{
    "model": "qwen2.5-coder:7b",
    "architecture": "simple",
    "total_test_time": 1136.1792800426483,
    "total_input_tokens": 87798,
    "total_output_tokens": 28115,
    "score": 8.396296296296297,
    "tokens_per_second": 24.745214504303103,
    "difficulty_stats": {
        "easy": {
            "total": 30,
            "passed": 10,
            "percentage": 33.33333333333333
        },
        "medium": {
            "total": 30,
            "passed": 0,
            "percentage": 0.0
        },
        "hard": {
            "total": 30,
            "passed": 0,
            "percentage": 0.0
        }
    },
    "completed_at": "2025-12-03T06:13:42.648522",
    "results": [
        {
            "question_id": "abc341_b",
            "difficulty": "easy",
            "total_time": 16.98353362083435,
            "code_generation_time": 11.024752140045166,
            "passed_tests": 6,
            "total_tests": 22,
            "success_rate": 0.27,
            "total_input_tokens": 1116,
            "total_output_tokens": 361,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    operations = []\n    index = N + 1\n    \n    for _ in range(N - 1):\n        S_i = int(data[index])\n        T_i = int(data[index + 1])\n        operations.append((S_i, T_i))\n        index += 2\n    \n    max_units_country_N = 0\n    \n    # Iterate over each operation starting from the last one\n    for j in reversed(range(len(operations))):\n        S_j, T_j = operations[j]\n        \n        if A[-1] >= S_j:\n            A[-1] -= S_j\n            A[-2] += T_j\n        \n        while True:\n            found_increase = False\n            \n            for k in range(j + 1, len(operations)):\n                S_k, T_k = operations[k]\n                \n                if A[k-1] < S_k or A[k] == 0:\n                    break\n                \n                A[k-1] -= S_k\n                A[k] += T_k\n                found_increase = True\n            \n            if not found_increase:\n                break\n        \n        max_units_country_N = max(max_units_country_N, A[N-1])\n\n    print(max_units_country_N)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "1899_B",
            "difficulty": "hard",
            "total_time": 11.461775541305542,
            "code_generation_time": 10.570651769638062,
            "passed_tests": 0,
            "total_tests": 39,
            "success_rate": 0.0,
            "total_input_tokens": 1399,
            "total_output_tokens": 316,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    t = int(input())\n    \n    def max_diff(n, a):\n        if n == 1:\n            return 0\n        \n        prefix_sum = [a[0]]\n        for i in range(1, n):\n            prefix_sum.append(prefix_sum[-1] + a[i])\n        \n        min_prefix = float('inf')\n        max_suffix = 0\n        result = 0\n        \n        for k in range(1, n // 2 + 1):\n            current_min = prefix_sum[k * (n // k) - 1]\n            current_max = prefix_sum[n-1] - current_min\n            \n            min_prefix = min(min_prefix, current_min)\n            max_suffix = max(max_suffix, current_max)\n            \n            result = max(result, abs(current_max - min_prefix), abs(current_min - max_suffix))\n        \n        return result\n    \n    results = []\n    for _ in range(t):\n        n = int(input().strip())\n        a = list(map(int, input().split()))\n        results.append(str(max_diff(n, a)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc332_b",
            "difficulty": "easy",
            "total_time": 9.390981197357178,
            "code_generation_time": 9.06212067604065,
            "passed_tests": 30,
            "total_tests": 30,
            "success_rate": 1.0,
            "total_input_tokens": 930,
            "total_output_tokens": 223,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    # Read input values\n    k, g, m = map(int, input().split())\n    \n    # Initialize variables\n    glass_water = 0\n    mug_water = 0\n    \n    # Perform the operations\n    while k > 0:\n        if glass_water == g:\n            glass_water = 0\n        elif mug_water == 0:\n            mug_water = m\n        else:\n            transfer_amount = min(mug_water, g - glass_water)\n            glass_water += transfer_amount\n            mug_water -= transfer_amount\n        \n        k -= 1\n    \n    # Print the final amounts of water in the glass and mug\n    print(glass_water, mug_water)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc337_e",
            "difficulty": "hard",
            "total_time": 10.348858118057251,
            "code_generation_time": 9.988956689834595,
            "passed_tests": 0,
            "total_tests": 25,
            "success_rate": 0.0,
            "total_input_tokens": 1322,
            "total_output_tokens": 276,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    # Read input\n    n = int(input())\n    \n    # Determine the minimum number of friends needed\n    m = 2\n    \n    # Distribute the juices\n    print(m)\n    print(1, 1)  # Friend 1 gets juice 1\n    print(n - 1, *range(2, n + 1))  # Friend 2 gets all other juices\n    \n    # Wait for response\n    s = input().strip()\n    \n    # Identify the bad juice based on responses\n    x_prime = None\n    if '1' not in s[1:]:\n        x_prime = 1\n    else:\n        x_prime = [i + 2 for i, c in enumerate(s[1:], start=2) if c == '1'][0]\n    \n    # Print the result\n    print(x_prime)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3207",
            "difficulty": "easy",
            "total_time": 9.658326625823975,
            "code_generation_time": 8.752590894699097,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 643,
            "total_output_tokens": 201,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    s1 = input().strip()\n    s2 = input().strip()\n    s3 = input().strip()\n\n    min_len = min(len(s1), len(s2), len(s3))\n    \n    i = 0\n    while i < min_len and s1[i] == s2[i] == s3[i]:\n        i += 1\n    \n    total_operations = (len(s1) - i) + (len(s2) - i) + (len(s3) - i)\n    \n    if i > 0:\n        print(total_operations)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2837",
            "difficulty": "medium",
            "total_time": 10.561742067337036,
            "code_generation_time": 9.732558250427246,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 697,
            "total_output_tokens": 268,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef min_operations(num1, num2):\n    if num1 < 0:\n        return -1\n    \n    target = abs(num1)\n    \n    def check_ops(ops):\n        remaining = target - ops * num2\n        bits_needed = bin(remaining).count('1')\n        return bits_needed == ops\n    \n    left, right = 0, max(target // num2, target.bit_length())\n    while left < right:\n        mid = (left + right) // 2\n        if check_ops(mid):\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left if check_ops(left) else -1\n\nif __name__ == \"__main__\":\n    input_line = sys.stdin.readline().strip()\n    nums = list(map(int, input_line.split()))\n    result = min_operations(nums[0], nums[1])\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "3331",
            "difficulty": "easy",
            "total_time": 9.238381624221802,
            "code_generation_time": 8.680708169937134,
            "passed_tests": 0,
            "total_tests": 57,
            "success_rate": 0.0,
            "total_input_tokens": 802,
            "total_output_tokens": 193,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    # Read input\n    line = sys.stdin.readline().strip()\n    nums = list(map(int, line.split()))\n    \n    line = sys.stdin.readline().strip()\n    k = int(line)\n    \n    # Convert nums into a min-heap in-place\n    heapq.heapify(nums)\n    \n    count = 0\n    while nums and nums[0] < k:\n        heapq.heappop(nums)  # Remove smallest element\n        count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc322_e",
            "difficulty": "hard",
            "total_time": 11.31301212310791,
            "code_generation_time": 10.719281435012817,
            "passed_tests": 4,
            "total_tests": 44,
            "success_rate": 0.09,
            "total_input_tokens": 1048,
            "total_output_tokens": 335,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    # Read input\n    n, k, p = map(int, input().split())\n    dp = [[float('inf')] * (p + 1) for _ in range(k)]\n    \n    for i in range(n):\n        c, *a = map(int, input().split())\n        \n        new_dp = [row[:] for row in dp]\n        for j in range(p + 1):\n            if dp[0][j] == float('inf'):\n                continue\n            \n            for l in range(1, k):\n                if j >= a[l]:\n                    new_dp[l][min(j - a[l], p)] = min(new_dp[l][min(j - a[l], p)], dp[l - 1][j])\n            \n            new_dp[0][max(0, j - a[0])] = min(new_dp[0][max(0, j - a[0])], dp[0][j] + c)\n        \n        dp = new_dp[:]\n    \n    result = min(dp[-1][:k+1])\n    print(result if result != float('inf') else -1)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc315_f",
            "difficulty": "hard",
            "total_time": 33.38206744194031,
            "code_generation_time": 12.19957160949707,
            "passed_tests": 0,
            "total_tests": 66,
            "success_rate": 0.0,
            "total_input_tokens": 1193,
            "total_output_tokens": 440,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom math import sqrt\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    points = [(int(data[i*2+1]), int(data[i*2+2])) for i in range(N)]\n    \n    def distance(p1, p2):\n        return sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n    \n    dp = [[float('inf')] * (N) for _ in range(1 << N)]\n    dp[(1<<0)] = [distance(points[0], points[j]) if j != 0 else float('-inf') for j in range(N)]\n    \n    for mask in range(1 << N):\n        for bit in range(N):\n            if not (mask & (1 << bit)):\n                continue\n            prev_mask = mask ^ (1 << bit)\n            dist_to_prev = min(dp[prev_mask][j] + distance(points[j], points[bit]) for j in range(bit))\n            dp[mask | (1 << bit)][bit] = dist_to_prev\n    \n    ans = float('inf')\n    for mask in range(1 << N):\n        C = bin(mask).count('1') - 1\n        penalty = 2**(C-1) if C > 0 else 0\n        last_checkpoint = max(j for j in range(N) if mask & (1 << j))\n        total_distance = dp[mask][(last_checkpoint)] + penalty\n        ans = min(ans, total_distance)\n    \n    print(f\"{ans:.15f}\")\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc335_a",
            "difficulty": "easy",
            "total_time": 9.22411298751831,
            "code_generation_time": 8.916660785675049,
            "passed_tests": 17,
            "total_tests": 17,
            "success_rate": 1.0,
            "total_input_tokens": 678,
            "total_output_tokens": 66,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    if len(s) >= 4 and s[-4:] == \"2023\":\n        s = s[:-1] + '4'\n    print(s)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc304_b",
            "difficulty": "easy",
            "total_time": 9.823918342590332,
            "code_generation_time": 9.513301134109497,
            "passed_tests": 6,
            "total_tests": 18,
            "success_rate": 0.33,
            "total_input_tokens": 859,
            "total_output_tokens": 243,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    n = int(input())\n    \n    if n <= 10**3 - 1:\n        pass\n    elif n <= 10**4 - 1:\n        n //= 10 * 10\n    elif n <= 10**5 - 1:\n        n //= 100 * 100\n    elif n <= 10**6 - 1:\n        n //= 1000 * 1000\n    elif n <= 10**7 - 1:\n        n //= 10000 * 10000\n    elif n <= 10**8 - 1:\n        n //= 100000 * 100000\n    \n    print(n)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc341_a",
            "difficulty": "easy",
            "total_time": 7.25078010559082,
            "code_generation_time": 7.0867369174957275,
            "passed_tests": 9,
            "total_tests": 9,
            "success_rate": 1.0,
            "total_input_tokens": 580,
            "total_output_tokens": 68,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef generate_sequence(N):\n    return \"1\" + \"\".join([\"01\"] * N) if N > 0 else \"\"\n\nif __name__ == \"__main__\":\n    import sys\n    N = int(sys.stdin.read().strip())\n    result = generate_sequence(N)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "2877",
            "difficulty": "medium",
            "total_time": 13.317664861679077,
            "code_generation_time": 12.406287431716919,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 743,
            "total_output_tokens": 473,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef overlap(s1, s2):\n    max_overlap = min(len(s1), len(s2))\n    while max_overlap > 0:\n        if s1[-max_overlap:] == s2[:max_overlap]:\n            break\n        max_overlap -= 1\n    return max_overlap\n\ndef merge(a, b, o):\n    return a + b[o:]\n\ndef solve():\n    input = sys.stdin.read().split()\n    a, b, c = input\n    \n    # Find overlaps between pairs\n    ab_overlaps = [overlap(a, b)]\n    ba_overlaps = [overlap(b, a)]\n    \n    ac_overlaps = [overlap(a, c)]\n    ca_overlaps = [overlap(c, a)]\n    \n    bc_overlaps = [overlap(b, c)]\n    cb_overlaps = [overlap(c, b)]\n    \n    best_length = float('inf')\n    best_string = \"\"\n    \n    # Try merging in different orders\n    candidates = [\n        (merge(merge(a, b, ab_overlaps[0]), c)),\n        (merge(merge(a, c, ac_overlaps[0]), b)),\n        (merge(merge(b, a, ba_overlaps[0]), c)),\n        \n        (merge(merge(b, c, bc_overlaps[0]), a)),\n        (merge(merge(c, a, ca_overlaps[0]), b)),\n        (merge(merge(c, b, cb_overlaps[0]), a))\n    ]\n    \n    for candidate in candidates:\n        current_length = len(candidate)\n        if current_length < best_length or (current_length == best_length and candidate < best_string):\n            best_length = current_length\n            best_string = candidate\n            \n    print(best_string)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2878",
            "difficulty": "medium",
            "total_time": 10.962618350982666,
            "code_generation_time": 9.999826192855835,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 691,
            "total_output_tokens": 280,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    n = int(input())\n    nums = list(map(int, input().split()))\n    k = int(input())\n\n    heap = []\n    \n    i = 0\n    while i < len(nums):\n        if nums[i] > 0:\n            diff = min(k - (i + k), len(nums) - i)\n            \n            # If we cannot reduce this element to zero in one go, return False\n            if nums[i] % diff != 0:\n                print(\"False\")\n                return\n            \n            heapq.heappush(heap, (-nums[i] // diff * diff, i))\n        \n        if heap and heap[0][1] == i:\n            _, start_index = heapq.heappop(heap)\n            end_index = start_index + abs(start_index - i)\n            decrease_value = nums[start_index] // (end_index - start_index)\n            for j in range(i, end_index):\n                nums[j] -= decrease_value\n        \n        i += 1\n    \n    print(\"True\")\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3263",
            "difficulty": "easy",
            "total_time": 12.779066801071167,
            "code_generation_time": 11.881664991378784,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 827,
            "total_output_tokens": 414,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    def min_cost_to_divide(nums):\n        n = len(nums)\n        \n        # Initialize prefix sums array\n        prefix_sums = [nums[0]]\n        for i in range(1, n):\n            prefix_sums.append(prefix_sums[-1] + nums[i])\n            \n        # Use two heaps to find the optimal split points\n        left_heap = [(prefix_sums[n - 1] - prefix_sums[j], j) for j in range(n)]\n        right_heap = []\n        \n        heapq.heapify(left_heap)\n        heapq.heappush(right_heap, (-prefix_sums[n - 1], n))\n        \n        result = float('inf')\n        \n        while True:\n            _, j = heapq.heappop(left_heap)\n            if j == 0 or not right_heap:\n                break\n            \n            k = right_heap[0][1]\n            current_sum = prefix_sums[k - 1] + prefix_sums[j - 1] - prefix_sums[k - 1] + nums[j - 1]\n            result = min(result, current_sum)\n            \n            new_right_value = -(prefix_sums[n - 1] - prefix_sums[k - 1]) + prefix_sums[j - 1]\n            heapq.heappush(right_heap, (new_right_value, j))\n    \n        return result\n        \n    input_line = sys.stdin.readline().strip()\n    nums = list(map(int, input_line.split()))\n    \n    output = min_cost_to_divide(nums)\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc339_d",
            "difficulty": "medium",
            "total_time": 13.910251140594482,
            "code_generation_time": 13.32312798500061,
            "passed_tests": 0,
            "total_tests": 52,
            "success_rate": 0.0,
            "total_input_tokens": 994,
            "total_output_tokens": 521,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque\n\ndef solve():\n    n = int(input().strip())\n    grid = [input().strip() for _ in range(n)]\n    \n    start_positions = []\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 'P':\n                start_positions.append((i, j))\n                \n    def get_neighbors(x, y):\n        neighbors = [(x+dx, y+dy) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]]\n        return filter(lambda pos: 0 <= pos[0] < n and 0 <= pos[1] < n and grid[pos[0]][pos[1]] != '#', neighbors)\n        \n    queue = deque([(start_positions[0], start_positions[1], 0)])\n    visited = set()\n    visited.add(start_positions[0])\n    visited.add(start_positions[1])\n\n    while queue:\n        x1, y1, steps = queue.popleft()\n\n        # Check if both players are at the same position\n        if (x1, y1) == tuple(sorted([tuple(pos) for pos in start_positions])):\n            break\n        \n        for nx1, ny1 in get_neighbors(x1, y1):\n            new_visited_1 = visited.copy()\n            new_visited_1.remove(tuple(sorted([tuple(pos) for pos in start_positions])[0]))\n            new_visited_1.add((nx1, ny1))\n\n            for nx2, ny2 in get_neighbors(*sorted([tuple(pos) for pos in start_positions])[::-1]):\n                new_state = ((nx1, ny1), (nx2, ny2), steps + 1)\n                if new_state not in visited or len(new_visited_1 & {new_state[1]} | {new_state[0]}) > 1:\n                    continue\n                    \n                visited |= new_visited_1.union({(nx2, ny2)})\n                queue.append(((nx1, ny1), (nx2, ny2), steps + 1))\n                    \n    else:\n        result = -1\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3309",
            "difficulty": "easy",
            "total_time": 10.040817975997925,
            "code_generation_time": 9.149560928344727,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 883,
            "total_output_tokens": 208,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    n = int(input())\n    words = [input().strip() for _ in range(n)]\n    \n    count = 0\n    \n    def is_prefix_and_suffix(str1, str2):\n        return str1 == str2[:len(str1)] and str1 == str2[-len(str1):]\n    \n    for i in range(n-1):\n        for j in range(i+1, n):\n            if is_prefix_and_suffix(words[i], words[j]):\n                count += 1\n                \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2873",
            "difficulty": "medium",
            "total_time": 12.77736234664917,
            "code_generation_time": 11.029127836227417,
            "passed_tests": 49,
            "total_tests": 94,
            "success_rate": 0.52,
            "total_input_tokens": 614,
            "total_output_tokens": 366,
            "error": null,
            "traceback": null,
            "code": "import math\nfrom typing import List\n\ndef sieve_of_eratosthenes(n):\n    primes = [True] * (n+1)\n    p = 2\n    while (p * p <= n):\n        if (primes[p] == True):\n            for i in range(p * p, n+1, p):\n                primes[i] = False\n        p += 1\n    prime_numbers = []\n    for p in range(2, n+1):\n        if primes[p]:\n            prime_numbers.append(p)\n    return prime_numbers\n\ndef find_prime_pairs_with_target_sum(n) -> List[List[int]]:\n    primes = set(sieve_of_eratosthenes(n))\n    result = []\n\n    for x in primes:\n        y = n - x\n        if y > x and y in primes:\n            result.append([x, y])\n\n    return result\n\nif __name__ == \"__main__\":\n    input_n = int(input().strip())\n    output = find_prime_pairs_with_target_sum(input_n)\n    print(output)",
            "history_file": null
        },
        {
            "question_id": "abc322_a",
            "difficulty": "easy",
            "total_time": 7.539156198501587,
            "code_generation_time": 7.379572629928589,
            "passed_tests": 8,
            "total_tests": 8,
            "success_rate": 1.0,
            "total_input_tokens": 678,
            "total_output_tokens": 73,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(input())\n    S = input().strip()\n\n    for i in range(N - 2):\n        if S[i:i + 3] == \"ABC\":\n            print(i + 1)\n            return\n    \n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3203",
            "difficulty": "hard",
            "total_time": 14.326623439788818,
            "code_generation_time": 13.470889806747437,
            "passed_tests": 0,
            "total_tests": 79,
            "success_rate": 0.0,
            "total_input_tokens": 1329,
            "total_output_tokens": 520,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    s = data[0]\n    q = int(data[1])\n    queries = []\n    index = 2\n    \n    for _ in range(q):\n        ai = int(data[index]) - 1\n        bi = int(data[index + 1]) - 1\n        ci = int(data[index + 2]) - 1\n        di = int(data[index + 3]) - 1\n        queries.append((ai, bi, ci, di))\n        index += 4\n    \n    def count_chars(s):\n        return sorted([char for char in s if char.isalpha()])\n    \n    half_n = len(s) // 2\n    left_half = count_chars(s[:half_n])\n    right_half = count_chars(s[half_n:])\n    \n    result = []\n    \n    for ai, bi, ci, di in queries:\n        sub_left = count_chars(s[ai:bi+1])\n        sub_right = count_chars(s[ci:di+1])\n        \n        combined_subleft = left_half[:]\n        combined_subright = right_half[:]\n        \n        # Try rearranging sub-left into sub-right and vice versa\n        can_rearrange = True\n        \n        while sub_left or sub_right:\n            if not sub_left:\n                if sub_right[-1] != combined_subright.pop(-1):\n                    can_rearrange = False\n                    break\n            elif not sub_right:\n                if sub_left[-1] != combined_subleft.pop(0):\n                    can_rearrange = False\n                    break\n            \n            if sub_left[-1] == combined_subright[-1]:\n                sub_left.pop()\n                combined_subright.pop()\n            else:\n                if sub_left[-1] < combined_subright[-1]:\n                    if not combined_subleft or combined_subleft[0] > sub_left[-1]:\n                        can_rearrange = False\n                        break\n                    combined_subleft.remove(combined_subleft[0])\n                else:\n                    if not combined_subright or combined_subright[-1] >= sub_left[-1]:\n                        can_rearrange = False\n                        break\n                    combined_subright.pop()\n            \n            if not can_rearrange:\n                break\n        \n        result.append(can_rearrange)\n    \n    output = ' '.join('true' if x else 'false' for x in result)\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3297",
            "difficulty": "medium",
            "total_time": 10.437261581420898,
            "code_generation_time": 9.592066049575806,
            "passed_tests": 30,
            "total_tests": 100,
            "success_rate": 0.3,
            "total_input_tokens": 856,
            "total_output_tokens": 222,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    word = input().strip()\n    k = int(input())\n    \n    n = len(word)\n    target_word = word\n    \n    def check_time(t):\n        current_word = word[:n - t * k]\n        return current_word == target_word[-len(current_word):] if t > 0 else False\n    \n    left, right = 1, n // k + 1\n    while left < right:\n        mid = (left + right) // 2\n        if check_time(mid):\n            right = mid\n        else:\n            left = mid + 1\n            \n    print(left)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3212",
            "difficulty": "hard",
            "total_time": 10.148106098175049,
            "code_generation_time": 9.285426378250122,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 719,
            "total_output_tokens": 217,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = 10**9 + 7\n\ndef count_good_partitions(nums):\n    n = len(nums)\n    last_occurrence = {}\n    \n    # Find the last occurrence index of each element in nums\n    for i, num in enumerate(nums):\n        last_occurrence[num] = i\n    \n    ans = 1\n    end_of_partition = -1\n    \n    for i, num in enumerate(nums):\n        end_of_partition = max(end_of_partition, last_occurrence[num])\n        \n        if i == end_of_partition:\n            ans *= 2\n            ans %= MOD\n    \n    return ans % MOD\n\nif __name__ == \"__main__\":\n    input_line = sys.stdin.readline().strip()\n    nums = list(map(int, input_line.split()))\n    result = count_good_partitions(nums)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc315_e",
            "difficulty": "hard",
            "total_time": 13.060522556304932,
            "code_generation_time": 10.970941066741943,
            "passed_tests": 0,
            "total_tests": 34,
            "success_rate": 0.0,
            "total_input_tokens": 1088,
            "total_output_tokens": 344,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    index += 1\n    \n    graph = [[] for _ in range(N + 1)]\n    indegree = [0] * (N + 1)\n    \n    for i in range(1, N + 1):\n        C_i = int(data[index])\n        index += 1\n        for j in range(C_i):\n            P_ij = int(data[index]) - 1\n            index += 1\n            graph[P_ij].append(i-1)\n            indegree[i-1] += 1\n    \n    queue = deque([i for i in range(N) if indegree[i] == 0])\n    result = []\n    \n    while queue:\n        node = queue.popleft()\n        result.append(node + 1)\n        \n        for neighbor in graph[node]:\n            indegree[neighbor] -= 1\n            if indegree[neighbor] == 0:\n                queue.append(neighbor)\n                \n    # Remove book 1 and reverse the remaining sequence\n    final_result = ' '.join(map(str, sorted(result)[1::][::-1]))\n    print(final_result.strip())\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc323_c",
            "difficulty": "medium",
            "total_time": 12.768232345581055,
            "code_generation_time": 12.309147834777832,
            "passed_tests": 2,
            "total_tests": 11,
            "success_rate": 0.18,
            "total_input_tokens": 1292,
            "total_output_tokens": 422,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    A = list(map(int, data[2:2+M]))\n    S = [data[i] for i in range(2+M, len(data))]\n    \n    results = []\n    \n    for i in range(N):\n        solved_score = sum(A[j-1] if S[i][j-1] == 'o' else 0 for j in range(M))\n        current_total = solved_score + i\n        \n        max_other_score = -float('inf')\n        \n        for other_i in range(N):\n            if other_i != i and all(S[other_i][j] == 'o' or S[i][j] == 'x' for j in range(M)):\n                other_solved_score = sum(A[j-1] if S[other_i][j-1] == 'o' else 0 for j in range(M))\n                other_current_total = other_solved_score + other_i\n                \n                if other_current_total > max_other_score:\n                    max_other_score = other_current_total\n        \n        needed_problems_to_solve = ((max_other_score - current_total) // min(A)) + 1\n        \n        # Ensure we don't exceed any player's score by solving more problems than available\n        remaining_unsolved = sum(1 for j in range(M) if S[i][j] == 'x')\n        needed_problems_to_solve = min(needed_problems_to_solve, remaining_unsolved)\n        \n        results.append(str(max(0, needed_problems_to_solve)))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3172",
            "difficulty": "easy",
            "total_time": 9.590059518814087,
            "code_generation_time": 8.783714532852173,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 866,
            "total_output_tokens": 158,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    n, m = map(int, input().split())\n    \n    total_sum = n * (n + 1) // 2\n    \n    # Sum of multiples of m within the range [1, n]\n    multiple_of_m_sum = ((n // m) * (m + n % m)) // 2\n    \n    result = total_sum - 2 * multiple_of_m_sum\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc305_b",
            "difficulty": "easy",
            "total_time": 14.220951080322266,
            "code_generation_time": 13.929884195327759,
            "passed_tests": 0,
            "total_tests": 11,
            "success_rate": 0.0,
            "total_input_tokens": 679,
            "total_output_tokens": 559,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import string\n    \n    point_distances = {\n        'B': {'A': 3},\n        'C': {'B': 1, 'A': 4},\n        'D': {'C': 4, 'B': 5, 'A': 8},\n        'E': {'D': 1, 'C': 5, 'B': 6, 'A': 9},\n        'F': {'E': 5, 'D': 6, 'C': 10, 'B': 11, 'A': 14},\n        'G': {'F': 9, 'E': 10, 'D': 11, 'C': 15, 'B': 16, 'A': 20}\n    }\n    \n    line_points = list(string.ascii_uppercase)[:7]\n    distances_between_consecutive_points = [3, 1, 4, 1, 5, 9]\n\n    def get_distance(p, q):\n        if p == q:\n            return 0\n        \n        start_index = min(line_points.index(p), line_points.index(q))\n        end_index = max(line_points.index(p), line_points.index(q))\n\n        total_distance = sum(distances_between_consecutive_points[start_index:end_index - 1])\n        \n        # If we are moving in reverse direction add remaining distance till last element\n        if start_index > end_index:\n            total_distance += sum(point_distances[line_points[end_index]][line_point] for line_point in reversed(line_points[:end_index]))\n            \n        return total_distance\n\n    p, q = input().split()\n    result = get_distance(p, q)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc340_a",
            "difficulty": "easy",
            "total_time": 8.747319221496582,
            "code_generation_time": 8.61079454421997,
            "passed_tests": 10,
            "total_tests": 10,
            "success_rate": 1.0,
            "total_input_tokens": 623,
            "total_output_tokens": 130,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef generate_arithmetic_sequence(A, B, D):\n    if (B - A) % D != 0:\n        raise ValueError(\"No valid arithmetic sequence can be generated.\")\n    \n    num_terms = ((B - A) // D) + 1\n    \n    return [str(A + i * D) for i in range(num_terms)]\n\nif __name__ == \"__main__\":\n    line = sys.stdin.readline().strip()\n    A, B, D = map(int, line.split())\n    \n    result = ' '.join(generate_arithmetic_sequence(A, B, D))\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc314_c",
            "difficulty": "medium",
            "total_time": 16.574211359024048,
            "code_generation_time": 11.334580183029175,
            "passed_tests": 2,
            "total_tests": 27,
            "success_rate": 0.07,
            "total_input_tokens": 1012,
            "total_output_tokens": 342,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import io\n    input = io.StringIO(sys.stdin.read()).readline\n    \n    n, m = map(int, input().split())\n    s = list(input().strip())\n    colors = [int(x) - 1 for x in input().strip().split()]\n    \n    # Create a dictionary to store indices of each color\n    index_map = [[] for _ in range(m)]\n    for i, c in enumerate(colors):\n        index_map[c].append(i)\n    \n    # Perform rotations based on the order of colors\n    for col in range(m):\n        if len(index_map[col]) > 0:\n            last_index = max(index_map[col])\n            first_index = min(index_map[col])\n            \n            # Rotate the segment between first and last occurrence of current color\n            rotated_segment = s[first_index:last_index + 1]\n            rotated_segment.reverse()\n            s[last_index] = rotated_segment[0]\n            del rotated_segment[0]\n            s[first_index:first_index+len(rotated_segment)] = rotated_segment\n            \n    # Join the list back into a string and output it\n    result = ''.join(s)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc336_b",
            "difficulty": "easy",
            "total_time": 7.7572314739227295,
            "code_generation_time": 7.537163257598877,
            "passed_tests": 0,
            "total_tests": 17,
            "success_rate": 0.0,
            "total_input_tokens": 634,
            "total_output_tokens": 61,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef ctz(n):\n    return n.bit_length() - len(bin(n).rstrip('0'))\n\nif __name__ == \"__main__\":\n    import sys\n    n = int(sys.stdin.read().strip())\n    result = ctz(n)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "2856",
            "difficulty": "medium",
            "total_time": 11.06430196762085,
            "code_generation_time": 10.062069177627563,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 615,
            "total_output_tokens": 270,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef count_complete_subarrays(nums):\n    total_count = len(set(nums))\n    \n    def at_most_k_distinct(k):\n        left = right = result = 0\n        counts = {}\n        \n        while right < len(nums):\n            if nums[right] not in counts:\n                k -= 1\n            counts[nums[right]] = counts.get(nums[right], 0) + 1\n            \n            while k < 0:\n                counts[nums[left]] -= 1\n                if counts[nums[left]] == 0:\n                    del counts[nums[left]]\n                    k += 1\n                left += 1\n                \n            result += right - left + 1\n            right += 1\n        \n        return result\n    \n    return at_most_k_distinct(total_count) - at_most_k_distinct(total_count - 1)\n\nif __name__ == \"__main__\":\n    input_line = sys.stdin.readline().strip()\n    nums = list(map(int, input_line.split()))\n    print(count_complete_subarrays(nums))",
            "history_file": null
        },
        {
            "question_id": "abc310_f",
            "difficulty": "hard",
            "total_time": 10.949764490127563,
            "code_generation_time": 10.480141878128052,
            "passed_tests": 3,
            "total_tests": 38,
            "success_rate": 0.08,
            "total_input_tokens": 1014,
            "total_output_tokens": 279,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    MOD = 998244353\n    \n    # Read input\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    dp = [0] * (n + 1)\n    dp[0] = 1\n    \n    for i in range(n):\n        new_dp = [0] * (n + 1)\n        for j in range(1, min(a[i], 10) + 1):\n            for k in range(j - 1, n):\n                new_dp[k + j] += dp[k]\n                new_dp[k + j] %= MOD\n        dp = new_dp[:]\n    \n    result = 0\n    for i in range(1, n + 1):\n        if i % 2 == 1:\n            result -= dp[n - i]\n        else:\n            result += dp[n - i]\n        result %= MOD\n    \n    if result < 0:\n        result += MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc333_e",
            "difficulty": "hard",
            "total_time": 21.69141173362732,
            "code_generation_time": 13.41640853881836,
            "passed_tests": 0,
            "total_tests": 44,
            "success_rate": 0.0,
            "total_input_tokens": 1695,
            "total_output_tokens": 472,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(input())\n    \n    potions = [False] * (N + 1)\n    max_potions = 0\n    \n    actions = []\n    \n    for _ in range(N):\n        t_i, x_i = map(int, input().split())\n        \n        if t_i == 1:\n            if not potions[x_i]:\n                potions[x_i] = True\n                actions.append(1)\n                max_potions += 1\n            else:\n                actions.append(0)\n        elif t_i == 2 and potions[x_i]:\n            potions[x_i] = False\n            max_potions -= 1\n        \n        # If at any point we have no more potions but still need one, return -1\n        if all(not p for p in potions) and sum(potions) > 0:\n            print(-1)\n            return\n    \n    min_k = max(max_potions, len([p for p in potions if p]))\n    print(min_k)\n    print(' '.join(map(str, actions)))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2867",
            "difficulty": "medium",
            "total_time": 10.749333143234253,
            "code_generation_time": 9.851493835449219,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 616,
            "total_output_tokens": 249,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = 10**9 + 7\n\ndef count_good_subarrays(nums):\n    n = len(nums)\n    indices_of_ones = []\n    \n    # Collect all indices where there is '1'\n    for i in range(n):\n        if nums[i] == 1:\n            indices_of_ones.append(i)\n    \n    num_ways = 1\n    \n    # Calculate the product of distances between consecutive ones\n    for i in range(1, len(indices_of_ones)):\n        distance = indices_of_ones[i] - indices_of_ones[i - 1]\n        num_ways *= distance\n        num_ways %= MOD\n    \n    return num_ways\n\nif __name__ == \"__main__\":\n    input_line = sys.stdin.readline().strip()\n    nums = list(map(int, input_line.split()))\n    result = count_good_subarrays(nums)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc324_e",
            "difficulty": "hard",
            "total_time": 14.187541961669922,
            "code_generation_time": 13.604771137237549,
            "passed_tests": 0,
            "total_tests": 40,
            "success_rate": 0.0,
            "total_input_tokens": 954,
            "total_output_tokens": 513,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    T = data[1]\n    strings = data[2:]\n    \n    count = 0\n    \n    def check(s):\n        i, t_idx = 0, 0\n        while i < len(s) and t_idx < len(T):\n            if s[i] == T[t_idx]:\n                t_idx += 1\n            i += 1\n        \n        return t_idx == len(T)\n    \n    total_length = sum(len(s) for s in strings)\n    \n    prefix_sums = [0] * (N + 1)\n    current_sum = 0\n    for i in range(N):\n        current_sum += len(strings[i])\n        prefix_sums[i+1] = current_sum\n    \n    suffix_counts = {}\n    for i in range(total_length - len(T) + 1):\n        substring = ''.join([strings[j][k-prefix_sums[j]] for j,k in enumerate(range(i,i+len(T)))])\n        if substring not in suffix_counts:\n            suffix_counts[substring] = []\n        \n        start_index = max(0, i-len(Suffix))\n        end_index = min(current_sum-1, i+len(suffix)-len(T)+1)\n        \n        for k in range(start_index, end_index):\n            if S[k].startswith(substring[:i-start_index]):\n                suffix_counts[substring].append(k)\n                \n    result = 0\n                \n    for key,value in suffix_counts.items():  \n        n=len(value)\n        result+=n*(n+1)//2\n            \n    print(result)\n\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc318_d",
            "difficulty": "medium",
            "total_time": 9.80018162727356,
            "code_generation_time": 9.544519186019897,
            "passed_tests": 0,
            "total_tests": 17,
            "success_rate": 0.0,
            "total_input_tokens": 1213,
            "total_output_tokens": 221,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom itertools import combinations\n\ndef solve():\n    N = int(input())\n    D = [list(map(int, input().split())) for _ in range(N-1)]\n    \n    max_weight = 0\n    \n    # Iterate over all possible subsets of edges\n    for r in range(1, N):\n        for subset in combinations(range(N), r*2):\n            weight = sum(D[i][j] if i < j else D[j][i] for i, j in zip(subset[::2], subset[1::2]))\n            max_weight = max(max_weight, weight)\n            \n    print(max_weight)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc343_c",
            "difficulty": "medium",
            "total_time": 9.676987886428833,
            "code_generation_time": 9.321335315704346,
            "passed_tests": 0,
            "total_tests": 29,
            "success_rate": 0.0,
            "total_input_tokens": 741,
            "total_output_tokens": 215,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef max_palindrome_cube(N):\n    left = int(N**(1/3))\n    right = -(-left // 1) + 1\n    \n    def is_palindrome(num):\n        return str(num) == str(num)[::-1]\n    \n    for k in range(left, right - 1, -1):\n        cube = k ** 3\n        if cube <= N and is_palindrome(cube):\n            return cube\n\nif __name__ == \"__main__\":\n    import sys\n    n = int(sys.stdin.read().strip())\n    result = max_palindrome_cube(n)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc309_e",
            "difficulty": "hard",
            "total_time": 14.00780177116394,
            "code_generation_time": 12.269249439239502,
            "passed_tests": 0,
            "total_tests": 51,
            "success_rate": 0.0,
            "total_input_tokens": 959,
            "total_output_tokens": 434,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    \n    # Read inputs\n    N = int(data[index])\n    M = int(data[index + 1])\n    parents = [int(x) - 1 for x in data[index + 2:index + N]]\n    insurances = []\n    for _ in range(M):\n        xi = int(data[index + N + (_ * 2)])\n        yi = int(data[index + N + (_ * 2) + 1])\n        insurances.append((xi - 1, yi))\n        index += 2\n    \n    # Initialize coverage set with all nodes initially uncovered\n    covered = {i for i in range(N)}\n    \n    # Process each insurance policy\n    for xi, yi in insurances:\n        queue = [(xi, yi)]\n        \n        while queue:\n            current_person, generations_left = queue.pop(0)\n            \n            if generations_left > 0:\n                children_indices = [j for j in range(current_person + 1, N) if parents[j] == current_person]\n                \n                for child_index in children_indices:\n                    if child_index not in covered:\n                        covered.add(child_index)\n                        queue.append((child_index, generations_left - 1))\n                    \n                    parent_of_child = parents[child_index]\n                    while parent_of_child != -1 and parent_of_child not in covered:\n                        covered.add(parent_of_child)\n                        queue.append((parent_of_child, generations_left - 1))\n                        parent_of_child = parents[parent_of_child]\n    \n    # The number of people covered by at least one insurance\n    result = len(covered)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc338_d",
            "difficulty": "hard",
            "total_time": 12.027973175048828,
            "code_generation_time": 11.113282918930054,
            "passed_tests": 0,
            "total_tests": 27,
            "success_rate": 0.0,
            "total_input_tokens": 1364,
            "total_output_tokens": 323,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    X = list(map(int, data[2:]))\n\n    # Calculate prefix sums of distances between consecutive visits\n    dists = [X[i] - X[i-1] if i > 0 else float('inf') for i in range(M)]\n    prefix_sums = [0]\n    current_sum = 0\n    for d in dists:\n        current_sum += d\n        prefix_sums.append(current_sum)\n        \n    min_length = float('inf')\n    total_distance = sum(dists) * 2\n    \n    # Iterate over each bridge that can be removed\n    for i in range(N):\n        left_dist = prefix_sums[M-1] + prefix_sums[N-i-1] - prefix_sums[(M+i)%N]\n        right_dist = prefix_sums[N-(i+1)-1] + prefix_sums[M-1] - prefix_sums[(i-M+N)%N]\n        length = total_distance - max(left_dist, right_dist)\n        min_length = min(min_length, length)\n    \n    print(min_length)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc329_f",
            "difficulty": "hard",
            "total_time": 15.680950403213501,
            "code_generation_time": 11.043011665344238,
            "passed_tests": 0,
            "total_tests": 42,
            "success_rate": 0.0,
            "total_input_tokens": 1001,
            "total_output_tokens": 329,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import collections\n    \n    # Read input\n    n, q = map(int, input().split())\n    colors = list(map(int, input().split()))\n    \n    boxes = [collections.defaultdict(set) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        boxes[i][colors[i - 1]].add(i)\n    \n    results = []\n    for _ in range(q):\n        a, b = map(int, input().split())\n        \n        if len(boxes[a]) == 0 or not any(colors[j] in boxes[b].keys() for j in boxes[a]):\n            continue\n        \n        moved_colors = set()\n        for c in boxes[a]:\n            if c in boxes[b]:\n                boxes[b][c].update(boxes[a][c])\n                del boxes[a][c]\n            else:\n                boxes[b][c] |= boxes[a][c]\n            \n            moved_colors.update(c for c in boxes[b][c])\n        \n        results.append(len(moved_colors))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc306_c",
            "difficulty": "medium",
            "total_time": 10.362788200378418,
            "code_generation_time": 9.743115901947021,
            "passed_tests": 3,
            "total_tests": 16,
            "success_rate": 0.19,
            "total_input_tokens": 893,
            "total_output_tokens": 234,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import bisect\n    \n    # Read input\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    # Find middle indices for each number\n    mid_indices = {}\n    count = [0] * (n + 1)\n    for j, x in enumerate(a):\n        if count[x] == 1:\n            mid_indices[x] = j\n        elif count[x] == 2:\n            continue\n        else:\n            count[x] += 1\n    \n    # Sort numbers based on their middle index\n    sorted_numbers = sorted(mid_indices.keys(), key=lambda x: mid_indices[x])\n    \n    # Print result\n    print(' '.join(map(str, sorted_numbers)))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc331_b",
            "difficulty": "easy",
            "total_time": 12.122648477554321,
            "code_generation_time": 11.81427550315857,
            "passed_tests": 0,
            "total_tests": 22,
            "success_rate": 0.0,
            "total_input_tokens": 686,
            "total_output_tokens": 390,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    n = int(input())\n    s, m, l = map(int, input().split())\n\n    min_cost = float('inf')\n    \n    # Iterate over possible numbers of large packs (L) we could buy\n    for i in range(n // 12 + 1):\n        remaining_eggs_after_large_packs = n - i * 12\n        \n        # Iterate over possible numbers of medium packs (M) we could buy with the remainder\n        for j in range((remaining_eggs_after_large_packs + 7) // 8):  # Adding 7 ensures integer division rounds up\n            remaining_eggs_after_medium_and_large_packs = remaining_eggs_after_large_packs - j * 8\n            \n            if remaining_eggs_after_medium_and_large_packs <= 0:\n                cost = i * l + j * m\n                heapq.heappush(min_heap, (-cost))\n            \n            else:\n                small_packs_needed = remaining_eggs_after_medium_and_large_packs // 6\n                extra_small_pack_if_any = 1 if remaining_eggs_after_medium_and_large_packs % 6 != 0 else 0\n                \n                total_extra_small_packs = small_packs_needed + extra_small_pack_if_any\n                cost = i * l + j * m + total_extra_small_packs * s\n                heapq.heappush(min_heap, (-cost))\n\n    result = abs(min_heap[0])\n    print(result)\n\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2869",
            "difficulty": "medium",
            "total_time": 11.78579044342041,
            "code_generation_time": 10.892119646072388,
            "passed_tests": 0,
            "total_tests": 83,
            "success_rate": 0.0,
            "total_input_tokens": 901,
            "total_output_tokens": 323,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    nums1 = list(map(int, data[1:n+1]))\n    nums2 = list(map(int, data[n+1:2*n+1]))\n    \n    dp1 = [1] * n\n    dp2 = [1] * n\n    \n    max_length = 1\n    \n    for i in range(1, n):\n        if nums1[i] >= nums1[i-1]:\n            dp1[i] = dp1[i-1] + 1\n        \n        if nums2[i] >= nums2[i-1]:\n            dp2[i] = dp2[i-1] + 1\n            \n        if nums1[i] >= nums2[i-1]:\n            dp1[i] = max(dp1[i], dp2[i-1] + 1)\n        \n        if nums2[i] >= nums1[i-1]:\n            dp2[i] = max(dp2[i], dp1[i-1] + 1)\n            \n        max_length = max(max_length, dp1[i], dp2[i])\n    \n    print(max_length)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc332_d",
            "difficulty": "hard",
            "total_time": 14.315070867538452,
            "code_generation_time": 13.845977544784546,
            "passed_tests": 3,
            "total_tests": 38,
            "success_rate": 0.08,
            "total_input_tokens": 2615,
            "total_output_tokens": 463,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    H, W = map(int, input().split())\n    \n    A = [list(map(int, input().strip().split())) for _ in range(H)]\n    B = [list(map(int, input().strip().split())) for _ in range(H)]\n\n    # Check if it's possible to make grid A identical to grid B by swapping rows and columns\n    def is_possible(A, B):\n        return sorted([cell for row in A for cell in row]) == sorted([cell for row in B for cell in row])\n\n    if not is_possible(A, B):\n        print(-1)\n        return\n    \n    min_operations = float('inf')\n    \n    # Try all permutations of rows and columns\n    import itertools\n    for perm_rows in itertools.permutations(range(1, H)):\n        for perm_cols in itertools.permutations(range(1, W)):\n            current_A = [[A[i][j] for j in perm_cols] for i in perm_rows]\n            operations = (H - len(set(perm_rows))) + (W - len(set(perm_cols)))\n            if current_A == B:\n                min_operations = min(min_operations, operations)\n\n    print(min_operations) if min_operations != float('inf') else None\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc322_c",
            "difficulty": "medium",
            "total_time": 20.12551212310791,
            "code_generation_time": 19.102783918380737,
            "passed_tests": 2,
            "total_tests": 27,
            "success_rate": 0.07,
            "total_input_tokens": 3501,
            "total_output_tokens": 897,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    # Read input from Standard Input (stdin)\n    n, m = map(int, input().split())\n    fireworks_days = [int(x) for x in input().split()]\n\n    # Create an empty list to store the number of days until the next firework launch starting from each day\n    results = []\n    \n    # Loop through each day up to the last day when fireworks are guaranteed to be launched\n    current_time = 0\n    index = 0\n    \n    for i in range(n):\n        if i >= fireworks_days[index]:\n            index += 1\n        \n        if index > 0:\n            current_time = fireworks_days[index - 1]\n            \n        results.append(current_time - i)\n    \n    # Print the results one per line\n    for res in results:\n        print(res)\n\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3094",
            "difficulty": "medium",
            "total_time": 22.021161317825317,
            "code_generation_time": 20.601327419281006,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 1826,
            "total_output_tokens": 545,
            "error": null,
            "traceback": null,
            "code": "import collections\nimport heapq\nimport math\nfrom typing import *\nimport sys\n\ndef solve():\n    input_line = sys.stdin.read().rstrip('\\n')\n    nums = list(map(int, input_line.split()))\n\n    count_map = collections.Counter(nums)\n\n    total_operations = 0\n    \n    for value_count in count_map.values():\n        if value_count == 1:\n            return -1\n        \n        # Calculate the minimum operations needed using a greedy approach\n        while value_count > 0:\n            if value_count % 3 != 0:\n                value_count -= 1\n            else:\n                value_count //= 3\n            \n            total_operations += 1\n    \n    return total_operations\n\nif __name__ == \"__main__\":\n    result = solve()\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc312_b",
            "difficulty": "easy",
            "total_time": 12.93266773223877,
            "code_generation_time": 12.634061336517334,
            "passed_tests": 0,
            "total_tests": 14,
            "success_rate": 0.0,
            "total_input_tokens": 1377,
            "total_output_tokens": 438,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N, M = map(int, input().split())\n    grid = [input()[:-1] for _ in range(N)]\n    \n    def is_tak_code(i, j):\n        # Check top-left and bottom-right three-by-three regions\n        if i + 5 >= N or j + 5 >= M:\n            return False\n        \n        topLeftBlack = all(grid[x][y] == '#' for x in range(3) for y in range(3))\n        botRightWhite = all(grid[i+6+x][j+6+y] != '#' for x in range(-1, 4) for y in range(-1, 4)) and \\\n                        any(grid[i+6+x][j+6+y] == '#' for x in [-1, 0, 1] for y in [-1, 0, 1])\n        \n        # Check adjacent cells\n        adjCells = [(i-1,j), (i+1,j), (i,j-1), (i,j+1),\n                    (i-1,j-1),(i-1,j+1),(i+1,j-1),(i+1,j+1)]\n        adjAllWhite = all((grid[r][c] != '#') for r,c in adjCells)\n        \n        return topLeftBlack and botRightWhite and adjAllWhite\n    \n    tak_codes = []\n    for i in range(N - 8):\n        for j in range(M - 8):\n            if is_tak_code(i, j):\n                tak_codes.append(f\"{i} {j}\")\n                \n    print(\"\\n\".join(tak_codes))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "1899_C",
            "difficulty": "hard",
            "total_time": 12.166677713394165,
            "code_generation_time": 11.01803708076477,
            "passed_tests": 9,
            "total_tests": 106,
            "success_rate": 0.08,
            "total_input_tokens": 948,
            "total_output_tokens": 315,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    while index < len(data):\n        n = int(data[index])\n        index += 1\n        \n        arr = list(map(int, data[index:index + n]))\n        index += n\n        \n        max_sum = float('-inf')\n        \n        # Try starting with an odd number and then even numbers\n        current_sum_odd_starting = 0\n        current_sum_even_starting = 0\n        \n        for i in range(n):\n            if i % 2 == 0:\n                current_sum_odd_starting += arr[i]\n                current_sum_even_starting -= arr[i] * 2\n            else:\n                current_sum_odd_starting -= arr[i] * 2\n                current_sum_even_starting += arr[i]\n            \n            max_sum = max(max_sum, current_sum_odd_starting)\n            max_sum = max(max_sum, current_sum_even_starting)\n        \n        results.append(max_sum)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3228",
            "difficulty": "medium",
            "total_time": 11.612261056900024,
            "code_generation_time": 10.818082809448242,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 991,
            "total_output_tokens": 294,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    nums1 = list(map(int, data[1:n+1]))\n    nums2 = list(map(int, data[n+1:2*n+1]))\n    \n    unique_nums1 = len(set(nums1))\n    unique_nums2 = len(set(nums2))\n    common_elements = len(set(nums1) & set(nums2))\n    \n    max_size = min(unique_nums1 + unique_nums2 - common_elements, n)\n    if max_size > n // 2:\n        return n\n    \n    remaining_to_remove_from_1 = n // 2 - (unique_nums1 - common_elements)\n    remaining_to_remove_from_2 = n // 2 - (unique_nums2 - common_elements)\n    \n    if remaining_to_remove_from_1 < 0 or remaining_to_remove_from_2 < 0:\n        return n\n    \n    return max_size\n\nif __name__ == \"__main__\":\n    result = solve()\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc318_b",
            "difficulty": "easy",
            "total_time": 11.113673210144043,
            "code_generation_time": 10.820560932159424,
            "passed_tests": 1,
            "total_tests": 21,
            "success_rate": 0.05,
            "total_input_tokens": 877,
            "total_output_tokens": 297,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    n = int(input())\n    events = []\n    \n    # Collect all vertical edges\n    for i in range(n):\n        a, b, c, d = map(int, input().split())\n        events.append((a, 'start', i))\n        events.append((b, 'end', i))\n    \n    # Sort events by x-coordinate; if equal, end events come before start events\n    events.sort()\n    \n    active_sheets = set()\n    current_y_sum = 0\n    total_area = 0\n    \n    prev_x = None\n    for x, event_type, sheet_index in events:\n        if prev_x is not None:\n            width = x - prev_x\n            height_diff = sum(1 for s in active_sheets)\n            \n            if height_diff > 0:\n                total_area += width * height_diff\n        \n        if event_type == 'start':\n            active_sheets.add(sheet_index)\n        else:\n            active_sheets.remove(sheet_index)\n        \n        prev_x = x\n    \n    print(total_area)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc333_c",
            "difficulty": "medium",
            "total_time": 19.95619225502014,
            "code_generation_time": 9.756385326385498,
            "passed_tests": 0,
            "total_tests": 17,
            "success_rate": 0.0,
            "total_input_tokens": 637,
            "total_output_tokens": 239,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef generate_repunits(n):\n    return [int('1' * i) for i in range(1, n+1)]\n\ndef find_nth_sum_of_three_repunits(N):\n    max_val = 3000  # Upper bound based on constraints\n    repunits = generate_repunits(max_val)\n    \n    sums = set(a + b + c for a in repunits for b in repunits for c in repunits if a <= b <= c)\n    sorted_sums = sorted(sums)\n    \n    return sorted_sums[N - 1]\n\nif __name__ == \"__main__\":\n    import fileinput\n    with fileinput.input() as f:\n        N = int(f.readline().strip())\n        \n    result = find_nth_sum_of_three_repunits(N)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc314_b",
            "difficulty": "easy",
            "total_time": 11.934919118881226,
            "code_generation_time": 11.631181955337524,
            "passed_tests": 0,
            "total_tests": 20,
            "success_rate": 0.0,
            "total_input_tokens": 1158,
            "total_output_tokens": 321,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    # Read input\n    n = int(input())\n    min_bets = float('inf')\n    winners = []\n    \n    for _ in range(n):\n        c = int(input())\n        bets = set(map(int, input().split()))\n        \n        if X in bets:\n            if len(bets) < min_bets:\n                min_bets = len(bets)\n                winners = [n + 1]\n            elif len(bets) == min_bets:\n                winners.append(n + 1)\n                \n    # Print output\n    K = len(winners)\n    print(K)\n    if K > 0:\n        print(\" \".join(str(w - 1) for w in sorted(winners)))\n\nif __name__ == \"__main__\":\n    global X\n    N = int(sys.stdin.readline())\n    C_1 = list(map(int, sys.stdin.readline().strip().split()))[0]\n    A_1 = list(map(int, sys.stdin.readline().strip().split()))\n    C_X = list(map(int, sys.stdin.readline().strip().split()))[0]\n    A_X = list(map(int, sys.stdin.readline().strip().split()))\n    X = list(map(int, sys.stdin.readline().strip().split()))[0]\n\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc324_d",
            "difficulty": "hard",
            "total_time": 20.624465227127075,
            "code_generation_time": 9.978958129882812,
            "passed_tests": 14,
            "total_tests": 43,
            "success_rate": 0.33,
            "total_input_tokens": 950,
            "total_output_tokens": 232,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom itertools import permutations\n\ndef solve():\n    n = int(input())\n    s = input().strip()\n    \n    def is_square(num):\n        root = num ** 0.5\n        return int(root + 0.5) ** 2 == num\n    \n    count = set()\n    perms = permutations(s)\n    for perm in perms:\n        value = sum(int(digit) * 10**(n-idx-1) for idx, digit in enumerate(perm))\n        if is_square(value):\n            count.add(value)\n    \n    print(len(count))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3019",
            "difficulty": "easy",
            "total_time": 8.81847333908081,
            "code_generation_time": 8.024725437164307,
            "passed_tests": 10,
            "total_tests": 100,
            "success_rate": 0.1,
            "total_input_tokens": 674,
            "total_output_tokens": 96,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    moves = input().strip()\n    \n    max_distance = 0\n    current_position = 0\n    \n    for move in moves:\n        if move == 'L':\n            current_position -= 1\n        elif move == 'R':\n            current_position += 1\n        \n        max_distance = max(max_distance, abs(current_position))\n    \n    print(max_distance)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc334_d",
            "difficulty": "medium",
            "total_time": 11.446791410446167,
            "code_generation_time": 10.380071640014648,
            "passed_tests": 0,
            "total_tests": 24,
            "success_rate": 0.0,
            "total_input_tokens": 958,
            "total_output_tokens": 245,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    # Read input\n    n, q = map(int, input().split())\n    r = list(map(int, input().split()))\n    \n    # Create a min heap of negative requirements\n    pq = [-x for x in r]\n    heapq.heapify(pq)\n    \n    results = []\n    for _ in range(q):\n        x = int(input())\n        \n        count = 0\n        while pq and -pq[0] <= x:\n            x -= (-heapq.heappop(pq))\n            count += 1\n        \n        if not pq or -pq[0] > x:\n            break\n        \n        results.append(count + len(r) - len(results))\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc309_c",
            "difficulty": "medium",
            "total_time": 23.31608748435974,
            "code_generation_time": 12.942275285720825,
            "passed_tests": 2,
            "total_tests": 27,
            "success_rate": 0.07,
            "total_input_tokens": 1514,
            "total_output_tokens": 423,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    days_and_pills = []\n    index = 2\n    for _ in range(N):\n        a_i = int(data[index])\n        b_i = int(data[index + 1])\n        days_and_pills.append((a_i, b_i))\n        index += 2\n    \n    # Sort by day of prescription\n    days_and_pills.sort(key=lambda x: -x[0])\n    \n    current_day = 1\n    total_pills = sum(b_i * (current_day // a_i) if current_day % a_i == 0 else b_i * ((current_day // a_i) + 1)\n                      for _, b_i in days_and_pills)\n    \n    while True:\n        found = False\n        for i in range(len(days_and_pills)):\n            a_i, b_i = days_and_pills[i]\n            pills_to_take_today = min(current_day // a_i, b_i)\n            \n            if total_pills <= K and not found:\n                result = current_day\n                found = True\n            \n            total_pills -= pills_to_take_today\n        \n        if found or total_pills < 0:\n            break\n        \n        current_day += 1\n        total_pills += sum(min(day // a_i, b_i) for day, (_, b_i) in zip(range(1, current_day), days_and_pills))\n\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc343_b",
            "difficulty": "easy",
            "total_time": 9.80516242980957,
            "code_generation_time": 9.584137439727783,
            "passed_tests": 14,
            "total_tests": 14,
            "success_rate": 1.0,
            "total_input_tokens": 1028,
            "total_output_tokens": 198,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    # Read input\n    n = int(input())\n    adjacency_matrix = [list(map(int, input().split())) for _ in range(n)]\n    \n    # Process each vertex\n    for i in range(1, n + 1):\n        neighbors = []\n        for j in range(1, n + 1):\n            if adjacency_matrix[i-1][j-1] == 1:\n                neighbors.append(j)\n        \n        # Print sorted list of neighbors\n        print(' '.join(str(x) for x in neighbors))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc333_a",
            "difficulty": "easy",
            "total_time": 7.295150995254517,
            "code_generation_time": 7.174107074737549,
            "passed_tests": 7,
            "total_tests": 7,
            "success_rate": 1.0,
            "total_input_tokens": 499,
            "total_output_tokens": 41,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    n = int(input())\n    result = str(n) * n\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc312_c",
            "difficulty": "medium",
            "total_time": 14.768100500106812,
            "code_generation_time": 11.556450843811035,
            "passed_tests": 0,
            "total_tests": 41,
            "success_rate": 0.0,
            "total_input_tokens": 885,
            "total_output_tokens": 333,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import bisect\n    \n    # Read input\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    # Sort both lists\n    a.sort()\n    b.sort(reverse=True)\n    \n    max_price = min(max(a), max(b))\n    ans = -1\n    \n    # Binary search for the minimum X that satisfies the condition\n    left, right = 0, max_price + 1\n    while left < right:\n        mid = (left + right) // 2\n        \n        # Count number of people who can sell at least mid price\n        num_sellers_can_sell_mid_or_more = len([x for x in a if x >= mid])\n        \n        # Count number of people who can buy at most mid price\n        num_buyers_can_buy_mid_or_less = len([y for y in b if y <= mid])\n        \n        if num_sellers_can_sell_mid_or_more >= num_buyers_can_buy_mid_or_less:\n            ans = mid\n            right = mid\n        else:\n            left = mid + 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc312_f",
            "difficulty": "hard",
            "total_time": 29.40396213531494,
            "code_generation_time": 13.808000564575195,
            "passed_tests": 2,
            "total_tests": 43,
            "success_rate": 0.05,
            "total_input_tokens": 1031,
            "total_output_tokens": 520,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    N, M = map(int, input().split())\n    \n    pull_tab_cans = []\n    regular_cans = []\n    openers = []\n    \n    for _ in range(N):\n        T, X = map(int, input().split())\n        if T == 0:\n            pull_tab_cans.append(X)\n        elif T == 1:\n            regular_cans.append((X, -1))\n        else:\n            openers.append((-X, -1))  # Negative because we'll be using min-heap as max-heap\n            \n    heapq.heapify(pull_tab_cans)\n    heapq.heapify(regular_cans)\n    heapq.heapify(openers)\n    \n    total_happiness = 0\n    used_openers = set()\n    \n    while len(used_openers) < M and any([pull_tab_cans, regular_cans]):\n        \n        can_opener_count = sum(-x[0] for x in openers if id(x) not in used_openers)\n        \n        if can_opener_count > 0:\n            \n            best_can_to_use_with_opener = None\n            best_gain_from_using_opener = float('-inf')\n            \n            for i in range(len(regular_cans)):\n                gain = regular_cans[i][0]\n                \n                remaining_openers_needed = (-regular_cans[i][1]) // can_opener_count\n                \n                if remaining_openers_needed <= 0 or remaining_openers_needed >= can_opener_count + 1:\n                    continue\n                    \n                new_total_gains = (remaining_openers_needed * gain +\n                                   ((can_opener_count - remaining_openers_needed) *\n                                    pull_tab_cans[-1]))\n                    \n                if new_total_gains > best_gain_from_using_opener:\n                    best_gain_from_using_opener = new_total_gains\n                    best_can_to_use_with_opener = i\n        \n            if best_can_to_use_with_opener is not None:\n                _, count_used = regular_cans.pop(best_can_to_use_with_opener)\n                count_used += can_opener_count\n                regular_cans.insert(best_can_to_use_with_opener, (_, count_used))\n                total_happiness += best_gain_from_using_opener\n                used_openers.update(range(id(openers[x]), id(openers[min(can_opener_count, len(openers)-1)])))\n        \n        else:\n            break\n    \n    return total_happiness\n\n\nif __name__ == \"__main__\":\n    print(solve())",
            "history_file": null
        },
        {
            "question_id": "3225",
            "difficulty": "medium",
            "total_time": 10.907326698303223,
            "code_generation_time": 9.96994662284851,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 879,
            "total_output_tokens": 238,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    nums = list(map(int, data[2:]))\n\n    left = 0\n    freq = {}\n    max_length = 0\n    \n    for right in range(n):\n        if nums[right] not in freq:\n            freq[nums[right]] = 0\n        \n        while freq[nums[right]] >= k:\n            freq[nums[left]] -= 1\n            if freq[nums[left]] == 0:\n                del freq[nums[left]]\n            left += 1\n        \n        freq[nums[right]] += 1\n        max_length = max(max_length, right - left + 1)\n    \n    print(max_length)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc303_e",
            "difficulty": "hard",
            "total_time": 15.217085599899292,
            "code_generation_time": 13.415900468826294,
            "passed_tests": 0,
            "total_tests": 18,
            "success_rate": 0.0,
            "total_input_tokens": 1120,
            "total_output_tokens": 467,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    def find(parents, x):\n        if parents[x] != x:\n            parents[x] = find(parents, parents[x])\n        return parents[x]\n    \n    N = int(input())\n    edges = []\n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n    \n    # Initialize parent array and rank array\n    parents = list(range(2 * N + 1))\n    ranks = [0] * (2 * N + 1)\n    \n    star_levels = {}\n    \n    for u, v in edges:\n        pu = find(parents, u)\n        pv = find(parents, v)\n        \n        if pu == pv:\n            continue\n        \n        if ranks[pu] > ranks[pv]:\n            parents[pv] = pu\n            ranks[pu] += 1\n            \n            level_u = max(star_levels.get(pu, 0), 1) + 1\n            level_v = max(star_levels.get(pv, 0), 1) + 1\n            min_level = min(level_u, level_v)\n            \n            star_levels[min_level] = star_levels.setdefault(min_level, 0) + 1\n        else:\n            parents[pu] = pv\n            ranks[pv] += 1\n            \n            level_u = max(star_levels.get(u, 0), 1) + 1\n            level_v = max(star_levels.get(v, 0), 1) + 1\n            min_level = min(level_u, level_v)\n            \n            star_levels[min_level] = star_levels.setdefault(min_level, 0) + 1\n    \n    levels = sorted(list(star_levels.keys()))\n    result = ' '.join(map(str, levels))\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc305_a",
            "difficulty": "easy",
            "total_time": 7.729597091674805,
            "code_generation_time": 7.580681562423706,
            "passed_tests": 0,
            "total_tests": 7,
            "success_rate": 0.0,
            "total_input_tokens": 695,
            "total_output_tokens": 60,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef find_nearest_water_station(N):\n    return round((N + 4) / 5 * 5)\n\nif __name__ == \"__main__\":\n    N = int(input())\n    result = find_nearest_water_station(N)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "2884",
            "difficulty": "hard",
            "total_time": 19.091261863708496,
            "code_generation_time": 10.21279788017273,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 720,
            "total_output_tokens": 260,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().splitlines()\n\n    word = data[0]\n    forbidden = set(data[1:])\n    \n    n = len(word)\n    max_length = 0\n    \n    def check_valid(start):\n        end = start + min(30, n - start)  # Check up to next 30 characters\n        while end > start:\n            sub = word[start:end]\n            if any(sub.find(f) != -1 for f in forbidden):\n                return False\n            end -= 1\n        return True\n    \n    left = right = 0\n    while right < n:\n        if not check_valid(right):\n            left += 1\n        else:\n            right += 1\n        \n        max_length = max(max_length, right - left)\n    \n    print(max_length)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2866",
            "difficulty": "easy",
            "total_time": 10.94734787940979,
            "code_generation_time": 10.126888036727905,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 857,
            "total_output_tokens": 243,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    input_line = sys.stdin.readline().strip()\n    nums = list(map(int, input_line.split()))\n    \n    threshold = int(sys.stdin.readline().strip())\n    \n    max_length = 0\n    \n    n = len(nums)\n    i = 0\n    \n    while i < n:\n        if nums[i] % 2 == 0 and nums[i] <= threshold:\n            start = i\n            end = i\n            \n            # Extend the subarray as long as it meets the criteria\n            while end + 1 < n and abs((nums[end+1]) % 2 - (nums[end])) % 2 != 0 and nums[end+1] <= threshold:\n                end += 1\n                \n            max_length = max(max_length, end - start + 1)\n        \n        i += 1\n    \n    print(max_length)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3320",
            "difficulty": "easy",
            "total_time": 10.313745975494385,
            "code_generation_time": 9.499481678009033,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 689,
            "total_output_tokens": 199,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    n = int(input())\n    nums = list(map(int, input().split()))\n    \n    if len(nums) < 2:\n        return 0\n    \n    target_score = nums[0] + nums[1]\n    count = 1\n    \n    for i in range(2, len(nums), 2):\n        if i+1 >= len(nums) or nums[i] + nums[i+1] != target_score:\n            break\n        count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc315_b",
            "difficulty": "easy",
            "total_time": 11.063486814498901,
            "code_generation_time": 10.78328800201416,
            "passed_tests": 24,
            "total_tests": 24,
            "success_rate": 1.0,
            "total_input_tokens": 934,
            "total_output_tokens": 277,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    # Read input\n    m = int(input())\n    d_list = list(map(int, input().split()))\n    \n    # Calculate cumulative sum of days up to each month\n    cum_sum = [sum(d_list[:i]) for i in range(1, len(d_list) + 1)]\n    \n    # Find the middle index\n    mid_index = (cum_sum[-1] // 2) + 1\n    \n    # Determine the month and day corresponding to the middle index\n    if mid_index <= cum_sum[0]:\n        month = 1\n        day = mid_index\n    else:\n        for i in range(m - 1):\n            if cum_sum[i] < mid_index <= cum_sum[i + 1]:\n                month = i + 2\n                day = mid_index - cum_sum[i]\n                break\n    \n    # Print result\n    print(month, day)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc313_a",
            "difficulty": "easy",
            "total_time": 10.169768571853638,
            "code_generation_time": 9.959805011749268,
            "passed_tests": 2,
            "total_tests": 12,
            "success_rate": 0.17,
            "total_input_tokens": 690,
            "total_output_tokens": 233,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    \n    def main(input):\n        lines = iter(input.splitlines())\n        \n        n = int(next(lines))\n        p_list = list(map(int, next(lines).split()))\n        \n        max_p = max(p_list[1:])\n        if p_list[0] >= max_p:\n            return 0\n        \n        required_points = max_p - p_list[0]\n        return required_points\n\n    # Read input and call the function\n    result = main(sys.stdin.read().strip())\n\n    # Print the output\n    print(result)\n\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc329_e",
            "difficulty": "hard",
            "total_time": 11.17388105392456,
            "code_generation_time": 10.582741022109985,
            "passed_tests": 21,
            "total_tests": 48,
            "success_rate": 0.44,
            "total_input_tokens": 765,
            "total_output_tokens": 281,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    S = data[2]\n    T = data[3]\n\n    dp = [False] * (N + 1)\n    dp[0] = True\n    \n    for i in range(1, N + 1):\n        if not dp[i - 1]:\n            continue\n        \n        for j in range(max(i - M, 0), i):\n            if all(S[j+k] == '#' or S[j+k] == T[k-j+i-M+1] for k in range(M)):\n                dp[i] = True\n                break\n                \n    print(\"Yes\" if dp[N] else \"No\")\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3223",
            "difficulty": "hard",
            "total_time": 12.931556940078735,
            "code_generation_time": 11.977305173873901,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 641,
            "total_output_tokens": 378,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef count_complete_substrings(word, k):\n    def check(length):\n        char_count = [0] * 26\n        unique_chars = set()\n        \n        left = right = result = 0\n        \n        while right < len(word):\n            index_right = ord(word[right]) - ord('a')\n            char_count[index_right] += 1\n            \n            if char_count[index_right] == k:\n                unique_chars.add(index_right)\n            \n            while len(unique_chars) > length or max(char_count[i] for i in range(26)) != min(k, max(char_count)):\n                index_left = ord(word[left]) - ord('a')\n                char_count[index_left] -= 1\n                \n                if char_count[index_left] == k-1:\n                    unique_chars.remove(index_left)\n                \n                left += 1\n            \n            result += right - left + 1\n            right += 1\n        \n        return result\n    \n    total_result = 0\n    for num_unique in range(1, 27):  # Maximum possible distinct characters in an alphabetic string\n        total_result += check(num_unique)\n    \n    return total_result\n\nif __name__ == \"__main__\":\n    import fileinput\n    input_stream = iter(fileinput.input())\n    \n    word = next(input_stream).strip()\n    k = int(next(input_stream))\n    \n    print(count_complete_substrings(word, k))",
            "history_file": null
        },
        {
            "question_id": "3017",
            "difficulty": "hard",
            "total_time": 12.783108949661255,
            "code_generation_time": 11.90772294998169,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 805,
            "total_output_tokens": 362,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    def dp(n, tight, mod, cnt_even, cnt_odd):\n        if n == 0:\n            return int(mod % K == 0) * (cnt_even == cnt_odd)\n        \n        res = 0\n        ub = d[n - 1] + 1 if tight else 10\n        \n        for i in range(ub):\n            new_tight = tight and i == d[n - 1]\n            new_mod = (mod * 10 + i) % K\n            new_cnt_even = cnt_even + (i % 2 == 0)\n            new_cnt_odd = cnt_odd + (i % 2 != 0)\n            \n            res += dp(n - 1, new_tight, new_mod, new_cnt_even, new_cnt_odd)\n        \n        return res\n    \n    def count_beautiful_numbers(num):\n        nonlocal d\n        num_str = str(num)\n        d = list(map(int, reversed(num_str)))\n        length = len(d)\n        return dp(length, True, 0, 0, 0)\n    \n    L, R, K = map(int, input().split())\n    result = count_beautiful_numbers(R) - count_beautiful_numbers(L - 1)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc301_a",
            "difficulty": "easy",
            "total_time": 17.803083658218384,
            "code_generation_time": 17.597687244415283,
            "passed_tests": 11,
            "total_tests": 12,
            "success_rate": 0.92,
            "total_input_tokens": 1806,
            "total_output_tokens": 777,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline().strip())  # Read the number of games\n    S = sys.stdin.readline().strip()       # Read the game results\n    \n    takahashi_wins = sum(1 for char in S if char == 'T')  # Count Takahashi's wins\n    aoki_wins = sum(1 for char in S if char == 'A')      # Count Aoki's wins\n    \n    if takahashi_wins != aoki_wins:  # Different number of wins\n        if takahashi_wins > aoki_wins:\n            winner = 'T'\n        else:\n            winner = 'A'\n    else:  # Same number of wins; determine who reached them first\n        takahashi_first_win_idx = next(i+1 for i, char in enumerate(S) if char == 'T')\n        aoki_first_win_idx = next(i+1 for i, char in enumerate(S) if char == 'A')\n        \n        if takahashi_first_win_idx < aoki_first_win_idx:\n            winner = 'T'\n        elif takahashi_first_win_idx > aoki_first_win_idx:\n            winner = 'A'\n    \n    print(winner)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3210",
            "difficulty": "medium",
            "total_time": 13.157345056533813,
            "code_generation_time": 12.385765552520752,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 895,
            "total_output_tokens": 402,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    input_string = sys.stdin.readline().strip()\n    k = int(sys.stdin.readline())\n    \n    n = len(input_string)\n    count_vowels = [0] * (n + 1)\n    result = 0\n    \n    # Precompute number of vowels up to each index\n    for i in range(1, n + 1):\n        if input_string[i - 1] in 'aeiou':\n            count_vowels[i] = count_vowels[i - 1] + 1\n        else:\n            count_vowels[i] = count_vowels[i - 1]\n        \n        # Calculate number of consonants using prefix sum\n        num_consonants = i - count_vowels[i]\n        \n        # Check conditions for a beautiful substring\n        if num_consonants > 0 and num_consonants == count_vowels[i]:\n            product = num_consonants ** 2\n            if product % k == 0:\n                result += 1\n                \n        # Look back for previous states with equal difference between vowels and consonants\n        diff = count_vowels[i] - num_consonants\n        target_diff_1 = diff - num_consonants\n        target_diff_2 = diff + num_consonants\n        \n        if target_diff_1 >= 0:\n            result -= count[target_diff_1][product // k]\n            \n        if target_diff_2 < n:\n            result += count[target_diff_2][(num_consonants * (num_consonants + 1)) // 2]\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3200",
            "difficulty": "medium",
            "total_time": 39.355188846588135,
            "code_generation_time": 13.948545217514038,
            "passed_tests": 0,
            "total_tests": 87,
            "success_rate": 0.0,
            "total_input_tokens": 718,
            "total_output_tokens": 482,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = int(1e9 + 7)\n\ndp = [[[[[[-1] * 2 for _ in range(2)] for _ in range(2)] for _ in range(2)] for _ in range(2)] for _ in range(5)]\n\ndef count_good_strings(n):\n    def dfs(i, l_count, e_count, t_count, has_leet):\n        if i == n:\n            return 1 if has_leet else 0\n        \n        if dp[i][l_count][e_count][t_count][has_leet] != -1:\n            return dp[i][l_count][e_count][t_count][has_leet]\n        \n        res = 0\n        for char in 'leetcode':\n            nl_count = l_count | (char == 'l')\n            ne_count = e_count | (char == 'e' and nl_count)\n            nt_count = t_count | (char == 't' and ne_count)\n            \n            res += dfs(i + 1, nl_count, ne_count, nt_count, has_leet or (nt_count > 0))\n            res %= MOD\n        \n        dp[i][l_count][e_count][t_count][has_leet] = res\n        return res\n    \n    result = dfs(0, 0, 0, 0, False)\n    \n    # Calculate total possible strings of length n\n    total_strings = pow(26, n, MOD)\n    \n    # Subtract bad strings that do not contain \"leet\"\n    bad_strings = sum(count_good_strings(j) for j in range(n)) % MOD\n    \n    good_strings = (total_strings - bad_strings + MOD) % MOD\n    \n    return good_strings\n\nif __name__ == \"__main__\":\n    import fileinput\n    input = fileinput.input()\n    n = int(next(input).strip())\n    print(count_good_strings(n))",
            "history_file": null
        },
        {
            "question_id": "abc329_c",
            "difficulty": "medium",
            "total_time": 10.45763349533081,
            "code_generation_time": 10.143537282943726,
            "passed_tests": 0,
            "total_tests": 17,
            "success_rate": 0.0,
            "total_input_tokens": 682,
            "total_output_tokens": 236,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef count_repetitive_substrings(s):\n    n = len(s)\n    result = 0\n    \n    i = 0\n    while i < n:\n        j = i + 1\n        while j < n and s[j] == s[i]:\n            j += 1\n        \n        length = j - i\n        result += length * (length + 1) // 2\n        i = j\n    \n    return result\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    S = data[1]\n    \n    print(count_repetitive_substrings(S))",
            "history_file": null
        },
        {
            "question_id": "3025",
            "difficulty": "hard",
            "total_time": 12.14504861831665,
            "code_generation_time": 11.190608978271484,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 915,
            "total_output_tokens": 302,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    def get_min_operations(nums, target):\n        # Convert list to min heap based on negative values for max heap behavior\n        nums_heap = [-num for num in nums if num > 1]\n        heapq.heapify(nums_heap)\n        \n        total_sum = sum(nums) & ~(target ^ (-target))\n        ops_count = 0\n        \n        while total_sum != target and len(nums_heap) >= 2:\n            largest = abs(heapq.heappop(nums_heap)) // 2\n            next_largest = abs(heapq.heappop(nums_heap)) // 2\n            \n            heapq.heappush(nums_heap, -largest * 2)\n            heapq.heappush(nums_heap, -(next_largest + largest))\n            \n            total_sum += largest + next_largest\n            ops_count += 1\n        \n        return ops_count if total_sum == target else -1\n\n    input_line = sys.stdin.readline().strip()\n    nums = list(map(int, input_line.split()))\n    \n    target = int(sys.stdin.readline().strip())\n    \n    result = get_min_operations(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc323_d",
            "difficulty": "hard",
            "total_time": 12.119728088378906,
            "code_generation_time": 10.858367681503296,
            "passed_tests": 0,
            "total_tests": 30,
            "success_rate": 0.0,
            "total_input_tokens": 933,
            "total_output_tokens": 263,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    # Read input\n    n = int(input())\n    slimes = []\n    \n    for _ in range(n):\n        s, c = map(int, input().split())\n        heapq.heappush(slimes, (-s * c))\n    \n    while len(slimes) > 1:\n        a = -heapq.heappop(slimes)\n        b = -heapq.heappop(slimes)\n        \n        if a != b:\n            new_slime_size = max(a // 2, b // 2)\n            remaining_a = a % 2 + (a == b)\n            remaining_b = b % 2\n            \n            heapq.heappush(slimes, -(new_slime_size * (remaining_a + remaining_b)))\n    \n    result = -slimes[0]\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc334_e",
            "difficulty": "hard",
            "total_time": 14.54002833366394,
            "code_generation_time": 14.109088659286499,
            "passed_tests": 0,
            "total_tests": 31,
            "success_rate": 0.0,
            "total_input_tokens": 1149,
            "total_output_tokens": 516,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    MOD = 998244353\n    \n    def count_components(grid):\n        visited = [[False] * W for _ in range(H)]\n        \n        def dfs(x, y):\n            if x < 0 or x >= H or y < 0 or y >= W or grid[x][y] == '.' or visited[x][y]:\n                return\n            visited[x][y] = True\n            directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                dfs(nx, ny)\n            \n        component_count = 0\n        for i in range(H):\n            for j in range(W):\n                if not visited[i][j] and grid[i][j] == '#':\n                    dfs(i, j)\n                    component_count += 1\n        \n        return component_count\n    \n    input.readline()\n    grid = [list(input().strip()) for _ in range(H := int(sys.stdin.readline()))]\n    \n    total_sum = 0\n    zero_component_count = sum(1 for row in grid for char in row if char == '.')\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '.':\n                original_grid = [row[:] for row in grid]\n                original_grid[i][j] = '#'\n                \n                new_component_count = count_components(original_grid)\n                total_sum += new_component_count\n                \n                # Revert changes\n                original_grid[i][j] =('.')\n    \n    expected_value_numerator = total_sum % MOD\n    expected_value_denominator = zero_component_count % MOD\n    \n    modular_inverse = pow(expected_value_denominator, MOD-2, MOD)  # Fermat's Little Theorem\n    result = (expected_value_numerator * modular_inverse) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc325_d",
            "difficulty": "hard",
            "total_time": 12.578047513961792,
            "code_generation_time": 12.082209825515747,
            "passed_tests": 0,
            "total_tests": 44,
            "success_rate": 0.0,
            "total_input_tokens": 1021,
            "total_output_tokens": 371,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(input())\n    \n    events = []\n    for _ in range(N):\n        T_i, D_i = map(int, input().split())\n        # Event at time T_i when a product starts entering the printing area\n        events.append((T_i - 1, 'start'))\n        # Event at time T_i + D_i / 2 when a product can be printed if it's still within the area\n        events.append(((T_i + D_i) // 2, 'print', i))\n        # Event at time T_i + D_i when a product stops leaving the printing area\n        events.append((T_i + D_i, 'end'))\n\n    events.sort()\n    \n    max_prints = 0\n    current_charge_time = float('-inf')\n    active_products = set()\n\n    for t, event_type, *args in events:\n        while active_products and min(active_products) < t:\n            active_products.remove(min(active_products))\n\n        if event_type == 'start':\n            active_products.add(t)\n        \n        elif event_type == 'print' and len(active_products) > 0 and t >= current_charge_time:\n            current_charge_time = t + 1\n            max_prints += 1\n        \n        else:\n            continue\n    \n    print(max_prints)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3151",
            "difficulty": "medium",
            "total_time": 11.569780588150024,
            "code_generation_time": 10.896158933639526,
            "passed_tests": 0,
            "total_tests": 53,
            "success_rate": 0.0,
            "total_input_tokens": 1030,
            "total_output_tokens": 279,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    # Read input\n    processor_time = list(map(int, input().split()))\n    tasks = list(map(int, input().split()))\n    \n    # Sort processors in ascending order based on their availability times\n    processor_time.sort()\n    \n    # Sort tasks in descending order so we can pair largest with smallest efficiently\n    tasks.sort(reverse=True)\n    \n    min_completion_time = float('-inf')\n    \n    # Assign each task to a core starting from the most efficient one\n    for i in range(len(processor_time)):\n        completion_times_for_processor_i = [processor_time[i] + tasks[j*len(processor_time)+i] for j in range(4)]\n        \n        # Find the maximum completion time among cores assigned to this processor\n        current_max_completion_time = max(completion_times_for_processor_i)\n        \n        if current_max_completion_time > min_completion_time:\n            min_completion_time = current_max_completion_time\n            \n    print(min_completion_time)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2844",
            "difficulty": "easy",
            "total_time": 10.263975143432617,
            "code_generation_time": 9.325165271759033,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 784,
            "total_output_tokens": 164,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    # Read input\n    line = sys.stdin.readline().strip()\n    nums = list(map(int, line.split()))\n    \n    n = len(nums)\n    result = 0\n    \n    # Calculate the sum of squares of special elements\n    for i in range(1, n+1):\n        if n % i == 0:\n            result += nums[i-1]**2\n            \n    # Print the result\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc341_d",
            "difficulty": "medium",
            "total_time": 12.085455894470215,
            "code_generation_time": 11.706860065460205,
            "passed_tests": 2,
            "total_tests": 32,
            "success_rate": 0.06,
            "total_input_tokens": 759,
            "total_output_tokens": 349,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef solve():\n    import math\n    \n    def count_divisibles(n, m, k):\n        lcm_nm = n * m // gcd(n, m)\n        total_count_n = n - n // lcm_nm\n        total_count_m = m - m // lcm_nm\n        \n        if k <= total_count_n + total_count_m:\n            if k > total_count_n:\n                k -= total_count_n\n                result = ((k - 1) * m + n) // gcd(m, n)\n            else:\n                result = ((k - 1) * n + m) // gcd(n, m)\n        else:\n            remaining_k = k - total_count_n - total_count_m\n            multiple_of_lcm = (remaining_k - 1) * lcm_nm + min(lcm_nm, max(n, m))\n            result = multiple_of_lcm\n            \n        return result\n    \n    N, M, K = map(int, input().split())\n    \n    answer = count_divisibles(N, M, K)\n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2816",
            "difficulty": "easy",
            "total_time": 10.55629563331604,
            "code_generation_time": 9.584550619125366,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 728,
            "total_output_tokens": 185,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    s = input().strip()\n    n = len(s)\n    result = list(s)\n    \n    left, right = 0, n - 1\n    \n    while left < right:\n        if s[left] != s[right]:\n            # Choose the lexicographically smaller character\n            if ord(s[left]) > ord(s[right]):\n                result[left] = s[right]\n            else:\n                result[right] = s[left]\n        \n        left += 1\n        right -= 1\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc343_d",
            "difficulty": "medium",
            "total_time": 10.641361236572266,
            "code_generation_time": 8.849074125289917,
            "passed_tests": 0,
            "total_tests": 19,
            "success_rate": 0.0,
            "total_input_tokens": 1297,
            "total_output_tokens": 385,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    T = int(data[1])\n    \n    events = []\n    index = 2\n    \n    for _ in range(T):\n        A_i = int(data[index])\n        B_i = int(data[index + 1])\n        events.append((A_i - 1, B_i))\n        index += 2\n    \n    # Sort events based on time and player ID\n    events.sort(key=lambda x: (-x[1], x[0]))\n    \n    current_scores = [0] * N\n    unique_scores = set(current_scores)\n    \n    results = []\n    \n    while events:\n        _, score_change = events.pop(0)\n        \n        if len(unique_scores) > 1:\n            results.append(len(unique_scores))\n            \n        max_score_index = None\n        \n        for i in range(N):\n            new_score = current_scores[i] + score_change\n            \n            if new_score != current_scores[i]:\n                if not max_score_index or new_score < current_scores[max_score_index]:\n                    max_score_index = i\n                \n                if new_score == current_scores[current_scores.index(max_score)]:\n                    continue\n                \n                if new_score in unique_scores:\n                    unique_scores.remove(new_score)\n                \n                current_scores[i] = new_score\n                unique_scores.add(new_score)\n    \n    results.append(len(unique_scores))\n    \n    for result in reversed(results[:-1]):\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc305_e",
            "difficulty": "hard",
            "total_time": 8.817885160446167,
            "code_generation_time": 6.471943378448486,
            "passed_tests": 0,
            "total_tests": 31,
            "success_rate": 0.0,
            "total_input_tokens": 1260,
            "total_output_tokens": 410,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    N = int(data[index])\n    M = int(data[index + 1])\n    K = int(data[index + 2])\n    index += 3\n    \n    # Build adjacency list representation of the graph\n    adj_list = defaultdict(list)\n    for _ in range(M):\n        u = int(data[index]) - 1\n        v = int(data[index + 1]) - 1\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n        index += 2\n    \n    guards = []\n    for i in range(K):\n        guard_vertex = int(data[index]) - 1\n        stamina = int(data[index + 1])\n        guards.append((guard_vertex, stamina))\n        index += 2\n    \n    visited = [False] * N\n    guarded_vertices = set()\n    \n    def bfs(start, distance_limit):\n        queue = deque([start])\n        while queue:\n            current = queue.popleft()\n            if not visited[current]:\n                visited[current] = True\n                guarded_vertices.add(current)\n                for neighbor in adj_list[current]:\n                    if abs(neighbor - start) <= distance_limit and not visited[neighbor]:\n                        queue.append(neighbor)\n    \n    for vertex, stamina in guards:\n        bfs(vertex, stamina)\n    \n    sorted_guarded_vertices = sorted(guarded_vertices)\n    G = len(sorted_guarded_vertices)\n    \n    print(G)\n    print(\" \".join(map(str, sorted_guarded_vertices)))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc311_c",
            "difficulty": "medium",
            "total_time": 11.745335340499878,
            "code_generation_time": 5.140193939208984,
            "passed_tests": 0,
            "total_tests": 51,
            "success_rate": 0.0,
            "total_input_tokens": 1036,
            "total_output_tokens": 328,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    A = list(map(int, data[1:]))\n\n    visited = [False] * (n + 1)\n    start_node = -1\n    \n    # Find the starting node of the cycle\n    for i in range(1, n + 1):\n        if not visited[i]:\n            current = i\n            while True:\n                next_vertex = A[current]\n                if visited[next_vertex]:\n                    break\n                visited[next_vertex] = True\n                current = next_vertex\n            \n            if current == i:\n                start_node = i\n                break\n                \n    # Trace back the cycle path\n    cycle_path = []\n    current = start_node\n    while True:\n        cycle_path.append(current)\n        current = A[current]\n        if current == start_node:\n            break\n    \n    M = len(cycle_path)\n    print(M)\n    print(' '.join(str(x) for x in cycle_path))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc326_e",
            "difficulty": "hard",
            "total_time": 4.3285253047943115,
            "code_generation_time": 3.8252696990966797,
            "passed_tests": 1,
            "total_tests": 27,
            "success_rate": 0.04,
            "total_input_tokens": 1135,
            "total_output_tokens": 229,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    MOD = 998244353\n    \n    N = int(input())\n    A = list(map(int, input().split()))\n    \n    dp = [0] * (N + 1)\n    total_prob = 0\n    \n    for i in range(1, N + 1):\n        if A[i - 1] == 0:\n            continue\n        \n        prob = (total_prob + 1) // i % MOD\n        dp[A[i - 1]] += prob\n        total_prob += prob\n    \n    result = sum(dp[j] * j for j in range(N)) % MOD\n    z = pow(total_prob, MOD - 2, MOD) * result % MOD\n    \n    print(z)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3298",
            "difficulty": "hard",
            "total_time": 4.015228748321533,
            "code_generation_time": 3.2595901489257812,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 676,
            "total_output_tokens": 204,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n\n    n = int(data[0])\n    nums = list(map(int, data[1:]))\n\n    nums.sort()\n    \n    max_consecutive = 1\n    current_count = 1\n    \n    for i in range(1, len(nums)):\n        if nums[i] - nums[i-1] > 1:\n            current_count = 1\n        else:\n            current_count += 1\n        \n        max_consecutive = max(max_consecutive, current_count)\n        \n    print(max_consecutive)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2824",
            "difficulty": "easy",
            "total_time": 3.817516565322876,
            "code_generation_time": 3.0915565490722656,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 655,
            "total_output_tokens": 187,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve(n):\n    concatenated_number = str(n) + str(2*n) + str(3*n)\n    \n    if '0' in concatenated_number:\n        return False\n    \n    digit_count = [0] * 10\n    for char in concatenated_number:\n        digit_count[int(char)] += 1\n        \n    return all(count == 1 for count in digit_count[1:])\n    \n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read().strip()\n    n = int(input)\n    result = \"true\" if solve(n) else \"false\"\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc313_c",
            "difficulty": "medium",
            "total_time": 5.0938544273376465,
            "code_generation_time": 4.440174341201782,
            "passed_tests": 0,
            "total_tests": 27,
            "success_rate": 0.0,
            "total_input_tokens": 869,
            "total_output_tokens": 277,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    min_heap = []\n    max_heap = [-x for x in a]\n    heapq.heapify(min_heap)\n    heapq.heapify(max_heap)\n    \n    while len(min_heap) > 0 and -max_heap[0] - min_heap[0] > 1:\n        # Pop the smallest element\n        small = heapq.heappop(min_heap)\n        \n        # Convert it to negative to use as a max heap\n        large = -heapq.heappushpop(max_heap, -small + 1)\n        \n        # Push back with decremented value\n        heapq.heappush(min_heap, large - 1)\n    \n    result = (-max_heap[0]) - min_heap[0]\n    if result < 0:\n        result = 0\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc307_e",
            "difficulty": "hard",
            "total_time": 5.401044607162476,
            "code_generation_time": 4.929161787033081,
            "passed_tests": 2,
            "total_tests": 21,
            "success_rate": 0.1,
            "total_input_tokens": 739,
            "total_output_tokens": 322,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = 998244353\n\ndef count_ways(N, M):\n    if M <= 1 or N > M + 1:\n        return 0\n    \n    dp = [[0] * M for _ in range(2)]\n    \n    # Initialize base case\n    for i in range(M):\n        dp[0][i] = 1\n    \n    # Fill DP table\n    for n in range(1, N % 2 + 1):\n        new_dp = [0] * M\n        total_sum = sum(dp[n & 1])\n        \n        for j in range(M):\n            new_dp[j] = ((total_sum - dp[(n & 1)][j]) % MOD) * (M - 1)\n            \n        dp[n & 1 ^ 1] = new_dp\n        \n        # Update total sum with current row's values\n        for k in range(M):\n            total_sum += new_dp[k]\n            total_sum %= MOD\n    \n    result = sum(dp[N & 1]) % MOD\n    return result\n\nif __name__ == \"__main__\":\n    input_line = sys.stdin.readline().strip()\n    N, M = map(int, input_line.split())\n    answer = count_ways(N, M)\n    print(answer)",
            "history_file": null
        }
    ]
}
{
    "model": "qwen3:14b",
    "architecture": "multi-agent",
    "total_test_time": 73938.47674560547,
    "total_input_tokens": 686178,
    "total_output_tokens": 2581445,
    "score": 51.181481481481484,
    "tokens_per_second": 34.91341874517895,
    "difficulty_stats": {
        "easy": {
            "total": 30,
            "passed": 24,
            "percentage": 80.0
        },
        "medium": {
            "total": 30,
            "passed": 13,
            "percentage": 43.333333333333336
        },
        "hard": {
            "total": 30,
            "passed": 8,
            "percentage": 26.666666666666668
        }
    },
    "completed_at": "2025-12-06T03:36:06.207022",
    "results": [
        {
            "question_id": "abc341_b",
            "difficulty": "easy",
            "total_time": 192.55086541175842,
            "code_generation_time": 191.66341400146484,
            "passed_tests": 22,
            "total_tests": 22,
            "success_rate": 1.0,
            "total_input_tokens": 3140,
            "total_output_tokens": 6755,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = list(map(int, sys.stdin.read().split()))\n    ptr = 0\n    N = data[ptr]\n    ptr += 1\n    A = data[ptr:ptr + N]\n    ptr += N\n    S = []\n    T = []\n    for _ in range(N - 1):\n        S.append(data[ptr])\n        T.append(data[ptr + 1])\n        ptr += 2\n    for i in range(N - 1):\n        max_exchanges = A[i] // S[i]\n        A[i] -= max_exchanges * S[i]\n        A[i + 1] += max_exchanges * T[i]\n    print(A[-1])\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc341_b.json"
        },
        {
            "question_id": "1899_B",
            "difficulty": "hard",
            "total_time": 224.88262391090393,
            "code_generation_time": 224.41205430030823,
            "passed_tests": 39,
            "total_tests": 39,
            "success_rate": 1.0,
            "total_input_tokens": 3666,
            "total_output_tokens": 7668,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport math\n\ndef get_divisors(n):\n    divisors = set()\n    for i in range(1, int(math.isqrt(n)) + 1):\n        if n % i == 0:\n            divisors.add(i)\n            divisors.add(n // i)\n    return divisors\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    t = int(input[ptr])\n    ptr += 1\n    for _ in range(t):\n        n = int(input[ptr])\n        ptr += 1\n        a = list(map(int, input[ptr:ptr + n]))\n        ptr += n\n        \n        # Compute prefix sum\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + a[i]\n        \n        # Get divisors of n\n        divisors = get_divisors(n)\n        max_diff = 0\n        \n        for k in divisors:\n            m = n // k\n            current_max = -float('inf')\n            current_min = float('inf')\n            for i in range(m):\n                start = i * k\n                end = start + k\n                s = prefix_sum[end] - prefix_sum[start]\n                if s > current_max:\n                    current_max = s\n                if s < current_min:\n                    current_min = s\n            current_diff = current_max - current_min\n            if current_diff > max_diff:\n                max_diff = current_diff\n        \n        print(max_diff)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/1899_B.json"
        },
        {
            "question_id": "abc332_b",
            "difficulty": "easy",
            "total_time": 124.35764646530151,
            "code_generation_time": 124.09806776046753,
            "passed_tests": 30,
            "total_tests": 30,
            "success_rate": 1.0,
            "total_input_tokens": 2202,
            "total_output_tokens": 4196,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    K = int(next(iterator))\n    G = int(next(iterator))\n    M = int(next(iterator))\n    \n    current_glass = 0\n    current_mug = 0\n    \n    for _ in range(K):\n        if current_glass == G:\n            current_glass = 0\n        elif current_mug == 0:\n            current_mug = M\n        else:\n            transfer = min(current_mug, G - current_glass)\n            current_glass += transfer\n            current_mug -= transfer\n    \n    print(current_glass, current_mug)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc332_b.json"
        },
        {
            "question_id": "abc337_e",
            "difficulty": "hard",
            "total_time": 1196.9351949691772,
            "code_generation_time": 1196.7346353530884,
            "passed_tests": 0,
            "total_tests": 25,
            "success_rate": 0.0,
            "total_input_tokens": 16141,
            "total_output_tokens": 41014,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    n = int(sys.stdin.readline())\n    m = (n - 1).bit_length()\n    friends = [[] for _ in range(m)]\n\n    for j in range(1, n + 1):\n        for i in range(m):\n            if (j - 1) & (1 << i):\n                friends[i].append(j)\n\n    print(m)\n    for lst in friends:\n        parts = [str(len(lst))] + list(map(str, lst))\n        print(' '.join(parts))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc337_e.json"
        },
        {
            "question_id": "3207",
            "difficulty": "easy",
            "total_time": 580.5755798816681,
            "code_generation_time": 579.9819259643555,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 7067,
            "total_output_tokens": 19871,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if len(input_data) != 3:\n        print(-1)\n        return\n    \n    s1, s2, s3 = input_data\n    min_len = min(len(s1), len(s2), len(s3))\n    \n    for L in range(min_len, 0, -1):\n        if s1[:L] == s2[:L] == s3[:L]:\n            operations = (len(s1) - L) + (len(s2) - L) + (len(s3) - L)\n            print(operations)\n            return\n    \n    print(-1)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/3207.json"
        },
        {
            "question_id": "2837",
            "difficulty": "medium",
            "total_time": 1889.4952430725098,
            "code_generation_time": 1888.9097707271576,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 9110,
            "total_output_tokens": 66234,
            "error": null,
            "traceback": null,
            "code": "",
            "history_file": "qwen3_14b/2837.json"
        },
        {
            "question_id": "3331",
            "difficulty": "easy",
            "total_time": 425.8608446121216,
            "code_generation_time": 425.4842138290405,
            "passed_tests": 0,
            "total_tests": 57,
            "success_rate": 0.0,
            "total_input_tokens": 7383,
            "total_output_tokens": 14522,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    # Parse the input\n    k = int(input_data[-1])\n    nums = list(map(int, input_data[:-1]))\n\n    # Sort the array\n    nums_sorted = sorted(nums)\n\n    # Count elements less than k\n    count = 0\n    for num in nums_sorted:\n        if num < k:\n            count += 1\n        else:\n            break\n\n    print(count)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/3331.json"
        },
        {
            "question_id": "abc322_e",
            "difficulty": "hard",
            "total_time": 1749.5002727508545,
            "code_generation_time": 1749.197818994522,
            "passed_tests": 0,
            "total_tests": 44,
            "success_rate": 0.0,
            "total_input_tokens": 11209,
            "total_output_tokens": 61138,
            "error": null,
            "traceback": null,
            "code": "",
            "history_file": "qwen3_14b/abc322_e.json"
        },
        {
            "question_id": "abc315_f",
            "difficulty": "hard",
            "total_time": 1459.046247959137,
            "code_generation_time": 1458.5691049098969,
            "passed_tests": 0,
            "total_tests": 66,
            "success_rate": 0.0,
            "total_input_tokens": 18080,
            "total_output_tokens": 49953,
            "error": null,
            "traceback": null,
            "code": "import math\nimport sys\n\ndef main():\n    input = sys.stdin.read().split()\n    idx = 0\n    N = int(input[idx])\n    idx += 1\n    points = []\n    for _ in range(N):\n        x = float(input[idx])\n        y = float(input[idx + 1])\n        points.append((x, y))\n        idx += 2\n\n    max_skips = 20\n    k = 20  # Maximum steps ahead to consider\n    INF = float('inf')\n    dp = [[INF] * (max_skips + 1) for _ in range(N + 1)]\n    dp[1][0] = 0.0  # Starting at checkpoint 1 with 0 skipped checkpoints\n\n    for i in range(1, N + 1):\n        for c in range(max_skips + 1):\n            if dp[i][c] == INF:\n                continue\n            # Consider moving to checkpoints up to k steps ahead\n            for j in range(i + 1, min(i + k + cigaret, N + 1)):\n                dx = points[j - 1][0] - points[i - 1][0]\n                dy = points[j - 1][1] - points[i - 1][1]\n                dist = math.hypot(dx, dy)\n                new_c = c + (j - i - 1)  # Number of checkpoints skipped between i and j\n                if new_c <= max_skips:\n                    if dp[j][new_c] > dp[i][c] + dist:\n                        dp[j][new_c] = dp[i][c] + dist\n\n    # Find the minimum total cost at the last checkpoint\n    min_total = INF\n    for c in range(max_skips + 1):\n        if dp[N][c] != INF:\n            penalty = 0 if c == 0 else (2 ** (c - 1))\n            total = dp[N][c] + penalty\n            if total < min_total:\n                min_total = total\n\n    print(f\"{min_total:.10f}\")\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc315_f.json"
        },
        {
            "question_id": "abc335_a",
            "difficulty": "easy",
            "total_time": 65.08062219619751,
            "code_generation_time": 64.926349401474,
            "passed_tests": 17,
            "total_tests": 17,
            "success_rate": 1.0,
            "total_input_tokens": 1623,
            "total_output_tokens": 2131,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    s = next(iterator)\n    modified = s[:-1] + '4'\n    print(modified)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc335_a.json"
        },
        {
            "question_id": "abc304_b",
            "difficulty": "easy",
            "total_time": 310.7963058948517,
            "code_generation_time": 310.6067535877228,
            "passed_tests": 18,
            "total_tests": 18,
            "success_rate": 1.0,
            "total_input_tokens": 2701,
            "total_output_tokens": 10804,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    N = int(input_data[0])\n    \n    if N == 0:\n        print(0)\n        return\n\n    # Count the number of digits\n    d = 1\n    while N >= 10 ** d:\n        d += 1\n\n    if d <= 3:\n        print(N)\n    else:\n        truncate_digits = d - 3\n        divisor = 10 ** truncate_digits\n        result = (N // divisor) * divisor\n        print(result)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc304_b.json"
        },
        {
            "question_id": "abc341_a",
            "difficulty": "easy",
            "total_time": 75.87035822868347,
            "code_generation_time": 75.76280689239502,
            "passed_tests": 9,
            "total_tests": 9,
            "success_rate": 1.0,
            "total_input_tokens": 1413,
            "total_output_tokens": 2528,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    N = int(next(iterator))\n    result = '1' + '01' * N\n    print(result)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc341_a.json"
        },
        {
            "question_id": "2877",
            "difficulty": "medium",
            "total_time": 2028.8810908794403,
            "code_generation_time": 2028.2900941371918,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 6046,
            "total_output_tokens": 71265,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport itertools\n\ndef merge_two(s1, s2):\n    max_k = 0\n    for k in range(0, min(len(s1), len(s2)) + 1):\n        if s1.endswith(s2[:k]):\n            max_k = k\n    return s1 + s2[max_k:]\n\ndef generate_all_merged(strs):\n    perms = itertools.permutations(strs)\n    results = []\n    for perm in perms:\n        merged = perm[0]\n        for i in range(1, len(perm)):\n            merged = merge_two(merged, perm[i])\n        results.append(merged)\n    return results\n\ndef select_best(merged_list):\n    best = None\n    for s in merged_list:\n        if best is None:\n            best = s\n        else:\n            if len(s) < len(best):\n                best = s\n            elif len(s) == len(best):\n                if s < best:\n                    best = s\n    return best\n\ndef main():\n    # Read input from standard input\n    strs = [line.strip() for line in sys.stdin]\n    merged_list = generate_all_merged(strs)\n    best = select_best(merged_list)\n    print(best)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/2877.json"
        },
        {
            "question_id": "2878",
            "difficulty": "medium",
            "total_time": 996.334465265274,
            "code_generation_time": 995.6990342140198,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 11415,
            "total_output_tokens": 34375,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef canApplyOperations(nums, k):\n    n = len(nums)\n    diff = [0] * (n + 1)\n    current_ops = 0\n\n    for i in range(n):\n        current_ops += diff[i]\n        val = nums[i] - current_ops\n\n        if val < 0:\n            return False\n\n        if i + k > n:\n            if val != 0:\n                return False\n            else:\n                continue\n        else:\n            ops_to_apply = val\n            current_ops += ops_to_apply\n            if i + k < n:\n                diff[i + k] -= ops_to_apply\n\n    return True\n\nif __name__ == '__main__':\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        print(False)\n        sys.exit()\n    \n    iterator = iter(input_data)\n    try:\n        nums = list(map(int, iterator))\n        k = int(next(iterator))\n    except:\n        print(False)\n        sys.exit()\n    \n    print(canApplyOperations(nums, k))",
            "history_file": "qwen3_14b/2878.json"
        },
        {
            "question_id": "3263",
            "difficulty": "easy",
            "total_time": 681.2642338275909,
            "code_generation_time": 680.6590881347656,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 9466,
            "total_output_tokens": 23387,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    nums = list(map(int, input_data))\n    n = len(nums)\n    if n < 3:\n        return  # According to constraints, n >= 3\n\n    min_sum = float('inf')\n\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            current_sum = nums[0] + nums[i + 1] + nums[j + 1]\n            if current_sum < min_sum:\n                min_sum = current_sum\n\n    print(min_sum)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/3263.json"
        },
        {
            "question_id": "abc339_d",
            "difficulty": "medium",
            "total_time": 1432.596037387848,
            "code_generation_time": 1420.0315897464752,
            "passed_tests": 38,
            "total_tests": 52,
            "success_rate": 0.73,
            "total_input_tokens": 9088,
            "total_output_tokens": 49194,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque\n\ndef main():\n    input_data = sys.stdin.read().split()\n    idx = 0\n    N = int(input_data[idx])\n    idx += 1\n    grid = []\n    for _ in range(N):\n        grid.append(input_data[idx])\n        idx += 1\n\n    # Find the positions of the two players\n    players = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'P':\n                players.append((i, j))\n    x1, y1 = players[0]\n    x2, y2 = players[1]\n\n    # Define the four possible movement directions\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Initialize BFS\n    visited = set()\n    queue = deque()\n    initial_state = (x1, y1, x2, y2)\n    visited.add(initial_state)\n    queue.append((x1, y1, x2, y2, 0))\n\n    while queue:\n        x1, y1, x2, y2, steps = queue.popleft()\n\n        # Check if the players are on the same cell\n        if (x1, y1) == (x2, y2):\n            print(steps)\n            return\n\n        # Try all four directions\n        for dx, dy in directions:\n            # Compute new positions for both players\n            nx1, ny1 = x1 + dx, y1 + dy\n            if 0 <= nx1 < N and 0 <= ny1 < N and grid[nx1][ny1] != '#':\n                pass  # Valid move\n            else:\n                nx1, ny1 = x1, y1  # Stay in place\n\n            nx2, ny2 = x2 + dx, y2 + dy\n            if 0 <= nx2 < N and 0 <= ny2 < N and grid[nx2][ny2] != '#':\n                pass  # Valid move\n            else:\n                nx2, ny2 = x2, y2  # Stay in place\n\n            new_state = (nx1, ny1, nx2, ny2)\n            if new_state not in visited:\n                visited.add(new_state)\n                queue.append((nx1, ny1, nx2, ny2, steps + 1))\n\n    # If no meeting is possible\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc339_d.json"
        },
        {
            "question_id": "3309",
            "difficulty": "easy",
            "total_time": 449.7306501865387,
            "code_generation_time": 449.14550256729126,
            "passed_tests": 86,
            "total_tests": 100,
            "success_rate": 0.86,
            "total_input_tokens": 8684,
            "total_output_tokens": 15246,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    words = input_data\n    count = 0\n    n = len(words)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if words[j].startswith(words[i]) and words[j].endswith(words[i]):\n                count += 1\n    print(count)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/3309.json"
        },
        {
            "question_id": "2873",
            "difficulty": "medium",
            "total_time": 279.7027747631073,
            "code_generation_time": 278.80442905426025,
            "passed_tests": 94,
            "total_tests": 94,
            "success_rate": 1.0,
            "total_input_tokens": 2155,
            "total_output_tokens": 9664,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        print([])\n        return\n\n    n = int(input_data[0])\n    if n < 2:\n        print([])\n        return\n\n    # Generate sieve of Eratosthenes\n    sieve = [True] * (n + 1)\n    sieve[0] = sieve[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i]:\n            sieve[i*i : n+1 : i] = [False] * len(sieve[i*i : n+1 : i])\n\n    result = []\n    max_x = n // 2\n    for x in range(2, max_x + 1):\n        y = n - x\n        if sieve[x] and sieve[y]:\n            result.append([x, y])\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/2873.json"
        },
        {
            "question_id": "abc322_a",
            "difficulty": "easy",
            "total_time": 106.22593331336975,
            "code_generation_time": 106.1378984451294,
            "passed_tests": 8,
            "total_tests": 8,
            "success_rate": 1.0,
            "total_input_tokens": 1648,
            "total_output_tokens": 3597,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    n = int(next(iterator))\n    s = next(iterator)\n    \n    for i in range(len(s) - 2):\n        if s[i] == 'A' and s[i+1] == 'B' and s[i+2] == 'C':\n            print(i + 1)\n            return\n    print(-1)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc322_a.json"
        },
        {
            "question_id": "3203",
            "difficulty": "hard",
            "total_time": 1279.7287323474884,
            "code_generation_time": 1279.0989282131195,
            "passed_tests": 0,
            "total_tests": 79,
            "success_rate": 0.0,
            "total_input_tokens": 12514,
            "total_output_tokens": 40467,
            "error": null,
            "traceback": null,
            "code": "from collections import Counter\n\ndef can_form_palindrome(s):\n    # Count the frequency of each character\n    freq = Counter(s)\n    \n    # Count how many characters have odd frequency\n    odd_count = sum(1 for count in freq.values() if count % 2 != 0)\n    \n    # A string can be rearranged into a palindrome if at most one character has an odd count\n    return odd_count <= 1\n\n# Example usage\ns = input(\"Enter a string: \")\nif can_form_palindrome(s):\n    print(\"YES\")\nelse:\n    print(\"NO\")",
            "history_file": "qwen3_14b/3203.json"
        },
        {
            "question_id": "3297",
            "difficulty": "medium",
            "total_time": 2000.8469622135162,
            "code_generation_time": 2000.2518100738525,
            "passed_tests": 10,
            "total_tests": 100,
            "success_rate": 0.1,
            "total_input_tokens": 14373,
            "total_output_tokens": 70455,
            "error": null,
            "traceback": null,
            "code": "word = input().strip()\nk = int(input())\nn = len(word)\n\nfor t in range(1, n + 1):\n    kt = k * t\n    if kt % n == 0:\n        print(t)\n        break\n    elif kt <= n:\n        if word[kt:] == word[:n - kt]:\n            print(t)\n            break",
            "history_file": "qwen3_14b/3297.json"
        },
        {
            "question_id": "3212",
            "difficulty": "hard",
            "total_time": 979.7001881599426,
            "code_generation_time": 979.075451374054,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 7340,
            "total_output_tokens": 34252,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = 10**9 + 7\n\ndef main():\n    input_data = sys.stdin.read().split()\n    nums = list(map(int, input_data))\n    \n    first_occurrence = {}\n    last_occurrence = {}\n    \n    for i, num in enumerate(nums):\n        if num not in first_occurrence:\n            first_occurrence[num] = i\n        last_occurrence[num] = i\n    \n    intervals = []\n    for num in first_occurrence:\n        start = first_occurrence[num]\n        end = last_occurrence[num]\n        intervals.append((start, end))\n    \n    # Sort intervals by their starting index\n    intervals.sort()\n    \n    # Merge overlapping intervals\n    merged = []\n    for interval in intervals:\n        if not merged:\n            merged.append(interval)\n        else:\n            last_start, last_end = merged[-1]\n            current_start, current_end = interval\n            if current_start <= last_end:\n                # Merge intervals\n                new_start = last_start\n                new_end = max(last_end, current_end)\n                merged[-1] = (new_start, new_end)\n            else:\n                merged.append(interval)\n    \n    m = len(merged)\n    print(pow(2, m - 1, MOD))\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/3212.json"
        },
        {
            "question_id": "abc315_e",
            "difficulty": "hard",
            "total_time": 1461.0145123004913,
            "code_generation_time": 1458.8806505203247,
            "passed_tests": 7,
            "total_tests": 34,
            "success_rate": 0.21,
            "total_input_tokens": 11116,
            "total_output_tokens": 51081,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque, defaultdict\n\ndef main():\n    N = int(sys.stdin.readline())\n    prerequisites = [[] for _ in range(N + 1)]\n\n    for book in range(1, N + 1):\n        parts = list(map(int, sys.stdin.readline().split()))\n        C_i = parts[0]\n        prereqs = parts[1:]\n        prerequisites[book] = prereqs\n\n    required_books = set()\n    queue = deque()\n\n    # Initialize with prerequisites of book 1\n    for p in prerequisites[1]:\n        if p not in required_books:\n            required_books.add(p)\n            queue.append(p)\n\n    # Process the queue to collect all required_books\n    while queue:\n        current = queue.popleft()\n        for p in prerequisites[current]:\n            if p not in required_books:\n                required_books.add(p)\n                queue.append(p)\n\n    # Build the graph and in-degree dictionary\n    adj = defaultdict(list)\n    in_degree = defaultdict(int)\n\n    for book in required_books:\n        in_degree[book] = 0\n\n    for book in required_books:\n        for p in prerequisites[book]:\n            adj[p].append(book)\n            in_degree[book] += 1\n\n    # Perform Kahn's algorithm\n    result = []\n    queue = deque()\n\n    for book in required_books:\n        if in_degree[book] == 0:\n            queue.append(book)\n\n    while queue:\n        u = queue.popleft()\n        result.append(u)\n        for v in adj[u]:\n            in_degree[v] -= 1\n            if in_degree[v] == 0:\n                queue.append(v)\n\n    # Output the result\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc315_e.json"
        },
        {
            "question_id": "abc323_c",
            "difficulty": "medium",
            "total_time": 1969.2542216777802,
            "code_generation_time": 1969.129667520523,
            "passed_tests": 0,
            "total_tests": 11,
            "success_rate": 0.0,
            "total_input_tokens": 15203,
            "total_output_tokens": 69333,
            "error": null,
            "traceback": null,
            "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n\n    idx = 0\n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n\n    A = list(map(int, data[idx:idx + M]))\n    idx += M\n\n    S_list = data[idx:idx + N]\n\n    # Step 1: Calculate current scores\n    scores = []\n    for i in range(N):\n        score = 0\n        for j in range(M):\n            if S_list[i][j] == 'o':\n                score += A[j]\n        scores.append(score + (i + 1))  # Add bonus\n\n    # Step 2: For each player, determine the number of problems needed\n    result = []\n    for i in range(N):\n        max_other = 0\n        for j in range(N):\n            if j != i:\n                max_other = max(max_other, scores[j])\n        target = max_other + 1\n        current = scores[i]\n        if current >= target:\n            result.append(0)\n            continue\n\n        # Find unsolved problems\n        unsolved = []\n        for j in range(M):\n            if S_list[i][j] == 'x':\n                unsolved.append(A[j])\n        unsolved.sort(reverse=True)\n\n        # Greedily select problems\n        needed = 0\n        total = 0\n        while total < (target - current):\n            if not unsolved:\n                break\n            total += unsolved[needed]\n            needed += 1\n        result.append(needed)\n\n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc323_c.json"
        },
        {
            "question_id": "3172",
            "difficulty": "easy",
            "total_time": 100.03639507293701,
            "code_generation_time": 99.45111513137817,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 2032,
            "total_output_tokens": 3352,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    n = int(next(iterator))\n    m = int(next(iterator))\n    total_sum = n * (n + 1) // 2\n    k = n // m\n    num2 = m * k * (k + 1) // 2\n    result = total_sum - 2 * num2\n    print(result)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/3172.json"
        },
        {
            "question_id": "abc305_b",
            "difficulty": "easy",
            "total_time": 76.60240840911865,
            "code_generation_time": 76.4763720035553,
            "passed_tests": 11,
            "total_tests": 11,
            "success_rate": 1.0,
            "total_input_tokens": 1598,
            "total_output_tokens": 2553,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    p = next(iterator)\n    q = next(iterator)\n    positions = {'A':0, 'B':3, 'C':4, 'D':8, 'E':9, 'F':14, 'G':23}\n    print(abs(positions[p] - positions[q]))\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc305_b.json"
        },
        {
            "question_id": "abc340_a",
            "difficulty": "easy",
            "total_time": 72.63876700401306,
            "code_generation_time": 72.50573015213013,
            "passed_tests": 10,
            "total_tests": 10,
            "success_rate": 1.0,
            "total_input_tokens": 1507,
            "total_output_tokens": 2410,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    A = int(input_data[0])\n    B = int(input_data[1])\n    D = int(input_data[2])\n    \n    n = ((B - A) // D) + 1\n    sequence = [A + i * D for i in range(n)]\n    print(' '.join(map(str, sequence)))\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc340_a.json"
        },
        {
            "question_id": "abc314_c",
            "difficulty": "medium",
            "total_time": 222.68661832809448,
            "code_generation_time": 222.10979199409485,
            "passed_tests": 27,
            "total_tests": 27,
            "success_rate": 1.0,
            "total_input_tokens": 2832,
            "total_output_tokens": 7685,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    ptr = 0\n    N = int(data[ptr])\n    ptr += 1\n    M = int(data[ptr])\n    ptr += 1\n    S = data[ptr]\n    ptr += 1\n    C = list(map(int, data[ptr:ptr + N]))\n    \n    # Build color to index mapping\n    color_positions = {}\n    for i in range(N):\n        color = C[i]\n        if color not in color_positions:\n            color_positions[color] = []\n        color_positions[color].append(i)\n    \n    # Convert string to list for easy manipulation\n    chars = list(S)\n    \n    # Process each color from 1 to M\n    for color in range(1, M + 1):\n        pos_list = color_positions.get(color, [])\n        if not pos_list:\n            continue\n        # Collect characters at these positions\n        chars_in_pos = [chars[pos] for pos in pos_list]\n        # Rotate right by one\n        new_chars = [chars_in_pos[-1]] + chars_in_pos[:-1]\n        # Update the characters in the list\n        for idx, pos in enumerate(pos_list):\n            chars[pos] = new_chars[idx]\n    \n    # Output the final string\n    print(''.join(chars))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc314_c.json"
        },
        {
            "question_id": "abc336_b",
            "difficulty": "easy",
            "total_time": 52.981849908828735,
            "code_generation_time": 52.82081389427185,
            "passed_tests": 17,
            "total_tests": 17,
            "success_rate": 1.0,
            "total_input_tokens": 1525,
            "total_output_tokens": 1690,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    N = int(next(iterator))\n    count = 0\n    while N % 2 == 0:\n        N //= 2\n        count += 1\n    print(count)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc336_b.json"
        },
        {
            "question_id": "2856",
            "difficulty": "medium",
            "total_time": 540.5973103046417,
            "code_generation_time": 539.8043591976166,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 7677,
            "total_output_tokens": 18570,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    nums = list(map(int, input_data))\n    total_distinct = len(set(nums))\n    n = len(nums)\n    result = 0\n\n    for i in range(n):\n        freq = defaultdict(int)\n        current_distinct = 0\n        for j in range(i, n):\n            num = nums[j]\n            if freq[num] == 0:\n                current_distinct += 1\n            freq[num] += 1\n            if current_distinct == total_distinct:\n                result += (n - j)\n                break\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/2856.json"
        },
        {
            "question_id": "abc310_f",
            "difficulty": "hard",
            "total_time": 3051.986490249634,
            "code_generation_time": 3041.866224527359,
            "passed_tests": 16,
            "total_tests": 38,
            "success_rate": 0.42,
            "total_input_tokens": 15539,
            "total_output_tokens": 107908,
            "error": null,
            "traceback": null,
            "code": "MOD = 998244353\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    max_mask = 1 << 11  # 2048 possible masks (0 to 10)\n    dp = [[0] * max_mask for _ in range(N + 1)]\n    dp[0][1 << 0] = 1  # Start with subset {0}\n    \n    for i in range(N):\n        current_a = A[i]\n        for mask in range(max_mask):\n            if dp[i][mask] == 0:\n                continue\n            # Find subset sums in the current mask\n            subset_sums = set()\n            for k in range(11):\n                if mask & (1 << k):\n                    subset_sums.add(k)\n            # Compute invalid values v\n            invalid_vs = set()\n            for k in subset_sums:\n                v = 10 - k\n                if 1 <= v <= current_a:\n                    invalid_vs.add(v)\n            # Iterate over all valid v\n            for v in range(1, current_a + 1):\n                if v in invalid_vs:\n                    continue\n                shifted = mask << v\n                new_mask = mask | shifted\n                new_mask &= (1 << 11) - 1  # Keep only 11 bits\n                dp[i + 1][new_mask] = (dp[i + 1][new_mask] + dp[i][mask]) % MOD\n    \n    # Compute total number of outcomes\n    total = 1\n    for a in A:\n        total = (total * a) % MOD\n    \n    # Compute number of invalid outcomes (no subset sums to 10)\n    invalid = 0\n    for mask in range(max_mask):\n        if not (mask & (1 << 10)):  # 10th bit is not set\n            invalid = (invalid + dp[N][mask]) % MOD\n    \n    valid = (total - invalid) % MOD\n    if total == 0:\n        print(0)\n    else:\n        inv_total = pow(total, MOD - 2, MOD)\n        result = (valid * inv_total) % MOD\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc310_f.json"
        },
        {
            "question_id": "abc333_e",
            "difficulty": "hard",
            "total_time": 1248.701640844345,
            "code_generation_time": 1248.2480409145355,
            "passed_tests": 0,
            "total_tests": 44,
            "success_rate": 0.0,
            "total_input_tokens": 21412,
            "total_output_tokens": 43666,
            "error": null,
            "traceback": null,
            "code": "from collections import defaultdict, deque\n\ndef max_inventory(events):\n    # Step 1: Count future removals\n    future_removals = defaultdict(int)\n    for action, typ in events:\n        if action == 'remove':\n            future_removals[typ] += 1\n\n    # Step 2: Simulate the process\n    inventory = defaultdict(deque)\n    current_inventory = 0\n    max_inventory = 0\n\n    for action, typ in events:\n        if action == 'add':\n            if future_removals[typ] > 0:\n                inventory[typ].append(typ)\n                current_inventory += 1\n                max_inventory = max(max_inventory, current_inventory)\n        else:  # 'remove'\n            if not inventory[typ]:\n                return -1  # Not enough inventory\n            inventory[typ].popleft()\n            current_inventory -= 1\n            future_removals[typ] -= 1\n\n    return max_inventory",
            "history_file": "qwen3_14b/abc333_e.json"
        },
        {
            "question_id": "2867",
            "difficulty": "medium",
            "total_time": 519.8280837535858,
            "code_generation_time": 519.2188985347748,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 6374,
            "total_output_tokens": 18070,
            "error": null,
            "traceback": null,
            "code": "def numberOfWays(nums):\n    ones = [i for i, num in enumerate(nums) if num == 1]\n    \n    if not ones:\n        return 0\n    if len(ones) == 1:\n        return 1\n    \n    result = 1\n    for i in range(1, len(ones)):\n        result *= (ones[i] - ones[i - 1])\n    \n    return result",
            "history_file": "qwen3_14b/2867.json"
        },
        {
            "question_id": "abc324_e",
            "difficulty": "hard",
            "total_time": 1243.9609234333038,
            "code_generation_time": 1242.434786081314,
            "passed_tests": 9,
            "total_tests": 40,
            "success_rate": 0.23,
            "total_input_tokens": 11857,
            "total_output_tokens": 43840,
            "error": null,
            "traceback": null,
            "code": "import bisect\n\ndef compute_prefix(s, t):\n    i = 0\n    for c in s:\n        if i < len(t) and c == t[i]:\n            i += 1\n    return i\n\ndef compute_suffix(s, t):\n    j = len(t) - 1\n    for c in reversed(s):\n        if j >= 0 and c == t[j]:\n            j -= 1\n    return len(t) - 1 - j\n\ndef main():\n    import sys\n    input = sys.stdin.read().splitlines()\n    T = input[0]\n    len_T = len(T)\n    strings = input[1:]\n    \n    pre_list = []\n    suf_list = []\n    \n    for s in strings:\n        pre = compute_prefix(s, T)\n        suf = compute_suffix(s, T)\n        pre_list.append(pre)\n        suf_list.append(suf)\n    \n    pre_sorted = sorted(pre_list)\n    total = 0\n    \n    for suf_val in suf_list:\n        target = max(0, len_T - suf_val)\n        idx = bisect.bisect_left(pre_sorted, target)\n        total += len(pre_sorted) - idx\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc324_e.json"
        },
        {
            "question_id": "abc318_d",
            "difficulty": "medium",
            "total_time": 627.2828886508942,
            "code_generation_time": 626.5934016704559,
            "passed_tests": 17,
            "total_tests": 17,
            "success_rate": 1.0,
            "total_input_tokens": 2518,
            "total_output_tokens": 22329,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    N = int(sys.stdin.readline())\n    if N == 0:\n        print(0)\n        return\n    D = [[0]*N for _ in range(N)]\n    for i in range(N-1):\n        line = list(map(int, sys.stdin.readline().split()))\n        idx = 0\n        for j in range(i+1, N):\n            D[i][j] = line[idx]\n            idx += 1\n    max_mask = 1 << N\n    dp = [-float('inf')] * max_mask\n    dp[0] = 0\n    for mask in range(max_mask):\n        if dp[mask] == -float('inf'):\n            continue\n        available = []\n        for k in range(N):\n            if not (mask & (1 << k)):\n                available.append(k)\n        for i in range(len(available)):\n            for j in range(i+1, len(available)):\n                u = available[i]\n                v = available[j]\n                new_mask = mask | (1 << u) | (1 << v)\n                if dp[new_mask] < dp[mask] + D[u][v]:\n                    dp[new_mask] = dp[mask] + D[u][v]\n    print(max(dp))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc318_d.json"
        },
        {
            "question_id": "abc343_c",
            "difficulty": "medium",
            "total_time": 318.5261495113373,
            "code_generation_time": 317.8470163345337,
            "passed_tests": 29,
            "total_tests": 29,
            "success_rate": 1.0,
            "total_input_tokens": 2132,
            "total_output_tokens": 11213,
            "error": null,
            "traceback": null,
            "code": "n = int(input())\n\ndef is_palindrome(num):\n    s = str(num)\n    return s == s[::-1]\n\nx_max = int(n ** (1/3)) + 2\n\nfor x in range(x_max, 0, -1):\n    cube = x ** 3\n    if cube <= n and is_palindrome(cube):\n        print(cube)\n        break",
            "history_file": "qwen3_14b/abc343_c.json"
        },
        {
            "question_id": "abc309_e",
            "difficulty": "hard",
            "total_time": 1517.830955505371,
            "code_generation_time": 1514.37406539917,
            "passed_tests": 51,
            "total_tests": 51,
            "success_rate": 1.0,
            "total_input_tokens": 9786,
            "total_output_tokens": 53595,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque\n\ndef main():\n    N, M = map(int, sys.stdin.readline().split())\n    children = [[] for _ in range(N + 1)]\n    parents = list(map(int, sys.stdin.readline().split()))\n    \n    for i in range(2, N + 1):\n        p = parents[i - 2]\n        children[p].append(i)\n    \n    coverage = [-1] * (N + 1)\n    q = deque()\n    \n    for _ in range(M):\n        x, y = map(int, sys.stdin.readline().split())\n        if coverage[x] < y:\n            coverage[x] = y\n            q.append(x)\n    \n    while q:\n        u = q.popleft()\n        for v in children[u]:\n            new_cov = coverage[u] - 1\n            if coverage[v] < new_cov:\n                coverage[v] = new_cov\n                q.append(v)\n    \n    count = 0\n    for i in range(1, N + 1):\n        if coverage[i] >= 0:\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc309_e.json"
        },
        {
            "question_id": "abc338_d",
            "difficulty": "hard",
            "total_time": 2744.9305996894836,
            "code_generation_time": 2744.642538547516,
            "passed_tests": 0,
            "total_tests": 27,
            "success_rate": 0.0,
            "total_input_tokens": 10820,
            "total_output_tokens": 97963,
            "error": null,
            "traceback": null,
            "code": "",
            "history_file": "qwen3_14b/abc338_d.json"
        },
        {
            "question_id": "abc329_f",
            "difficulty": "hard",
            "total_time": 1505.1462585926056,
            "code_generation_time": 1501.8620717525482,
            "passed_tests": 0,
            "total_tests": 42,
            "success_rate": 0.0,
            "total_input_tokens": 10074,
            "total_output_tokens": 53158,
            "error": null,
            "traceback": null,
            "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    q = int(data[1])\n    \n    # Initialize sets for each group\n    sets = [set() for _ in range(n)]\n    for i in range(n):\n        sets[i].add(i)  # Each group starts with its own index\n\n    idx = 2\n    results = []\n\n    for _ in range(q):\n        a = int(data[idx])\n        b = int(data[idx + 1])\n        idx += 2\n\n        # Ensure a and b are within bounds\n        if a < 0 or a >= n or b < 0 or b >= n:\n            results.append(\"Invalid group index\")\n            continue\n\n        # If set a is empty, just report the size of set b\n        if not sets[a]:\n            results.append(str(len(sets[b])))\n            continue\n\n        # If set a is larger than set b, swap them\n        if len(sets[a]) > len(sets[b]):\n            a, b = b, a\n\n        # Merge set a into set b\n        sets[b].update(sets[a])\n        sets[a].clear()\n\n        # Append the size of set b after the merge\n        results.append(str(len(sets[b])))\n\n    # Print all results\n    print(\"\\n\".join(results))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc329_f.json"
        },
        {
            "question_id": "abc306_c",
            "difficulty": "medium",
            "total_time": 189.7187705039978,
            "code_generation_time": 189.21214747428894,
            "passed_tests": 16,
            "total_tests": 16,
            "success_rate": 1.0,
            "total_input_tokens": 2363,
            "total_output_tokens": 6591,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    n = int(next(iterator))\n    A = [int(next(iterator)) for _ in range(3 * n)]\n    \n    positions = [[] for _ in range(n + 1)]\n    for idx, num in enumerate(A):\n        positions[num].append(idx + 1)  # 1-based index\n    \n    sorted_numbers = sorted(range(1, n + 1), key=lambda x: positions[x][1])\n    print(' '.join(map(str, sorted_numbers)))\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc306_c.json"
        },
        {
            "question_id": "abc331_b",
            "difficulty": "easy",
            "total_time": 609.9185044765472,
            "code_generation_time": 609.7119510173798,
            "passed_tests": 22,
            "total_tests": 22,
            "success_rate": 1.0,
            "total_input_tokens": 5952,
            "total_output_tokens": 21496,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    n, s, m, l = map(int, sys.stdin.read().split())\n    \n    # Calculate the maximum number of each pack type needed\n    max_6 = ((n + 5) // 6) + 1\n    max_8 = ((n + 7) // 8) + 1\n    max_12 = ((n + 11) // 12) + 1\n    \n    min_cost = float('inf')\n    \n    # Iterate through all combinations of small, medium, and large packs\n    for x in range(0, max_6 + 1):\n        for y in range(0, max_8 + 1):\n            for z in range(0, max_12 + 1):\n                total_eggs = 6 * x + 8 * y + 12 * z\n                if total_eggs >= n:\n                    cost = x * s + y * m + z * l\n                    if cost < min_cost:\n                        min_cost = cost\n    \n    print(min_cost)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc331_b.json"
        },
        {
            "question_id": "2869",
            "difficulty": "medium",
            "total_time": 824.5532236099243,
            "code_generation_time": 823.9930393695831,
            "passed_tests": 0,
            "total_tests": 83,
            "success_rate": 0.0,
            "total_input_tokens": 10554,
            "total_output_tokens": 28846,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = list(map(int, sys.stdin.read().split()))\n    n = len(input_data) // 2\n    nums1 = input_data[:n]\n    nums2 = input_data[n:]\n    \n    if n == 0:\n        print(0)\n        return\n    \n    max_len = 1\n    prev_dp1 = 1\n    prev_dp2 = 1\n    \n    for i in range(1, n):\n        current_dp1 = 1\n        current_dp2 = 1\n        \n        # Compute current_dp1\n        if nums1[i] >= nums1[i-1]:\n            current_dp1 = max(current_dp1, prev_dp1 + 1)\n        if nums1[i] >= nums2[i-1]:\n            current_dp1 = max(current_dp1, prev_dp2 + 1)\n        \n        # Compute current_dp2\n        if nums2[i] >= nums1[i-1]:\n            current_dp2 = max(current_dp2, prev_dp1 + 1)\n        if nums2[i] >= nums2[i-1]:\n            current_dp2 = max(current_dp2, prev_dp2 + 1)\n        \n        # Update max_len\n        current_max = max(current_dp1, current_dp2)\n        if current_max > max_len:\n            max_len = current_max\n        \n        # Update previous values\n        prev_dp1, prev_dp2 = current_dp1, current_dp2\n    \n    print(max_len)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/2869.json"
        },
        {
            "question_id": "abc332_d",
            "difficulty": "hard",
            "total_time": 1017.4923872947693,
            "code_generation_time": 1017.1305174827576,
            "passed_tests": 38,
            "total_tests": 38,
            "success_rate": 1.0,
            "total_input_tokens": 21901,
            "total_output_tokens": 35542,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport itertools\n\ndef count_inversions(perm):\n    inversions = 0\n    n = len(perm)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if perm[i] > perm[j]:\n                inversions += 1\n    return inversions\n\ndef main():\n    H, W = map(int, sys.stdin.readline().split())\n    A = [list(map(int, sys.stdin.readline().split())) for _ in range(H)]\n    B = [list(map(int, sys.stdin.readline().split())) for _ in range(H)]\n\n    # Check if multisets are equal\n    flat_A = [num for row in A for num in row]\n    flat_B = [num for row in B for num in row]\n    if sorted(flat_A) != sorted(flat_B):\n        print(-1)\n        return\n\n    min_swaps = float('inf')\n\n    # Generate all row permutations\n    for row_perm in itertools.permutations(range(H)):\n        # Apply row permutation to A\n        permuted_rows = [A[row] for row in row_perm]\n        # Generate all column permutations\n        for col_perm in itertools.permutations(range(W)):\n            # Apply column permutation to permuted_rows\n            transformed = []\n            for row in permuted_rows:\n                new_row = [row[col] for col in col_perm]\n                transformed.append(new_row)\n            # Check if transformed equals B\n            if transformed == B:\n                row_inv = count_inversions(row_perm)\n                col_inv = count_inversions(col_perm)\n                total = row_inv + col_inv\n                if total < min_swaps:\n                    min_swaps = total\n\n    if min_swaps == float('inf'):\n        print(-1)\n    else:\n        print(min_swaps)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc332_d.json"
        },
        {
            "question_id": "abc322_c",
            "difficulty": "medium",
            "total_time": 553.9089715480804,
            "code_generation_time": 553.0497670173645,
            "passed_tests": 27,
            "total_tests": 27,
            "success_rate": 1.0,
            "total_input_tokens": 1786,
            "total_output_tokens": 19701,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport bisect\n\ndef main():\n    data = sys.stdin.read().split()\n    ptr = 0\n    N = int(data[ptr])\n    ptr += 1\n    M = int(data[ptr])\n    ptr += 1\n    A = list(map(int, data[ptr:ptr + M]))\n    \n    for i in range(1, N + 1):\n        pos = bisect.bisect_left(A, i)\n        if pos < len(A) and A[pos] == i:\n            print(0)\n        else:\n            print(A[pos] - i)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc322_c.json"
        },
        {
            "question_id": "3094",
            "difficulty": "medium",
            "total_time": 976.3075501918793,
            "code_generation_time": 975.7042572498322,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 9999,
            "total_output_tokens": 34297,
            "error": null,
            "traceback": null,
            "code": "",
            "history_file": "qwen3_14b/3094.json"
        },
        {
            "question_id": "abc312_b",
            "difficulty": "easy",
            "total_time": 395.0725677013397,
            "code_generation_time": 394.90401315689087,
            "passed_tests": 14,
            "total_tests": 14,
            "success_rate": 1.0,
            "total_input_tokens": 4032,
            "total_output_tokens": 13946,
            "error": null,
            "traceback": null,
            "code": "# Read input\nN, M = map(int, input().split())\ngrid = [input().strip() for _ in range(N)]\n\nresult = []\n\n# Iterate over all possible top-left positions of a 9x9 subgrid\nfor i in range(N - 9 + 1):\n    for j in range(M - 9 + 1):\n        valid = True\n\n        # Check top-left 3x3\n        for row in range(i, i + 3):\n            for col in range(j, j + 3):\n                if grid[row][col] != '#':\n                    valid = False\n                    break\n            if not valid:\n                break\n        if not valid:\n            continue\n\n        # Check bottom-right 3x3\n        for row in range(i + 6, i + 9):\n            for col in range(j + 6, j + 9):\n                if grid[row][col] != '#':\n                    valid = False\n                    break\n            if not valid:\n                break\n        if not valid:\n            continue\n\n        # Check adjacent cells for top-left 3x3\n        # Row i+3, columns j to j+2\n        for col in range(j, j + 3):\n            if grid[i + 3][col] != '.':\n                valid = False\n                break\n        if not valid:\n            continue\n\n        # Column j+3, rows i to i+2\n        for row in range(i, i + 3):\n            if grid[row][j + 3] != '.':\n                valid = False\n                break\n        if not valid:\n            continue\n\n        # Cell (i+3, j+3)\n        if grid[i + 3][j + 3] != '.':\n            valid = False\n        if not valid:\n            continue\n\n        # Check adjacent cells for bottom-right 3x3\n        # Row i+5, columns j+6 to j+8\n        for col in range(j + 6, j + 9):\n            if grid[i + 5][col] != '.':\n                valid = False\n                break\n        if not valid:\n            continue\n\n        # Column j+5, rows i+6 to i+8\n        for row in range(i + 6, i + 9):\n            if grid[row][j + 5] != '.':\n                valid = False\n                break\n        if not valid:\n            continue\n\n        # Cell (i+5, j+5)\n        if grid[i + 5][j + 5] != '.':\n            valid = False\n        if not valid:\n            continue\n\n        # If all checks passed\n        result.append((i + 1, j + 1))\n\n# Output the result\nfor x, y in result:\n    print(x, y)",
            "history_file": "qwen3_14b/abc312_b.json"
        },
        {
            "question_id": "1899_C",
            "difficulty": "hard",
            "total_time": 351.6131238937378,
            "code_generation_time": 350.62663555145264,
            "passed_tests": 106,
            "total_tests": 106,
            "success_rate": 1.0,
            "total_input_tokens": 2899,
            "total_output_tokens": 12344,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef max_alternating_sum(arr):\n    current_even = float('-inf')\n    current_odd = float('-inf')\n    \n    # Initialize based on the first element\n    if arr[0] % 2 == 0:\n        current_even = arr[0]\n    else:\n        current_odd = arr[0]\n    \n    max_sum = max(current_even, current_odd)\n    \n    for i in range(1, len(arr)):\n        num = arr[i]\n        if num % 2 == 0:\n            # Current number is even\n            current_even = max(num, current_odd + num)\n            current_odd = float('-inf')\n        else:\n            # Current number is odd\n            current_odd = max(num, current_even + num)\n            current_even = float('-inf')\n        \n        max_sum = max(max_sum, current_even, current_odd)\n    \n    return max_sum\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    t = int(input[ptr])\n    ptr += 1\n    \n    for _ in range(t):\n        n = int(input[ptr])\n        ptr += 1\n        arr = list(map(int, input[ptr:ptr + n]))\n        ptr += n\n        result = max_alternating_sum(arr)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/1899_C.json"
        },
        {
            "question_id": "3228",
            "difficulty": "medium",
            "total_time": 877.8185951709747,
            "code_generation_time": 877.2115173339844,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 10852,
            "total_output_tokens": 30331,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    n = len(input_data) // 2\n    nums1 = list(map(int, input_data[:n]))\n    nums2 = list(map(int, input_data[n:]))\n\n    u1 = len(set(nums1))\n    u2 = len(set(nums2))\n    total_unique = len(set(nums1 + nums2))\n\n    max1 = min(u1, n // 2)\n    max2 = min(u2, n // 2)\n    result = min(max1 + max2, total_unique)\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/3228.json"
        },
        {
            "question_id": "abc318_b",
            "difficulty": "easy",
            "total_time": 153.35196042060852,
            "code_generation_time": 153.16138076782227,
            "passed_tests": 21,
            "total_tests": 21,
            "success_rate": 1.0,
            "total_input_tokens": 2161,
            "total_output_tokens": 5275,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    ptr = 0\n    N = int(data[ptr])\n    ptr += 1\n    rectangles = []\n    for _ in range(N):\n        A = int(data[ptr])\n        B = int(data[ptr + 1])\n        C = int(data[ptr + 2])\n        D = int(data[ptr + 3])\n        rectangles.append((A, B, C, D))\n        ptr += 4\n    total_area = 0\n    for x in range(100):\n        for y in range(100):\n            for (A, B, C, D) in rectangles:\n                if A <= x and B >= x + 1 and C <= y and D >= y + 1:\n                    total_area += 1\n                    break\n    print(total_area)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc318_b.json"
        },
        {
            "question_id": "abc333_c",
            "difficulty": "medium",
            "total_time": 275.72693943977356,
            "code_generation_time": 275.5393433570862,
            "passed_tests": 17,
            "total_tests": 17,
            "success_rate": 1.0,
            "total_input_tokens": 1718,
            "total_output_tokens": 9717,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    N = int(input_data[0])\n    \n    # Generate repunits up to 20 digits\n    repunits = []\n    for k in range(1, 21):  # 1 to 20 inclusive\n        repunit = (10**k - 1) // 9\n        repunits.append(repunit)\n    \n    # Generate all possible sums of three repunits\n    sums = set()\n    for a in repunits:\n        for b in repunits:\n            for c in repunits:\n                s = a + b + c\n                sums.add(s)\n    \n    # Sort the sums\n    sorted_sums = sorted(sums)\n    \n    # Get the N-th smallest\n    print(sorted_sums[N-1])\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc333_c.json"
        },
        {
            "question_id": "abc314_b",
            "difficulty": "easy",
            "total_time": 178.24923849105835,
            "code_generation_time": 178.07229161262512,
            "passed_tests": 20,
            "total_tests": 20,
            "success_rate": 1.0,
            "total_input_tokens": 2727,
            "total_output_tokens": 6196,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    N = int(next(iterator))\n    people = []\n    \n    for _ in range(N):\n        C_i = int(next(iterator))\n        bets = [int(next(iterator)) for _ in range(C_i)]\n        people.append((C_i, bets))\n    \n    X = int(next(iterator))\n    \n    # Collect candidates\n    candidates = []\n    for idx in range(N):\n        C_i, bets = people[idx]\n        if X in bets:\n            candidates.append((idx + 1, C_i))  # idx + 1 for 1-based indexing\n    \n    if not candidates:\n        print(0)\n        return\n    \n    # Find minimum number of bets among candidates\n    min_c = min(c for _, c in candidates)\n    filtered = [i for i, c in candidates if c == min_c]\n    filtered.sort()\n    \n    print(len(filtered))\n    print(' '.join(map(str, filtered)))\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc314_b.json"
        },
        {
            "question_id": "abc324_d",
            "difficulty": "hard",
            "total_time": 1205.672779083252,
            "code_generation_time": 1196.6645822525024,
            "passed_tests": 37,
            "total_tests": 43,
            "success_rate": 0.86,
            "total_input_tokens": 9643,
            "total_output_tokens": 41399,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    s = data[1]\n    \n    sorted_s = sorted(s)\n    max_num = 10 ** n - 1\n    m = int(max_num ** 0.5)\n    \n    count = 0\n    for i in range(m + 1):\n        square = i * i\n        square_str = str(square).zfill(n)\n        if sorted(square_str) == sorted_s:\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc324_d.json"
        },
        {
            "question_id": "3019",
            "difficulty": "easy",
            "total_time": 326.42186975479126,
            "code_generation_time": 325.81482100486755,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 4087,
            "total_output_tokens": 11294,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    moves = next(iterator)\n    \n    r = moves.count('R')\n    l = moves.count('L')\n    underscores = moves.count('_')\n    \n    base = r - l\n    max_distance = max(abs(base + underscores), abs(base - underscores))\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/3019.json"
        },
        {
            "question_id": "abc334_d",
            "difficulty": "medium",
            "total_time": 154.11320209503174,
            "code_generation_time": 152.41614770889282,
            "passed_tests": 24,
            "total_tests": 24,
            "success_rate": 1.0,
            "total_input_tokens": 2246,
            "total_output_tokens": 5235,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport bisect\n\ndef main():\n    input_data = sys.stdin.read().split()\n    ptr = 0\n    N = int(input_data[ptr])\n    ptr += 1\n    Q = int(input_data[ptr])\n    ptr += 1\n    R = list(map(int, input_data[ptr:ptr + N]))\n    ptr += N\n    queries = list(map(int, input_data[ptr:ptr + Q]))\n    \n    # Sort the R array\n    R.sort()\n    \n    # Compute prefix sums\n    prefix_sum = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_sum[i] = prefix_sum[i - 1] + R[i - 1]\n    \n    # Process each query\n    for X in queries:\n        k = bisect.bisect_right(prefix_sum, X) - 1\n        print(k)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc334_d.json"
        },
        {
            "question_id": "abc309_c",
            "difficulty": "medium",
            "total_time": 606.0046827793121,
            "code_generation_time": 604.0976800918579,
            "passed_tests": 27,
            "total_tests": 27,
            "success_rate": 1.0,
            "total_input_tokens": 3495,
            "total_output_tokens": 21458,
            "error": null,
            "traceback": null,
            "code": "import bisect\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    k = int(data[1])\n    \n    a_list = []\n    b_list = []\n    \n    index = 2\n    for _ in range(n):\n        a = int(data[index])\n        b = int(data[index + 1])\n        a_list.append(a)\n        b_list.append(b)\n        index += 2\n    \n    # Sort the pill types by the number of days they are taken\n    sorted_pairs = sorted(zip(a_list, b_list))\n    sorted_a = [a for a, b in sorted_pairs]\n    sorted_b = [b for a, b in sorted_pairs]\n    \n    n_pairs = len(sorted_a)\n    suffix_sums = [0] * (n_pairs + 1)\n    \n    # Build the suffix sum array\n    for i in range(n_pairs - 1, -1, -1):\n        suffix_sums[i] = suffix_sums[i + 1] + sorted_b[i]\n    \n    # Binary search for the earliest day\n    low = 1\n    max_a = sorted_a[-1] if n_pairs > 0 else 0\n    high = max_a + 1\n    ans = high\n    \n    while low <= high:\n        mid = (low + high) // 2\n        pos = bisect.bisect_left(sorted_a, mid)\n        s = suffix_sums[pos]\n        \n        if s <= k:\n            ans = mid\n            high = mid - 1\n        else:\n            low = mid + 1\n    \n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc309_c.json"
        },
        {
            "question_id": "abc343_b",
            "difficulty": "easy",
            "total_time": 157.2564148902893,
            "code_generation_time": 157.04781579971313,
            "passed_tests": 14,
            "total_tests": 14,
            "success_rate": 1.0,
            "total_input_tokens": 2432,
            "total_output_tokens": 5449,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = list(map(int, sys.stdin.read().split()))\n    if not input_data:\n        return\n\n    n = input_data[0]\n    matrix = []\n    index = 1\n\n    # Construct the adjacency matrix\n    for _ in range(n):\n        row = input_data[index:index + n]\n        matrix.append(row)\n        index += n\n\n    # Process each node\n    for i in range(1, n + 1):\n        row = matrix[i - 1]\n        connected = [j + 1 for j in range(n) if row[j] == 1]\n        connected.sort()\n        print(' '.join(map(str, connected)))\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc343_b.json"
        },
        {
            "question_id": "abc333_a",
            "difficulty": "easy",
            "total_time": 73.29890537261963,
            "code_generation_time": 73.20435118675232,
            "passed_tests": 7,
            "total_tests": 7,
            "success_rate": 1.0,
            "total_input_tokens": 1226,
            "total_output_tokens": 2436,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nsys.setrecursionlimit(200000)\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    N = int(next(iterator))\n    result = str(N) * N\n    print(result)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc333_a.json"
        },
        {
            "question_id": "abc312_c",
            "difficulty": "medium",
            "total_time": 1400.64622092247,
            "code_generation_time": 1399.798133611679,
            "passed_tests": 40,
            "total_tests": 41,
            "success_rate": 0.98,
            "total_input_tokens": 14020,
            "total_output_tokens": 49342,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport bisect\n\ndef find_min_price(sellers, buyers):\n    sellers.sort()\n    buyers.sort()\n    \n    left = 0\n    right = 10**9  # Upper bound for price\n    \n    while left < right:\n        mid = (left + right) // 2\n        \n        # Count of sellers willing to sell at price mid\n        count_sellers = bisect.bisect_right(sellers, mid)\n        \n        # Count of buyers willing to buy at price mid\n        count_buyers = len(buyers) - bisect.bisect_left(buyers, mid)\n        \n        if count_sellers >= count_buyers:\n            right = mid\n        else:\n            left = mid + 1\n    \n    return left\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    \n    iterator = iter(input_data)\n    \n    N = int(next(iterator))\n    M = int(next(iterator))\n    \n    sellers = list(map(int, [next(iterator) for _ in range(N)]))\n    buyers = list(map(int, [next(iterator) for _ in range(M)]))\n    \n    result = find_min_price(sellers, buyers)\n    print(result)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc312_c.json"
        },
        {
            "question_id": "abc312_f",
            "difficulty": "hard",
            "total_time": 1306.558109998703,
            "code_generation_time": 1305.9626064300537,
            "passed_tests": 0,
            "total_tests": 43,
            "success_rate": 0.0,
            "total_input_tokens": 17511,
            "total_output_tokens": 45801,
            "error": null,
            "traceback": null,
            "code": "",
            "history_file": "qwen3_14b/abc312_f.json"
        },
        {
            "question_id": "3225",
            "difficulty": "medium",
            "total_time": 810.1412398815155,
            "code_generation_time": 809.3525106906891,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 9353,
            "total_output_tokens": 28339,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef main():\n    input_data = list(map(int, sys.stdin.read().split()))\n    nums = input_data[:-1]\n    k = input_data[-1]\n    \n    if not nums:\n        print(0)\n        return\n\n    freq = defaultdict(int)\n    left = 0\n    max_len = 0\n\n    for right in range(len(nums)):\n        num = nums[right]\n        freq[num] += 1\n\n        # Shrink the window if the current element's frequency exceeds k\n        while freq[num] > k:\n            left_num = nums[left]\n            freq[left_num] -= 1\n            left += 1\n\n        # Update the maximum length of the valid window\n        current_len = right - left + 1\n        if current_len > max_len:\n            max_len = current_len\n\n    print(max_len)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/3225.json"
        },
        {
            "question_id": "abc303_e",
            "difficulty": "hard",
            "total_time": 2425.1494121551514,
            "code_generation_time": 2424.6842279434204,
            "passed_tests": 0,
            "total_tests": 18,
            "success_rate": 0.0,
            "total_input_tokens": 13243,
            "total_output_tokens": 86395,
            "error": null,
            "traceback": null,
            "code": "",
            "history_file": "qwen3_14b/abc303_e.json"
        },
        {
            "question_id": "abc305_a",
            "difficulty": "easy",
            "total_time": 113.77428936958313,
            "code_generation_time": 113.69616866111755,
            "passed_tests": 7,
            "total_tests": 7,
            "success_rate": 1.0,
            "total_input_tokens": 1674,
            "total_output_tokens": 3887,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    n = int(next(iterator))\n    nearest = ((n + 2) // 5) * 5\n    print(nearest)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc305_a.json"
        },
        {
            "question_id": "2884",
            "difficulty": "hard",
            "total_time": 1500.336472272873,
            "code_generation_time": 1498.1917152404785,
            "passed_tests": 33,
            "total_tests": 100,
            "success_rate": 0.33,
            "total_input_tokens": 11834,
            "total_output_tokens": 52670,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport json\n\ndef longest_valid_substring(word, forbidden):\n    forbidden_set = set(forbidden)\n    max_len = 0\n    start = 0  # Start of the current valid window\n\n    for i in range(len(word)):\n        # Check all substrings ending at i with length from 1 to 10\n        for l in range(1, 11):\n            if i - l + 1 < 0:\n                continue\n            substring = word[i - l + 1:i + 1]\n            if substring in forbidden_set:\n                start = max(start, i - l + 1 + 1)  # Move start past the forbidden substring\n        current_len = i - start + 1\n        if current_len > max_len:\n            max_len = current_len\n\n    return max_len\n\ndef main():\n    # Read the word from the first line\n    word = sys.stdin.readline().strip()\n    \n    # Read the forbidden list from the second line and parse it as JSON\n    forbidden = json.loads(sys.stdin.readline().strip())\n    \n    # Compute the result\n    result = longest_valid_substring(word, forbidden)\n    \n    # Print the result\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/2884.json"
        },
        {
            "question_id": "2866",
            "difficulty": "easy",
            "total_time": 753.6845581531525,
            "code_generation_time": 753.1163985729218,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 6847,
            "total_output_tokens": 26576,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().splitlines()\n    nums_str = data[0].strip()\n    threshold = int(data[1].strip())\n\n    # Parse the list of integers from the first line\n    nums = list(map(int, nums_str.strip('[]').split(',')))\n\n    max_len = 0\n\n    for l in range(len(nums)):\n        # Check if the current element is even and within the threshold\n        if nums[l] % 2 != 0 or nums[l] > threshold:\n            continue\n\n        current_len = 1\n        current_parity = nums[l] % 2\n\n        # Extend the subarray to the right\n        for r in range(l + 1, len(nums)):\n            if nums[r] > threshold:\n                break\n            if nums[r] % 2 == current_parity:\n                break\n            current_len += 1\n            current_parity = nums[r] % 2\n\n        # Update the maximum length if needed\n        if current_len > max_len:\n            max_len = current_len\n\n    print(max_len)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/2866.json"
        },
        {
            "question_id": "3320",
            "difficulty": "easy",
            "total_time": 622.2881729602814,
            "code_generation_time": 621.692542552948,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 8709,
            "total_output_tokens": 21531,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        print(0)\n        return\n    nums = list(map(int, input_data))\n    if len(nums) < 2:\n        print(0)\n        return\n    target = nums[0] + nums[1]\n    count = 1\n    i = 2\n    while i + 1 < len(nums):\n        if nums[i] + nums[i + 1] == target:\n            count += 1\n            i += 2\n        else:\n            break\n    print(count)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/3320.json"
        },
        {
            "question_id": "abc315_b",
            "difficulty": "easy",
            "total_time": 120.75726056098938,
            "code_generation_time": 120.55470275878906,
            "passed_tests": 24,
            "total_tests": 24,
            "success_rate": 1.0,
            "total_input_tokens": 2202,
            "total_output_tokens": 4124,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    M = int(next(iterator))\n    D = []\n    for _ in range(M):\n        D.append(int(next(iterator)))\n    total_days = sum(D)\n    middle = (total_days + 1) // 2\n    cumulative = 0\n    for i in range(M):\n        if cumulative + D[i] >= middle:\n            a = i + 1\n            b = middle - cumulative\n            print(f\"{a} {b}\")\n            return\n        else:\n            cumulative += D[i]\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc315_b.json"
        },
        {
            "question_id": "abc313_a",
            "difficulty": "easy",
            "total_time": 210.2326695919037,
            "code_generation_time": 210.05997467041016,
            "passed_tests": 12,
            "total_tests": 12,
            "success_rate": 1.0,
            "total_input_tokens": 4133,
            "total_output_tokens": 7121,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = list(map(int, sys.stdin.read().split()))\n    if not data:\n        return\n    n = data[0]\n    p = data[1:]\n    if n == 1:\n        print(0)\n        return\n    max_other = max(p[1:])\n    if p[0] > max_other:\n        print(0)\n    else:\n        print(max_other - p[0] + 1)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc313_a.json"
        },
        {
            "question_id": "abc329_e",
            "difficulty": "hard",
            "total_time": 2052.1208596229553,
            "code_generation_time": 2051.7792415618896,
            "passed_tests": 0,
            "total_tests": 48,
            "success_rate": 0.0,
            "total_input_tokens": 12148,
            "total_output_tokens": 72739,
            "error": null,
            "traceback": null,
            "code": "def can_replace_to_target(S, A, B, T):\n    # Step 1: Check length compatibility\n    count_A = S.count(A)\n    expected_len = len(S) - count_A * len(A) + count_A * len(B)\n    if len(T) != expected_len:\n        return False\n\n    # Step 2: Replace all occurrences of A with B\n    result = S.replace(A, B)\n\n    # Step 3: Compare with T\n    return result == T",
            "history_file": "qwen3_14b/abc329_e.json"
        },
        {
            "question_id": "3223",
            "difficulty": "hard",
            "total_time": 1592.7507474422455,
            "code_generation_time": 1585.7826862335205,
            "passed_tests": 81,
            "total_tests": 100,
            "success_rate": 0.81,
            "total_input_tokens": 16981,
            "total_output_tokens": 55560,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import Counter\n\ndef main():\n    word = sys.stdin.readline().strip()\n    k = int(sys.stdin.readline())\n    result = 0\n    n = len(word)\n    \n    for length in [k, 2 * k, 3 * k]:\n        if length > n:\n            continue\n        m = length // k\n        for i in range(n - length + 1):\n            substring = word[i:i+length]\n            # Check frequency condition\n            freq = Counter(substring)\n            if len(freq) != m:\n                continue\n            valid_freq = True\n            for char, count in freq.items():\n                if count != k:\n                    valid_freq = False\n                    break\n            if not valid_freq:\n                continue\n            # Check adjacency condition\n            valid_adjacent = True\n            for j in range(len(substring) - 1):\n                if abs(ord(substring[j]) - ord(substring[j+1])) > 2:\n                    valid_adjacent = False\n                    break\n            if valid_adjacent:\n                result += 1\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/3223.json"
        },
        {
            "question_id": "3017",
            "difficulty": "hard",
            "total_time": 1409.2392041683197,
            "code_generation_time": 1408.357189655304,
            "passed_tests": 97,
            "total_tests": 100,
            "success_rate": 0.97,
            "total_input_tokens": 14248,
            "total_output_tokens": 49457,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom functools import lru_cache\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    low = int(next(iterator))\n    high = int(next(iterator))\n    k = int(next(iterator))\n\n    def count(n, k):\n        if n < 1:\n            return 0\n        digits = list(map(int, str(n)))\n        n_len = len(digits)\n\n        @lru_cache(maxsize=None)\n        def dp(pos, even_count, odd_count, tight, mod, leading_zero):\n            if pos == n_len:\n                return 1 if even_count == odd_count and mod == 0 else 0\n\n            limit = digits[pos] if tight else 9\n            total = 0\n\n            for d in range(0, limit + 1):\n                new_tight = tight and (d == limit)\n                new_mod = (mod * 10 + d) % k\n                new_even = even_count\n                new_odd = odd_count\n                new_leading_zero = leading_zero and (d == 0)\n\n                if not new_leading_zero:\n                    if d % 2 == 0:\n                        new_even += 1\n                    else:\n                        new_odd += 1\n\n                total += dp(pos + 1, new_even, new_odd, new_tight, new_mod, new_leading_zero)\n\n            return total\n\n        return dp(0, 0, 0, True, 0, True)\n\n    result = count(high, k) - count(low - 1, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/3017.json"
        },
        {
            "question_id": "abc301_a",
            "difficulty": "easy",
            "total_time": 163.74332284927368,
            "code_generation_time": 163.61725521087646,
            "passed_tests": 12,
            "total_tests": 12,
            "success_rate": 1.0,
            "total_input_tokens": 1736,
            "total_output_tokens": 5689,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    N = int(next(iterator))\n    S = next(iterator)\n    count_T = S.count('T')\n    count_A = S.count('A')\n    if count_T > count_A:\n        print('T')\n    elif count_A > count_T:\n        print('A')\n    else:\n        K = count_T\n        current_T = 0\n        current_A = 0\n        for char in S:\n            if char == 'T':\n                current_T += 1\n            else:\n                current_A += 1\n            if current_T == K:\n                print('T')\n                return\n            if current_A == K:\n                print('A')\n                return\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc301_a.json"
        },
        {
            "question_id": "3210",
            "difficulty": "medium",
            "total_time": 908.7379593849182,
            "code_generation_time": 908.1203064918518,
            "passed_tests": 97,
            "total_tests": 100,
            "success_rate": 0.97,
            "total_input_tokens": 11919,
            "total_output_tokens": 31735,
            "error": null,
            "traceback": null,
            "code": "def main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    s = data[0]\n    k = int(data[1])\n    \n    n = len(s)\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    \n    # Build prefix sum array\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i + 1] = prefix[i] + (1 if s[i] in vowels else 0)\n    \n    count = 0\n    \n    # Iterate over all even lengths\n    for l in range(2, n + 1, 2):\n        max_start = n - l\n        for i in range(max_start + 1):\n            # Number of vowels in the substring s[i:i+l]\n            vowels_in_sub = prefix[i + l] - prefix[i]\n            if vowels_in_sub == l // 2:\n                if (vowels_in_sub * vowels_in_sub) % k == 0:\n                    count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/3210.json"
        },
        {
            "question_id": "3200",
            "difficulty": "medium",
            "total_time": 269.53334403038025,
            "code_generation_time": 269.03458166122437,
            "passed_tests": 87,
            "total_tests": 87,
            "success_rate": 1.0,
            "total_input_tokens": 2413,
            "total_output_tokens": 9398,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = 10**9 + 7\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    n = int(next(iterator))\n    \n    if n < 3:\n        print(0)\n        return\n    \n    # Compute all required powers\n    pow26 = pow(26, n, MOD)\n    pow25_n = pow(25, n, MOD)\n    pow25_n1 = pow(25, n - 1, MOD)\n    pow24_n = pow(24, n, MOD)\n    pow24_n1 = pow(24, n - 1, MOD)\n    pow23_n = pow(23, n, MOD)\n    pow23_n1 = pow(23, n - 1, MOD)\n    \n    # Compute each term\n    term1 = pow26\n    term2 = (3 * pow25_n) % MOD\n    term3 = (n * pow25_n1) % MOD\n    term4 = (3 * pow24_n) % MOD\n    term5 = (2 * n * pow24_n1) % MOD\n    term6 = pow23_n\n    term7 = (n * pow23_n1) % MOD\n    \n    # Apply the formula\n    result = (term1 - term2 - term3 + term4 + term5 - term6 - term7) % MOD\n    result = (result + MOD) % MOD  # Ensure non-negative result\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/3200.json"
        },
        {
            "question_id": "abc329_c",
            "difficulty": "medium",
            "total_time": 608.6843388080597,
            "code_generation_time": 608.475789308548,
            "passed_tests": 17,
            "total_tests": 17,
            "success_rate": 1.0,
            "total_input_tokens": 5370,
            "total_output_tokens": 21392,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        print(0)\n        return\n    iterator = iter(input_data)\n    N = int(next(iterator))\n    S = next(iterator)\n    \n    if not S:\n        print(0)\n        return\n    \n    max_runs = {}\n    current_char = S[0]\n    current_length = 1\n    \n    for c in S[1:]:\n        if c == current_char:\n            current_length += 1\n        else:\n            if current_length > max_runs.get(current_char, 0):\n                max_runs[current_char] = current_length\n            current_char = c\n            current_length = 1\n    \n    if current_length > max_runs.get(current_char, 0):\n        max_runs[current_char] = current_length\n    \n    print(sum(max_runs.values()))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc329_c.json"
        },
        {
            "question_id": "3025",
            "difficulty": "hard",
            "total_time": 1645.0952730178833,
            "code_generation_time": 1644.4991195201874,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 21568,
            "total_output_tokens": 57326,
            "error": null,
            "traceback": null,
            "code": "def min_operations(target, coins):\n    freq = coins.copy()\n    operations = 0\n\n    for i in range(31):  # Process up to 2^30\n        if (target >> i) & 1:\n            # Bit i is set in the target\n            if freq[i] > 0:\n                freq[i] -= 1\n            else:\n                # Find the smallest j > i with freq[j] > 0\n                found = False\n                j = i + 1\n                while j < 31:\n                    if freq[j] > 0:\n                        found = True\n                        break\n                    j += 1\n                if not found:\n                    return -1  # Not enough coins to form the target\n                operations += (j - i)\n                # Perform the splits\n                for k in range(j, i, -1):\n                    freq[k] -= 1\n                    freq[k - 1] += 2\n                # Use one of the resulting coins\n                freq[i] -= 1\n\n    return operations",
            "history_file": "qwen3_14b/3025.json"
        },
        {
            "question_id": "abc323_d",
            "difficulty": "hard",
            "total_time": 1169.422265291214,
            "code_generation_time": 1159.8894164562225,
            "passed_tests": 19,
            "total_tests": 30,
            "success_rate": 0.63,
            "total_input_tokens": 12855,
            "total_output_tokens": 39885,
            "error": null,
            "traceback": null,
            "code": "import heapq\nfrom collections import defaultdict\n\ndef main():\n    n = int(input())\n    counts = defaultdict(int)\n    heap = []\n\n    for _ in range(n):\n        size, cnt = map(int, input().split())\n        counts[size] += cnt\n        heapq.heappush(heap, size)\n\n    total = 0\n\n    while heap:\n        current_size = heapq.heappop(heap)\n        if counts[current_size] == 0:\n            continue\n        current_count = counts[current_size]\n        if current_count % 2 == 1:\n            total += 1\n            current_count -= 1\n        new_count = current_count // 2\n        counts[current_size] = 0\n        if new_count > 0:\n            next_size = current_size * 2\n            counts[next_size] += new_count\n            heapq.heappush(heap, next_size)\n\n    print(total)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc323_d.json"
        },
        {
            "question_id": "abc334_e",
            "difficulty": "hard",
            "total_time": 1046.2857179641724,
            "code_generation_time": 1041.5000965595245,
            "passed_tests": 31,
            "total_tests": 31,
            "success_rate": 1.0,
            "total_input_tokens": 12237,
            "total_output_tokens": 36215,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque\n\nMOD = 998244353\n\ndef main():\n    H, W = map(int, sys.stdin.readline().split())\n    grid = [sys.stdin.readline().strip() for _ in range(H)]\n    \n    component_id = [[0]*W for _ in range(H)]\n    current_component = 0\n    \n    directions = [(-1,0), (1,0), (0,-1), (0,1)]\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '#' and component_id[i][j] == 0:\n                current_component += 1\n                q = deque()\n                q.append((i, j))\n                component_id[i][j] = current_component\n                while q:\n                    x, y = q.popleft()\n                    for dx, dy in directions:\n                        nx = x + dx\n                        ny = y + dy\n                        if 0 <= nx < H and 0 <= ny < W:\n                            if grid[nx][ny] == '#' and component_id[nx][ny] == 0:\n                                component_id[nx][ny] = current_component\n                                q.append((nx, ny))\n    \n    sum_1_minus_m = 0\n    R = 0\n    \n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '.':\n                R += 1\n                neighbors = set()\n                for dx, dy in directions:\n                    nx = i + dx\n                    ny = j + dy\n                    if 0 <= nx < H and 0 <= ny < W:\n                        if grid[nx][ny] == '#':\n                            neighbors.add(component_id[nx][ny])\n                m = len(neighbors)\n                sum_1_minus_m += (1 - m)\n    \n    if R == 0:\n        print(current_component % MOD)\n    else:\n        numerator = (current_component * R + sum_1_minus_m) % MOD\n        denominator = R\n        inv_denominator = pow(denominator, MOD-2, MOD)\n        result = (numerator * inv_denominator) % MOD\n        print(result)\n    \nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc334_e.json"
        },
        {
            "question_id": "abc325_d",
            "difficulty": "hard",
            "total_time": 600.104250907898,
            "code_generation_time": 596.3733766078949,
            "passed_tests": 20,
            "total_tests": 44,
            "success_rate": 0.45,
            "total_input_tokens": 11117,
            "total_output_tokens": 20153,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    N = int(next(iterator))\n    products = []\n    for _ in range(N):\n        T = int(next(iterator))\n        D = int(next(iterator))\n        end = T + D\n        products.append((T, end))\n    # Sort by end time, then by start time\n    products.sort(key=lambda x: (x[1], x[0]))\n    count = 0\n    last_print = -float('inf')\n    for T, end in products:\n        earliest = max(last_print + 1, T)\n        if earliest <= end:\n            count += 1\n            last_print = earliest\n    print(count)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc325_d.json"
        },
        {
            "question_id": "3151",
            "difficulty": "medium",
            "total_time": 1223.6194908618927,
            "code_generation_time": 1223.261039018631,
            "passed_tests": 0,
            "total_tests": 53,
            "success_rate": 0.0,
            "total_input_tokens": 8944,
            "total_output_tokens": 43180,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    # Read all input data\n    data = list(map(int, sys.stdin.read().split()))\n    \n    # Determine the number of processors\n    n = len(data) // 5  # Since total elements = n + 4n = 5n\n    \n    # Split into processor times and task times\n    processor_time = data[:n]\n    tasks = data[n:]\n    \n    # Sort the lists\n    processor_time.sort()\n    tasks.sort(reverse=True)\n    \n    # Initialize the maximum time\n    max_time = 0\n    \n    # Assign tasks to each processor and compute max time\n    for i in range(n):\n        start = i * 4\n        current_max = 0\n        for j in range(4):\n            task_time = tasks[start + j]\n            current_time = processor_time[i] + task_time\n            if current_time > current_max:\n                current_max = current_time\n        if current_max > max_time:\n            max_time = current_max\n    \n    # Output the result\n    print(max_time)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/3151.json"
        },
        {
            "question_id": "2844",
            "difficulty": "easy",
            "total_time": 431.49683570861816,
            "code_generation_time": 430.88637137413025,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 7233,
            "total_output_tokens": 14703,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n\n    # Use an iterator to consume the input values\n    iterator = iter(input_data)\n    nums = []\n    while True:\n        try:\n            nums.append(int(next(iterator)))\n        except StopIteration:\n            break\n\n    n = len(nums)\n    sum_squares = 0\n\n    # Iterate over all possible divisors of n\n    for i in range(1, n + 1):\n        if n % i == 0:\n            sum_squares += nums[i - 1] ** 2\n\n    print(sum_squares)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/2844.json"
        },
        {
            "question_id": "abc341_d",
            "difficulty": "medium",
            "total_time": 443.6725580692291,
            "code_generation_time": 443.42139315605164,
            "passed_tests": 32,
            "total_tests": 32,
            "success_rate": 1.0,
            "total_input_tokens": 5905,
            "total_output_tokens": 15394,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport math\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    N = int(next(iterator))\n    M = int(next(iterator))\n    K = int(next(iterator))\n    \n    lcm = N * M // math.gcd(N, M)\n    \n    low = 1\n    high = max(N, M) * K\n    \n    while low < high:\n        mid = (low + high) // 2\n        count = (mid // N) + (mid // M) - 2 * (mid // lcm)\n        if count < K:\n            low = mid + 1\n        else:\n            high = mid\n    print(low)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc341_d.json"
        },
        {
            "question_id": "2816",
            "difficulty": "easy",
            "total_time": 178.02661561965942,
            "code_generation_time": 177.43395376205444,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 1761,
            "total_output_tokens": 6147,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    s = input_data[0]\n    s_list = list(s)\n    n = len(s)\n    for i in range(n // 2):\n        j = n - 1 - i\n        if s_list[i] != s_list[j]:\n            min_char = min(s_list[i], s_list[j])\n            s_list[i] = min_char\n            s_list[j] = min_char\n    print(''.join(s_list))\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/2816.json"
        },
        {
            "question_id": "abc343_d",
            "difficulty": "medium",
            "total_time": 825.92999792099,
            "code_generation_time": 824.8313217163086,
            "passed_tests": 19,
            "total_tests": 19,
            "success_rate": 1.0,
            "total_input_tokens": 8128,
            "total_output_tokens": 29006,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef main():\n    input_data = sys.stdin.read().split()\n    ptr = 0\n    N = int(input_data[ptr])\n    ptr += 1\n    T = int(input_data[ptr])\n    ptr += 1\n\n    current_scores = [0] * (N + 1)  # 1-based indexing\n    score_counts = defaultdict(int)\n    score_counts[0] = N  # All players start with score 0\n\n    results = []\n\n    for _ in range(T):\n        A = int(input_data[ptr])\n        ptr += 1\n        B = int(input_data[ptr])\n        ptr += 1\n\n        old_score = current_scores[A]\n        # Decrease count of old score\n        if score_counts[old_score] == 1:\n            del score_counts[old_score]\n        else:\n            score_counts[old_score] -= 1\n\n        # Update the player's score\n        new_score = old_score + B\n        current_scores[A] = new_score\n\n        # Increase count of new score\n        score_counts[new_score] += 1\n\n        # Append the number of distinct scores\n        results.append(str(len(score_counts)))\n\n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc343_d.json"
        },
        {
            "question_id": "abc305_e",
            "difficulty": "hard",
            "total_time": 231.28445196151733,
            "code_generation_time": 228.02774310112,
            "passed_tests": 31,
            "total_tests": 31,
            "success_rate": 1.0,
            "total_input_tokens": 3270,
            "total_output_tokens": 7770,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport heapq\nimport math\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr]); ptr += 1\n    M = int(input[ptr]); ptr += 1\n    K = int(input[ptr]); ptr += 1\n\n    # Build adjacency list\n    adj = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a = int(input[ptr]); ptr += 1\n        b = int(input[ptr]); ptr += 1\n        adj[a].append(b)\n        adj[b].append(a)\n\n    # Initialize max_stamina with -infinity\n    max_stamina = [-math.inf] * (N + 1)\n    heap = []\n\n    # Read guards and initialize the heap\n    for _ in range(K):\n        p = int(input[ptr]); ptr += 1\n        h = int(input[ptr]); ptr += 1\n        max_stamina[p] = h\n        heapq.heappush(heap, (-h, p))  # Use negative for max-heap simulation\n\n    # Process the heap\n    while heap:\n        current_neg_stamina, u = heapq.heappop(heap)\n        current_stamina = -current_neg_stamina\n\n        # Skip if this is not the best stamina for this node\n        if current_stamina < max_stamina[u]:\n            continue\n\n        # Propagate to neighbors\n        for v in adj[u]:\n            new_stamina = current_stamina - 1\n            if new_stamina > max_stamina[v]:\n                max_stamina[v] = new_stamina\n                heapq.heappush(heap, (-new_stamina, v))\n\n    # Collect and sort the result\n    result = []\n    for v in range(1, N + 1):\n        if max_stamina[v] >= 0:\n            result.append(v)\n    result.sort()\n\n    print(len(result))\n    if result:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc305_e.json"
        },
        {
            "question_id": "abc311_c",
            "difficulty": "medium",
            "total_time": 1579.9513251781464,
            "code_generation_time": 1579.6141502857208,
            "passed_tests": 0,
            "total_tests": 51,
            "success_rate": 0.0,
            "total_input_tokens": 11505,
            "total_output_tokens": 55850,
            "error": null,
            "traceback": null,
            "code": "def find_cycle(A):\n    n = len(A)\n    visited = [False] * (n + 1)  # 1-based indexing for nodes\n\n    for node in range(1, n + 1):\n        if not visited[node]:\n            path = []\n            path_dict = {}\n            current = node\n\n            while True:\n                if visited[current]:\n                    if current in path_dict:\n                        index = path_dict[current]\n                        cycle = path[index:] + [current]\n                        return cycle\n                    else:\n                        break\n                visited[current] = True\n                path_dict[current] = len(path)\n                path.append(current)\n\n                next_node = A[current - 1]  # A is 0-based, nodes are 1-based\n                if next_node in path_dict:\n                    index = path_dict[next_node]\n                    cycle = path[index:] + [next_node]\n                    return cycle\n\n                current = next_node\n\n    return None",
            "history_file": "qwen3_14b/abc311_c.json"
        },
        {
            "question_id": "abc326_e",
            "difficulty": "hard",
            "total_time": 398.7421860694885,
            "code_generation_time": 398.04009532928467,
            "passed_tests": 27,
            "total_tests": 27,
            "success_rate": 1.0,
            "total_input_tokens": 3312,
            "total_output_tokens": 14036,
            "error": null,
            "traceback": null,
            "code": "MOD = 998244353\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    # Step 1: Compute prefix sums modulo MOD\n    prefix_A = [0] * (N + 1)\n    for i in range(1, N + 1):\n        prefix_A[i] = (prefix_A[i - 1] + A[i - 1]) % MOD\n\n    # Step 2: Compute modular inverse of N\n    inv_N = pow(N, MOD - 2, MOD)\n\n    # Step 3: Initialize arrays for intermediate values\n    S = [0] * (N + 1)\n    T = [0] * (N + 2)\n    T[N + 1] = 0  # Base case\n\n    # Step 4: Backward iteration to compute S and T\n    for x in range(N, -1, -1):\n        sum_A = (prefix_A[N] - prefix_A[x]) % MOD\n        sum_S = T[x + 1]\n        term = (sum_S * inv_N) % MOD\n        S[x] = (sum_A + term) % MOD\n        T[x] = (S[x] + T[x + 1]) % MOD\n\n    # Step 5: Compute final answer\n    ans = (S[0] * inv_N) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "qwen3_14b/abc326_e.json"
        },
        {
            "question_id": "3298",
            "difficulty": "hard",
            "total_time": 1929.848515033722,
            "code_generation_time": 1929.2653608322144,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 10411,
            "total_output_tokens": 68247,
            "error": null,
            "traceback": null,
            "code": "def longest_consecutive_sequence(nums):\n    used = set()\n    dp = {}\n    max_length = 0\n\n    for num in nums:\n        if num not in used:\n            used.add(num)\n            # Process the number as the end of a sequence\n            if (num - 1) in dp:\n                dp[num] = dp[num - 1] + 1\n            else:\n                dp[num] = 1\n            if dp[num] > max_length:\n                max_length = dp[num]\n\n            # Process the number + 1 as the next in the sequence\n            if (num + 1) not in used:\n                used.add(num + 1)\n                if num in dp:\n                    dp[num + 1] = dp[num] + 1\n                else:\n                    dp[num + 1] = 1\n                if dp[num + 1] > max_length:\n                    max_length = dp[num + 1]\n\n    return max_length",
            "history_file": "qwen3_14b/3298.json"
        },
        {
            "question_id": "2824",
            "difficulty": "easy",
            "total_time": 173.26534056663513,
            "code_generation_time": 172.66186213493347,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 1677,
            "total_output_tokens": 5967,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nsys.setrecursionlimit(200000)\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    n = int(next(iterator))\n    twice = 2 * n\n    thrice = 3 * n\n    concatenated = str(n) + str(twice) + str(thrice)\n    if len(concatenated) != 9:\n        print(\"false\")\n        return\n    if '0' in concatenated:\n        print(\"false\")\n        return\n    sorted_concat = sorted(concatenated)\n    target = sorted('123456789')\n    if sorted_concat == target:\n        print(\"true\")\n    else:\n        print(\"false\")\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/2824.json"
        },
        {
            "question_id": "abc313_c",
            "difficulty": "medium",
            "total_time": 909.0840456485748,
            "code_generation_time": 908.5438911914825,
            "passed_tests": 13,
            "total_tests": 27,
            "success_rate": 0.48,
            "total_input_tokens": 9497,
            "total_output_tokens": 31831,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    n = int(next(iterator))\n    a = list(map(int, [next(iterator) for _ in range(n)]))\n    \n    total_sum = sum(a)\n    avg_floor = total_sum // n\n    rem = total_sum % n\n    \n    excess = 0\n    for num in a:\n        if num > avg_floor:\n            excess += num - avg_floor\n    \n    print(excess - rem)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc313_c.json"
        },
        {
            "question_id": "abc307_e",
            "difficulty": "hard",
            "total_time": 153.80105996131897,
            "code_generation_time": 153.59699630737305,
            "passed_tests": 21,
            "total_tests": 21,
            "success_rate": 1.0,
            "total_input_tokens": 1878,
            "total_output_tokens": 5294,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = 998244353\n\ndef main():\n    input_data = sys.stdin.read().split()\n    if not input_data:\n        return\n    iterator = iter(input_data)\n    N = int(next(iterator))\n    M = int(next(iterator))\n    \n    term1 = pow(M-1, N, MOD)\n    if N % 2 == 0:\n        term2 = (M-1) % MOD\n    else:\n        term2 = (MOD - (M-1) % MOD) % MOD\n    \n    result = (term1 + term2) % MOD\n    print(result)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "qwen3_14b/abc307_e.json"
        }
    ]
}
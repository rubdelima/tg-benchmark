{
    "model": "qwen3-coder:480b-cloud",
    "architecture": "simple",
    "total_test_time": 2049.4368438720703,
    "total_input_tokens": 84939,
    "total_output_tokens": 44577,
    "score": 54.3074074074074,
    "tokens_per_second": 21.750853232334386,
    "difficulty_stats": {
        "easy": {
            "total": 30,
            "passed": 25,
            "percentage": 83.33333333333334
        },
        "medium": {
            "total": 30,
            "passed": 15,
            "percentage": 50.0
        },
        "hard": {
            "total": 30,
            "passed": 5,
            "percentage": 16.666666666666664
        }
    },
    "completed_at": "2025-12-03T07:00:58.085003",
    "results": [
        {
            "question_id": "abc341_b",
            "difficulty": "easy",
            "total_time": 7.535867214202881,
            "code_generation_time": 6.3559770584106445,
            "passed_tests": 22,
            "total_tests": 22,
            "success_rate": 1.0,
            "total_input_tokens": 1116,
            "total_output_tokens": 200,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    S = [0]*(N-1)\n    T = [0]*(N-1)\n    \n    for i in range(N-1):\n        S[i] = int(data[1 + N + 2*i])\n        T[i] = int(data[1 + N + 2*i + 1])\n    \n    # Process from left to right\n    for i in range(N-1):\n        if A[i] >= S[i]:\n            num = A[i] // S[i]\n            A[i] -= num * S[i]\n            A[i+1] += num * T[i]\n    \n    print(A[N-1])\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "1899_B",
            "difficulty": "hard",
            "total_time": 4.835697650909424,
            "code_generation_time": 3.737946033477783,
            "passed_tests": 39,
            "total_tests": 39,
            "success_rate": 1.0,
            "total_input_tokens": 1399,
            "total_output_tokens": 224,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom math import isqrt\n\ndef solve():\n    t = int(sys.stdin.readline())\n    for _ in range(t):\n        n = int(sys.stdin.readline())\n        a = list(map(int, sys.stdin.readline().split()))\n        \n        max_diff = 0\n        \n        # For each possible k (number of boxes per truck)\n        for k in range(1, n + 1):\n            if n % k != 0:\n                continue\n            \n            num_trucks = n // k\n            if num_trucks == 1:\n                continue\n            \n            # Calculate sum for each truck\n            truck_sums = []\n            for i in range(num_trucks):\n                s = sum(a[i * k:(i + 1) * k])\n                truck_sums.append(s)\n            \n            min_sum = min(truck_sums)\n            max_sum = max(truck_sums)\n            diff = max_sum - min_sum\n            max_diff = max(max_diff, diff)\n        \n        print(max_diff)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc332_b",
            "difficulty": "easy",
            "total_time": 3.5515029430389404,
            "code_generation_time": 3.169771432876587,
            "passed_tests": 30,
            "total_tests": 30,
            "success_rate": 1.0,
            "total_input_tokens": 930,
            "total_output_tokens": 136,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    K, G, M = map(int, sys.stdin.readline().split())\n    \n    glass = 0\n    mug = 0\n    \n    for _ in range(K):\n        if glass == G:\n            glass = 0\n        elif mug == 0:\n            mug = M\n        else:\n            # Transfer water from mug to glass\n            space_in_glass = G - glass\n            transfer_amount = min(mug, space_in_glass)\n            glass += transfer_amount\n            mug -= transfer_amount\n    \n    print(glass, mug)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc337_e",
            "difficulty": "hard",
            "total_time": 13.664554357528687,
            "code_generation_time": 13.393413066864014,
            "passed_tests": 0,
            "total_tests": 25,
            "success_rate": 0.0,
            "total_input_tokens": 1322,
            "total_output_tokens": 283,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport math\n\ndef solve():\n    N = int(input())\n    \n    # Calculate the minimum number of friends needed\n    M = math.ceil(math.log2(N))\n    \n    # Print the number of friends\n    print(M)\n    sys.stdout.flush()\n    \n    # For each friend, determine which bottles to give\n    friends_bottles = []\n    for i in range(M):\n        bottles = []\n        for j in range(1, N + 1):\n            # Check if the j-th bottle (0-indexed j-1) has bit i set\n            if (j - 1) & (1 << i):\n                bottles.append(j)\n        friends_bottles.append(bottles)\n        print(len(bottles), *bottles)\n        sys.stdout.flush()\n    \n    # Read the results for each friend\n    S = input().strip()\n    \n    # Determine the spoiled bottle\n    spoiled = 0\n    for i in range(M):\n        if S[i] == '1':\n            spoiled |= (1 << i)\n    \n    # Convert to 1-indexed\n    spoiled += 1\n    \n    # Ensure the result is within bounds\n    if spoiled > N:\n        spoiled = N\n    \n    print(spoiled)\n    sys.stdout.flush()\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3207",
            "difficulty": "easy",
            "total_time": 12.014209985733032,
            "code_generation_time": 11.313367128372192,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 643,
            "total_output_tokens": 191,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    s1 = input().strip()\n    s2 = input().strip()\n    s3 = input().strip()\n    \n    # Find the longest common prefix\n    min_len = min(len(s1), len(s2), len(s3))\n    common_len = 0\n    \n    for i in range(min_len):\n        if s1[i] == s2[i] == s3[i]:\n            common_len += 1\n        else:\n            break\n    \n    # If there is no common prefix, return -1\n    if common_len == 0:\n        print(-1)\n        return\n    \n    # Calculate the number of operations needed\n    operations = (len(s1) - common_len) + (len(s2) - common_len) + (len(s3) - common_len)\n    print(operations)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2837",
            "difficulty": "medium",
            "total_time": 35.91900324821472,
            "code_generation_time": 35.034316301345825,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 697,
            "total_output_tokens": 881,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef min_operations(num1, num2):\n    # After k operations, we have:\n    # num1 - k * num2 - sum of (2^i_j) for j=1 to k = 0\n    # => num1 - k * num2 = sum of (2^i_j)\n    # Let S = num1 - k * num2. We need S = sum of k powers of 2 (each power between 0 and 60).\n    # For this to be possible:\n    # 1. S >= k (since minimum sum of k powers of 2 is k * 2^0 = k)\n    # 2. S <= k * 2^60 (since maximum sum of k powers of 2 is k * 2^60)\n    # 3. The number of 1-bits in binary representation of S (popcount) <= k\n    #    (because we can always break down larger powers to make up the count)\n    \n    # If num2 >= 0, then S decreases as k increases. \n    # If num2 < 0, then S increases as k increases.\n    \n    # Try k from 1 to some reasonable upper bound.\n    # Since num1 can be up to 10^9, and we're subtracting at least 1 each time,\n    # we won't need more than 10^9 operations in the worst case, but that's too much.\n    # However, if k > num1, we're subtracting more than we have, so it's not efficient.\n    # A better upper bound is when the subtraction per operation is 1 (2^0), \n    # so num1 - k*num2 = k => k = num1 / (num2 + 1). But this is complex.\n    \n    # Let's try a practical approach: try k from 1 to min(100000, num1 + 1000)\n    # But even better, we can derive a tighter bound.\n    \n    # After k operations: num1 - k*num2 - (sum of k terms of form 2^i) = 0\n    # => sum of k terms = num1 - k*num2 = S\n    # For this to be possible, we need:\n    # 1. S >= k (minimum sum of k powers of 2)\n    # 2. S <= k * 2^60 (maximum sum of k powers of 2)\n    # 3. popcount(S) <= k (we can always break down powers to increase count)\n    \n    for k in range(1, 100000):  # Try up to 100000 operations\n        S = num1 - k * num2\n        if S < 0:\n            # If S is negative, we're subtracting too much\n            # If num2 > 0, S will only get more negative, so we can break\n            if num2 > 0:\n                break\n            else:\n                continue\n        \n        # Check if it's possible to express S as sum of exactly k powers of 2\n        # Minimum sum is k (all 2^0), maximum is k * 2^60\n        if S < k:\n            continue\n        if S > k * (1 << 60):\n            continue\n            \n        # Count number of 1-bits in S\n        popcount = bin(S).count('1')\n        \n        # We can form S with k powers of 2 if:\n        # 1. popcount <= k (we have enough terms)\n        # 2. k <= S (we don't have more terms than the value itself, since min value per term is 1)\n        if popcount <= k and k <= S:\n            return k\n    \n    return -1\n\ndef solve():\n    num1 = int(input().strip())\n    num2 = int(input().strip())\n    result = min_operations(num1, num2)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3331",
            "difficulty": "easy",
            "total_time": 17.277386903762817,
            "code_generation_time": 16.761093378067017,
            "passed_tests": 0,
            "total_tests": 57,
            "success_rate": 0.0,
            "total_input_tokens": 802,
            "total_output_tokens": 110,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    # Read input\n    nums = list(map(int, sys.stdin.readline().strip().split()))\n    k = int(sys.stdin.readline().strip())\n    \n    # Count how many elements are less than k\n    count = 0\n    for num in nums:\n        if num < k:\n            count += 1\n    \n    # The minimum number of operations is equal to the count of elements less than k\n    print(count)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc322_e",
            "difficulty": "hard",
            "total_time": 27.091248512268066,
            "code_generation_time": 24.64576244354248,
            "passed_tests": 44,
            "total_tests": 44,
            "success_rate": 1.0,
            "total_input_tokens": 1048,
            "total_output_tokens": 383,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport itertools\n\ndef solve():\n    N, K, P = map(int, sys.stdin.readline().split())\n    plans = []\n    for _ in range(N):\n        line = list(map(int, sys.stdin.readline().split()))\n        C = line[0]\n        A = line[1:]\n        plans.append((C, A))\n    \n    # Generate all possible subsets of development plans\n    min_cost = float('inf')\n    found = False\n    \n    # We'll use dynamic programming with state compression\n    # State: tuple of current parameter values (clamped to P)\n    # Since P <= 5 and K <= 5, there are at most 6^K states\n    \n    # Initialize DP: dp[state] = minimum cost to reach that state\n    # State is a tuple of K values, each clamped to at most P\n    dp = {tuple([0]*K): 0}\n    \n    for i in range(N):\n        cost, increases = plans[i]\n        # Create new DP states by applying this plan to all existing states\n        new_dp = dp.copy()\n        for state, current_cost in dp.items():\n            # Compute new state after applying plan i\n            new_state = tuple(min(P, state[j] + increases[j]) for j in range(K))\n            new_cost = current_cost + cost\n            if new_state not in new_dp or new_cost < new_dp[new_state]:\n                new_dp[new_state] = new_cost\n        dp = new_dp\n    \n    # Check if any state has all parameters >= P\n    target = tuple([P]*K)\n    if target in dp:\n        min_cost = dp[target]\n        found = True\n    \n    if found:\n        print(min_cost)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc315_f",
            "difficulty": "hard",
            "total_time": 19.692447185516357,
            "code_generation_time": 18.809426307678223,
            "passed_tests": 0,
            "total_tests": 66,
            "success_rate": 0.0,
            "total_input_tokens": 1193,
            "total_output_tokens": 289,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport math\n\ndef euclidean_distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef solve():\n    N = int(sys.stdin.readline())\n    points = []\n    for _ in range(N):\n        x, y = map(int, sys.stdin.readline().split())\n        points.append((x, y))\n    \n    # dp[i] represents the minimum cost to reach checkpoint i\n    dp = [float('inf')] * N\n    dp[0] = 0\n    \n    for i in range(N):\n        for j in range(i + 1, N):\n            # Calculate distance from i to j\n            dist = euclidean_distance(points[i], points[j])\n            \n            # Calculate penalty for skipping checkpoints between i and j\n            skipped = j - i - 1\n            if skipped == 0:\n                penalty = 0\n            else:\n                penalty = 2 ** (skipped - 1)\n            \n            # Total cost to go from i to j\n            cost = dist + penalty\n            \n            # Update dp[j]\n            if dp[i] + cost < dp[j]:\n                dp[j] = dp[i] + cost\n    \n    print(dp[N-1])\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc335_a",
            "difficulty": "easy",
            "total_time": 12.83377456665039,
            "code_generation_time": 12.612981796264648,
            "passed_tests": 17,
            "total_tests": 17,
            "success_rate": 1.0,
            "total_input_tokens": 678,
            "total_output_tokens": 61,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    S = input().strip()\n    # Change the last character from '3' to '4'\n    modified_S = S[:-1] + '4'\n    print(modified_S)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc304_b",
            "difficulty": "easy",
            "total_time": 14.266007661819458,
            "code_generation_time": 14.021141767501831,
            "passed_tests": 18,
            "total_tests": 18,
            "success_rate": 1.0,
            "total_input_tokens": 859,
            "total_output_tokens": 218,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(input().strip())\n    \n    if N <= 10**3 - 1:\n        print(N)\n    elif N <= 10**4 - 1:\n        print(N // 10 * 10)\n    elif N <= 10**5 - 1:\n        print(N // 100 * 100)\n    elif N <= 10**6 - 1:\n        print(N // 1000 * 1000)\n    elif N <= 10**7 - 1:\n        print(N // 10000 * 10000)\n    elif N <= 10**8 - 1:\n        print(N // 100000 * 100000)\n    else:\n        print(N // 1000000 * 1000000)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc341_a",
            "difficulty": "easy",
            "total_time": 16.49222445487976,
            "code_generation_time": 16.357604503631592,
            "passed_tests": 9,
            "total_tests": 9,
            "success_rate": 1.0,
            "total_input_tokens": 580,
            "total_output_tokens": 74,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(input())\n    result = \"\"\n    for i in range(2 * N + 1):\n        if i % 2 == 0:\n            result += \"1\"\n        else:\n            result += \"0\"\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2877",
            "difficulty": "medium",
            "total_time": 19.215428352355957,
            "code_generation_time": 18.38768243789673,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 743,
            "total_output_tokens": 283,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom itertools import permutations\n\ndef merge(s1, s2):\n    \"\"\"Merge two strings with maximum overlap.\"\"\"\n    if s1 in s2:\n        return s2\n    if s2 in s1:\n        return s1\n    \n    # Try to overlap s1 and s2\n    max_overlap = min(len(s1), len(s2))\n    for i in range(max_overlap, 0, -1):\n        if s1[-i:] == s2[:i]:\n            return s1 + s2[i:]\n    return s1 + s2\n\ndef solve():\n    a = input().strip()\n    b = input().strip()\n    c = input().strip()\n    \n    strings = [a, b, c]\n    min_length = float('inf')\n    result = \"\"\n    \n    # Try all permutations of the three strings\n    for perm in permutations(strings):\n        # Merge the three strings in order\n        merged = merge(perm[0], perm[1])\n        merged = merge(merged, perm[2])\n        \n        # Update result if this is better\n        if len(merged) < min_length or (len(merged) == min_length and merged < result):\n            min_length = len(merged)\n            result = merged\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2878",
            "difficulty": "medium",
            "total_time": 14.234575986862183,
            "code_generation_time": 13.271997451782227,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 691,
            "total_output_tokens": 324,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque\n\ndef solve():\n    # Read input\n    nums = list(map(int, sys.stdin.readline().split()))\n    k = int(sys.stdin.readline().strip())\n    \n    n = len(nums)\n    \n    # We'll use a difference array approach\n    # diff[i] represents the difference in operations starting at position i\n    diff = [0] * (n + 1)\n    \n    # operations_count keeps track of how many operations are currently active\n    operations_count = 0\n    \n    for i in range(n):\n        # Apply all operations that are currently active\n        operations_count += diff[i]\n        \n        # Current value after applying all operations so far\n        current_val = nums[i] - operations_count\n        \n        # If current value is negative, it's impossible\n        if current_val < 0:\n            print(\"false\")\n            return\n            \n        # If current value is positive, we need to start 'current_val' operations\n        if current_val > 0:\n            # We can only start operations if there are at least k elements remaining\n            if i + k > n:\n                print(\"false\")\n                return\n                \n            # Start 'current_val' operations at position i\n            diff[i] += current_val\n            diff[i + k] -= current_val\n            operations_count += current_val\n    \n    # Check if all operations can be completed\n    # This is guaranteed by the logic above, but let's make sure\n    print(\"true\")\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3263",
            "difficulty": "easy",
            "total_time": 19.500691890716553,
            "code_generation_time": 18.79357647895813,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 827,
            "total_output_tokens": 292,
            "error": null,
            "traceback": null,
            "code": "def solve():\n    import sys\n    nums = list(map(int, sys.stdin.readline().split()))\n    n = len(nums)\n    \n    # The first subarray will always start at index 0, so its cost is nums[0]\n    # We need to choose two more starting points for the next two subarrays\n    # These can be any indices from 1 to n-1 (since we need at least one element in each subarray)\n    \n    # To minimize the sum of costs, we want to minimize the sum of the first elements\n    # of the second and third subarrays.\n    # The first element of the second subarray is nums[i] for some i in [1, n-2]\n    # The first element of the third subarray is nums[j] for some j in [i+1, n-1]\n    \n    # So we want to minimize nums[0] + nums[i] + nums[j] where 1 <= i < j <= n-1\n    # Since nums[0] is fixed, we need to minimize nums[i] + nums[j]\n    \n    # This is equivalent to finding the two smallest elements in nums[1:]\n    \n    suffix = nums[1:]\n    suffix.sort()\n    return nums[0] + suffix[0] + suffix[1]\n\nif __name__ == \"__main__\":\n    print(solve())",
            "history_file": null
        },
        {
            "question_id": "abc339_d",
            "difficulty": "medium",
            "total_time": 23.95363211631775,
            "code_generation_time": 11.10198163986206,
            "passed_tests": 37,
            "total_tests": 52,
            "success_rate": 0.71,
            "total_input_tokens": 994,
            "total_output_tokens": 544,
            "error": null,
            "traceback": null,
            "code": "from collections import deque\nimport sys\n\ndef main():\n    N = int(sys.stdin.readline())\n    grid = [sys.stdin.readline().strip() for _ in range(N)]\n    \n    # Find initial positions of players\n    positions = []\n    for i in range(N):\n        for j in range(N):\n            if grid[i][j] == 'P':\n                positions.append((i, j))\n    \n    start1, start2 = positions\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # BFS\n    # State: (pos1_row, pos1_col, pos2_row, pos2_col)\n    queue = deque()\n    visited = set()\n    \n    queue.append((start1[0], start1[1], start2[0], start2[1], 0))\n    visited.add((start1[0], start1[1], start2[0], start2[1]))\n    \n    while queue:\n        r1, c1, r2, c2, moves = queue.popleft()\n        \n        # Check if both players are at the same position\n        if (r1, c1) == (r2, c2):\n            print(moves)\n            return\n        \n        # Try all 4 directions\n        for dr, dc in directions:\n            # Calculate new positions\n            nr1, nc1 = r1 + dr, c1 + dc\n            nr2, nc2 = r2 + dr, c2 + dc\n            \n            # Check if new positions are valid (within bounds and not obstacles)\n            # If not valid, player stays in place\n            if not (0 <= nr1 < N and 0 <= nc1 < N and grid[nr1][nc1] != '#'):\n                nr1, nc1 = r1, c1\n            if not (0 <= nr2 < N and 0 <= nc2 < N and grid[nr2][nc2] != '#'):\n                nr2, nc2 = r2, c2\n                \n            # Check if this state has been visited\n            state = (nr1, nc1, nr2, nc2)\n            if state not in visited:\n                visited.add(state)\n                queue.append((nr1, nc1, nr2, nc2, moves + 1))\n    \n    # If queue is empty and we haven't found a solution\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "3309",
            "difficulty": "easy",
            "total_time": 8.908290147781372,
            "code_generation_time": 8.142860412597656,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 883,
            "total_output_tokens": 224,
            "error": null,
            "traceback": null,
            "code": "def is_prefix_and_suffix(str1, str2):\n    \"\"\"Check if str1 is both a prefix and a suffix of str2.\"\"\"\n    if len(str1) > len(str2):\n        return False\n    return str2.startswith(str1) and str2.endswith(str1)\n\ndef count_prefix_and_suffix_pairs(words):\n    \"\"\"Count the number of index pairs (i, j) such that i < j and is_prefix_and_suffix(words[i], words[j]) is True.\"\"\"\n    count = 0\n    n = len(words)\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_prefix_and_suffix(words[i], words[j]):\n                count += 1\n    return count\n\ndef solve():\n    import sys\n    # Read input\n    line = sys.stdin.readline().strip()\n    # Parse the list of words\n    words = eval(line)\n    # Calculate and print the result\n    result = count_prefix_and_suffix_pairs(words)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2873",
            "difficulty": "medium",
            "total_time": 9.638675928115845,
            "code_generation_time": 8.289745807647705,
            "passed_tests": 94,
            "total_tests": 94,
            "success_rate": 1.0,
            "total_input_tokens": 614,
            "total_output_tokens": 313,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef sieve_of_eratosthenes(limit):\n    \"\"\"Generate a list of primes up to limit using Sieve of Eratosthenes.\"\"\"\n    is_prime = [True] * (limit + 1)\n    is_prime[0] = is_prime[1] = False  # 0 and 1 are not prime numbers\n    \n    for i in range(2, int(limit**0.5) + 1):\n        if is_prime[i]:\n            for j in range(i*i, limit + 1, i):\n                is_prime[j] = False\n                \n    return is_prime\n\ndef find_prime_pairs(n):\n    \"\"\"Find all prime pairs [x, y] such that x + y = n and x <= y.\"\"\"\n    if n < 4:  # Smallest sum of two primes is 2 + 2 = 4\n        return []\n    \n    # Generate all primes up to n\n    is_prime = sieve_of_eratosthenes(n)\n    \n    result = []\n    # Check all possible x values from 2 to n//2\n    for x in range(2, n//2 + 1):\n        if is_prime[x]:\n            y = n - x\n            if is_prime[y]:\n                result.append([x, y])\n    \n    return result\n\ndef solve():\n    n = int(input().strip())\n    pairs = find_prime_pairs(n)\n    print(pairs)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc322_a",
            "difficulty": "easy",
            "total_time": 7.751220226287842,
            "code_generation_time": 7.635931015014648,
            "passed_tests": 8,
            "total_tests": 8,
            "success_rate": 1.0,
            "total_input_tokens": 678,
            "total_output_tokens": 110,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(input())\n    S = input().strip()\n    \n    # Iterate through the string to find the first occurrence of \"ABC\"\n    for i in range(N - 2):\n        if S[i:i+3] == \"ABC\":\n            print(i + 1)  # 1-indexed position\n            return\n    \n    # If \"ABC\" is not found, print -1\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3203",
            "difficulty": "hard",
            "total_time": 68.11104702949524,
            "code_generation_time": 57.311028480529785,
            "passed_tests": 61,
            "total_tests": 79,
            "success_rate": 0.77,
            "total_input_tokens": 1329,
            "total_output_tokens": 2698,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import Counter\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    half = n // 2\n    queries_line = sys.stdin.readline().strip()\n    # Since we're reading from stdin, we need to parse the queries properly\n    # The input format for queries is like [[1,1,3,5],[0,2,5,5]]\n    # We can use eval for simplicity in this context\n    queries = eval(queries_line)\n    \n    # Precompute prefix sums for character counts in both halves\n    left_prefix = [Counter() for _ in range(half + 1)]\n    right_prefix = [Counter() for _ in range(half + 1)]\n    \n    for i in range(half):\n        left_prefix[i+1] = left_prefix[i].copy()\n        left_prefix[i+1][s[i]] += 1\n        \n    for i in range(half):\n        right_prefix[i+1] = right_prefix[i].copy()\n        right_prefix[i+1][s[n-1-i]] += 1\n    \n    def can_make_palindrome(a, b, c, d):\n        # Convert c, d to indices in the right half (0-based from start of right half)\n        c_right = c - half\n        d_right = d - half\n        \n        # Check if we can make the string a palindrome\n        # We divide the string into segments and check character matching\n        \n        # There are multiple cases based on the overlap of [a,b] and [c_right, d_right] when mapped\n        \n        # First, check the parts that cannot be rearranged\n        # Left part before a\n        for i in range(a):\n            if s[i] != s[n-1-i]:\n                return False\n                \n        # Right part after b\n        for i in range(b+1, half):\n            if s[i] != s[n-1-i]:\n                return False\n                \n        # Left part after d_right\n        for i in range(d+1, n):\n            if s[i] != s[n-1-i]:\n                return False\n                \n        # Right part before c\n        for i in range(half, c):\n            if s[i] != s[n-1-i]:\n                return False\n                \n        # Now check the middle parts that can be rearranged\n        # We need to ensure that the characters in the rearrangeable parts can match\n        \n        # Get character counts in rearrangeable parts\n        left_rearrange = Counter()\n        right_rearrange = Counter()\n        \n        # Add characters from s[a..b]\n        for i in range(a, b+1):\n            left_rearrange[s[i]] += 1\n            \n        # Add characters from s[c..d] \n        for i in range(c, d+1):\n            right_rearrange[s[i]] += 1\n            \n        # Get characters that must match but are not rearrangeable\n        # Left fixed part that corresponds to right rearrangeable part\n        left_fixed = Counter()\n        for i in range(max(a, half - 1 - d), min(b + 1, half - c_right)):\n            left_fixed[s[i]] += 1\n            \n        # Right fixed part that corresponds to left rearrangeable part  \n        right_fixed = Counter()\n        for i in range(max(c, n - 1 - b), min(d + 1, n - a)):\n            right_fixed[s[i]] += 1\n            \n        # This approach is getting complex. Let's use a cleaner method.\n        \n        # Better approach:\n        # Split the string into regions and check character balance\n        \n        # Let's redefine: \n        # Left half indices [0, half-1]\n        # Right half indices [half, n-1] which correspond to [half-1, 0] in reverse\n        \n        # For the left half [0, half-1], we can rearrange [a,b]\n        # For the right half [half, n-1], we can rearrange [c,d]\n        \n        # When checking for palindrome:\n        # s[i] should match s[n-1-i] for all i in [0, half-1]\n        \n        # Let's think of it this way:\n        # 1. Fixed regions (not rearrangeable) must already match\n        # 2. Rearrangeable regions must have enough characters to match each other\n        \n        # Case analysis based on positions:\n        \n        # Normalize c,d to right half indices\n        c_norm = c - half\n        d_norm = d - half\n        \n        # Ensure a,b and c_norm,d_norm are in correct order\n        if a > c_norm:\n            a, c_norm = c_norm, a\n            b, d_norm = d_norm, b\n            \n        # Now a <= c_norm\n        # Check different cases:\n        \n        # Case 1: No overlap and gap between [a,b] and [c_norm, d_norm]\n        if b < c_norm - 1:\n            # Check fixed middle part\n            for i in range(b+1, c_norm):\n                if s[i] != s[n-1-i]:\n                    return False\n                    \n            # Check if rearrangeable parts can match their corresponding fixed parts\n            # Left rearrangeable [a,b] should match s[n-1-b .. n-1-a]\n            left_chars = Counter(s[a:b+1])\n            required_left = Counter(s[n-1-b: n-a][::-1]) # reverse because of palindrome property\n            \n            # Right rearrangeable [c,d] should match s[2*half-1-d .. 2*half-1-c] \n            right_chars = Counter(s[c:d+1])\n            required_right = Counter(s[2*half-1-d : 2*half-c][::-1])\n            \n            if left_chars != required_left or right_chars != required_right:\n                return False\n                \n        # Case 2: Overlap or adjacent\n        elif b >= c_norm:\n            # Merged interval [a, max(b,d_norm)]\n            merged_right_end = half - 1 - max(a, c_norm)\n            merged_left_start = half - 1 - min(b, d_norm)\n            \n            # The rearrangeable parts together should be able to form the required characters\n            left_rearrange_chars = Counter(s[a : min(b, d_norm - 1) + 1] if b >= c_norm else \"\")\n            if b > d_norm:\n                left_rearrange_chars += Counter(s[max(a, d_norm + 1) : b + 1])\n                \n            right_rearrange_chars = Counter(s[c : d + 1])\n            \n            total_available = left_rearrange_chars + right_rearrange_chars\n            total_required = Counter(s[merged_left_start : merged_right_end + 1])\n            \n            if total_available != total_required:\n                return False\n                \n        # Case 3: [c_norm, d_norm] is before [a,b] - already handled by swapping at start\n        \n        return True\n    \n    # Simpler and more robust approach:\n    # For each query, we check if characters can be rearranged to form palindrome\n    \n    result = []\n    for a, b, c, d in queries:\n        # Count characters in left rearrangeable part s[a:b+1]\n        left_chars = Counter()\n        for i in range(a, b+1):\n            left_chars[s[i]] += 1\n            \n        # Count characters in right rearrangeable part s[c:d+1]\n        right_chars = Counter()\n        for i in range(c, d+1):\n            right_chars[s[i]] += 1\n            \n        # For positions 0 to a-1: must already match their counterparts\n        match = True\n        for i in range(min(a, c-half)):\n            if s[i] != s[n-1-i]:\n                match = False\n                break\n                \n        if not match:\n            result.append(False)\n            continue\n            \n        # For positions b+1 to half-1 and also check the corresponding right part\n        # This is getting complex. Let's implement the official solution approach.\n        \n        # Official approach:\n        # 1. Divide string into segments\n        # 2. For fixed segments, check if they already satisfy palindrome property\n        # 3. For rearrangeable segments, check if characters can be matched\n        \n        # Let's simplify:\n        # Split into up to 4 segments in left half:\n        # [0, min(a,c-half)-1] - must match (FIXED)\n        # [min(a,c-half), max(a,c-half)-1] - rearrangeable\n        # [max(a,c-half), min(b,d-half)] - rearrangeable \n        # [min(b,d-half)+1, max(b,d-half)] - rearrangeable\n        # [max(b,d-half)+1, half-1] - must match (FIXED)\n        \n        # Actually, let's implement a cleaner version:\n        \n        def check_query(a, b, c, d):\n            # Convert right indices to left half equivalents\n            c_left = n - 1 - d  # left equivalent of c\n            d_left = n - 1 - c  # left equivalent of d\n            \n            # We can rearrange s[a..b] and s[c..d]\n            # Which means we can rearrange characters at positions a..b and (n-1-d)..(n-1-c) in the left half sense\n            \n            # Get all characters we can rearrange\n            available = Counter()\n            required = Counter()\n            \n            left_l, left_r = a, b\n            right_l, right_r = c_left, d_left\n            \n            # Add characters we can change\n            for i in range(left_l, left_r + 1):\n                available[s[i]] += 1\n            for i in range(right_l, right_r + 1):\n                available[s[i]] += 1\n                \n            # Add characters that are required at these positions for palindrome\n            for i in range(left_l, left_r + 1):\n                required[s[n-1-i]] += 1\n            for i in range(right_l, right_r + 1):\n                required[s[n-1-i]] += 1\n                \n            # Check fixed parts\n            # Before min(left_l, right_l)\n            for i in range(min(left_l, right_l)):\n                if s[i] != s[n-1-i]:\n                    return False\n                    \n            # Between the rearrangeable regions\n            # This is complex, let's check if available chars can satisfy required chars\n            if available != required:\n                return False\n                \n            # After max(left_r, right_r)\n            for i in range(max(left_r, right_r) + 1, half):\n                if s[i] != s[n-1-i]:\n                    return False\n                    \n            return True\n        \n        # Even simpler correct approach:\n        result.append(check_query_simple(s, a, b, c, d, n))\n        \n    print(str(result).lower())\n\ndef check_query_simple(s, a, b, c, d, n):\n    half = n // 2\n    \n    # Characters we can rearrange in left half [a,b] \n    left_avail = Counter(s[a:b+1])\n    # Characters we can rearrange in right half [c,d]\n    right_avail = Counter(s[c:d+1])\n    \n    # For each position in left half [0, half-1], check if we can satisfy palindrome requirement\n    for i in range(half):\n        mirror = n - 1 - i\n        if a <= i <= b and c <= mirror <= d:\n            # Both positions are rearrangeable\n            if s[i] != s[mirror]:\n                # We need to be able to swap characters\n                # Check if we have required characters available\n                # This is still complex, let's think differently\n                pass\n        elif a <= i <= b:\n            # Only left is rearrangeable\n            if s[i] != s[mirror]:\n                # We must have s[mirror] in left_avail to swap\n                if left_avail[s[mirror]] > 0:\n                    left_avail[s[mirror]] -= 1\n                else:\n                    return False\n        elif c <= mirror <= d:\n            # Only right is rearrangeable  \n            if s[i] != s[mirror]:\n                # We must have s[i] in right_avail to swap\n                if right_avail[s[i]] > 0:\n                    right_avail[s[i]] -= 1\n                else:\n                    return False\n        else:\n            # Neither is rearrangeable\n            if s[i] != s[mirror]:\n                return False\n                \n    return True\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3297",
            "difficulty": "medium",
            "total_time": 22.162386417388916,
            "code_generation_time": 21.336671113967896,
            "passed_tests": 33,
            "total_tests": 100,
            "success_rate": 0.33,
            "total_input_tokens": 856,
            "total_output_tokens": 225,
            "error": null,
            "traceback": null,
            "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    word = data[0]\n    k = int(data[1])\n    \n    n = len(word)\n    # Try each possible time t (number of operations)\n    for t in range(1, n // k + 2):\n        # After t operations, the first t*k characters are removed and replaced\n        # For the word to revert to initial state, the remaining suffix must match the prefix\n        removed_chars = t * k\n        if removed_chars >= n:\n            # All characters have been cycled out and back in\n            print(t)\n            return\n        # Check if the suffix of current length matches the prefix of the same length\n        # The part that remains in place is word[removed_chars:]\n        # This must match the beginning of the original word of the same length\n        if word[removed_chars:] == word[:n - removed_chars]:\n            print(t)\n            return\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3212",
            "difficulty": "hard",
            "total_time": 6.318333625793457,
            "code_generation_time": 5.27425479888916,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 719,
            "total_output_tokens": 254,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    MOD = 10**9 + 7\n    \n    # Read input\n    nums = list(map(int, sys.stdin.readline().split()))\n    n = len(nums)\n    \n    # Find the last occurrence of each element\n    last_occurrence = {}\n    for i in range(n):\n        last_occurrence[nums[i]] = i\n    \n    # Find the number of independent segments\n    segments = 0\n    i = 0\n    while i < n:\n        # The end of the current segment is at least the last occurrence of nums[i]\n        segment_end = last_occurrence[nums[i]]\n        \n        # Expand the segment end as needed\n        j = i\n        while j <= segment_end:\n            segment_end = max(segment_end, last_occurrence[nums[j]])\n            j += 1\n        \n        # We've found one independent segment\n        segments += 1\n        i = segment_end + 1\n    \n    # The number of good partitions is 2^(segments-1)\n    result = pow(2, segments - 1, MOD)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc315_e",
            "difficulty": "hard",
            "total_time": 29.498682737350464,
            "code_generation_time": 27.13100790977478,
            "passed_tests": 7,
            "total_tests": 34,
            "success_rate": 0.21,
            "total_input_tokens": 1088,
            "total_output_tokens": 416,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque, defaultdict\n\ndef solve():\n    N = int(sys.stdin.readline())\n    prerequisites = [[] for _ in range(N + 1)]\n    in_degree = [0] * (N + 1)\n    \n    for i in range(1, N + 1):\n        line = list(map(int, sys.stdin.readline().split()))\n        C = line[0]\n        if C > 0:\n            prerequisites[i] = line[1:]\n            for prereq in prerequisites[i]:\n                in_degree[prereq] += 1\n    \n    # Find all books needed to read book 1 using BFS/Topological sort\n    needed = set()\n    queue = deque([1])\n    needed.add(1)\n    \n    while queue:\n        book = queue.popleft()\n        for prereq in prerequisites[book]:\n            if prereq not in needed:\n                needed.add(prereq)\n                queue.append(prereq)\n    \n    # Remove book 1 from the set as we don't need to output it\n    needed.remove(1)\n    \n    # Topological sort on the needed books\n    in_degree_needed = defaultdict(int)\n    adj = defaultdict(list)\n    \n    for book in needed:\n        for prereq in prerequisites[book]:\n            if prereq in needed:\n                in_degree_needed[book] += 1\n                adj[prereq].append(book)\n    \n    # Find books with in-degree 0\n    queue = deque()\n    for book in needed:\n        if in_degree_needed[book] == 0:\n            queue.append(book)\n    \n    result = []\n    while queue:\n        book = queue.popleft()\n        result.append(book)\n        for next_book in adj[book]:\n            in_degree_needed[next_book] -= 1\n            if in_degree_needed[next_book] == 0:\n                queue.append(next_book)\n    \n    print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc323_c",
            "difficulty": "medium",
            "total_time": 13.609072208404541,
            "code_generation_time": 13.393467903137207,
            "passed_tests": 11,
            "total_tests": 11,
            "success_rate": 1.0,
            "total_input_tokens": 1292,
            "total_output_tokens": 364,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport heapq\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    # Calculate current scores for all players\n    current_scores = []\n    unsolved_problems = []\n    \n    for i in range(N):\n        S = sys.stdin.readline().strip()\n        score = i + 1  # bonus points\n        unsolved = []\n        \n        for j in range(M):\n            if S[j] == 'o':\n                score += A[j]\n            else:\n                unsolved.append(A[j])\n        \n        # Sort unsolved problems in descending order (greedy approach)\n        unsolved.sort(reverse=True)\n        current_scores.append(score)\n        unsolved_problems.append(unsolved)\n    \n    # For each player, find minimum number of problems to solve to exceed all others\n    results = []\n    \n    for i in range(N):\n        max_other_score = max(current_scores[j] for j in range(N) if j != i)\n        \n        if current_scores[i] > max_other_score:\n            results.append(0)\n            continue\n        \n        # We need to exceed max_other_score\n        needed = max_other_score - current_scores[i] + 1\n        count = 0\n        current_deficit = needed\n        unsolved = unsolved_problems[i]\n        \n        # Greedily take highest value problems until we cover the deficit\n        for score in unsolved:\n            current_deficit -= score\n            count += 1\n            if current_deficit <= 0:\n                break\n        \n        results.append(count)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3172",
            "difficulty": "easy",
            "total_time": 5.867522716522217,
            "code_generation_time": 4.922364950180054,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 866,
            "total_output_tokens": 111,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    n = int(input())\n    m = int(input())\n    \n    num1 = 0  # Sum of numbers not divisible by m\n    num2 = 0  # Sum of numbers divisible by m\n    \n    for i in range(1, n + 1):\n        if i % m == 0:\n            num2 += i\n        else:\n            num1 += i\n    \n    print(num1 - num2)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc305_b",
            "difficulty": "easy",
            "total_time": 6.1549599170684814,
            "code_generation_time": 5.965359926223755,
            "passed_tests": 11,
            "total_tests": 11,
            "success_rate": 1.0,
            "total_input_tokens": 679,
            "total_output_tokens": 331,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    # Read input\n    line = sys.stdin.readline().strip()\n    p, q = line.split()\n    \n    # Define the distances between adjacent points\n    distances = {\n        ('A', 'B'): 3,\n        ('B', 'C'): 1,\n        ('C', 'D'): 4,\n        ('D', 'E'): 1,\n        ('E', 'F'): 5,\n        ('F', 'G'): 9\n    }\n    \n    # Create a list of points in order\n    points = ['A', 'B', 'C', 'D', 'E', 'F', 'G']\n    \n    # Find the indices of p and q\n    idx_p = points.index(p)\n    idx_q = points.index(q)\n    \n    # Ensure idx_p < idx_q for easier calculation\n    if idx_p > idx_q:\n        idx_p, idx_q = idx_q, idx_p\n        p, q = q, p\n    \n    # Calculate the distance by summing up the distances between consecutive points\n    total_distance = 0\n    for i in range(idx_p, idx_q):\n        point1 = points[i]\n        point2 = points[i+1]\n        # Check both possible orderings in the distances dictionary\n        if (point1, point2) in distances:\n            total_distance += distances[(point1, point2)]\n        else:\n            total_distance += distances[(point2, point1)]\n    \n    print(total_distance)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc340_a",
            "difficulty": "easy",
            "total_time": 3.7066078186035156,
            "code_generation_time": 3.5643560886383057,
            "passed_tests": 10,
            "total_tests": 10,
            "success_rate": 1.0,
            "total_input_tokens": 623,
            "total_output_tokens": 80,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    line = sys.stdin.readline().strip()\n    A, B, D = map(int, line.split())\n    \n    sequence = []\n    current = A\n    while current <= B:\n        sequence.append(current)\n        current += D\n    \n    print(' '.join(map(str, sequence)))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc314_c",
            "difficulty": "medium",
            "total_time": 5.44364595413208,
            "code_generation_time": 4.623484373092651,
            "passed_tests": 27,
            "total_tests": 27,
            "success_rate": 1.0,
            "total_input_tokens": 1012,
            "total_output_tokens": 254,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    S = list(data[2])\n    C = list(map(int, data[3:3+N]))\n    \n    # Create a mapping from color to list of indices (0-based)\n    color_indices = defaultdict(list)\n    for i in range(N):\n        color_indices[C[i]].append(i)\n    \n    # For each color, perform a right circular shift\n    for color in range(1, M+1):\n        indices = color_indices[color]\n        if not indices:\n            continue\n        # Get the characters at these indices\n        chars = [S[i] for i in indices]\n        # Right circular shift by 1: last char moves to front\n        if len(chars) > 1:\n            chars = [chars[-1]] + chars[:-1]\n        # Put the shifted characters back\n        for i, char in enumerate(chars):\n            S[indices[i]] = char\n    \n    print(''.join(S))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc336_b",
            "difficulty": "easy",
            "total_time": 6.682826995849609,
            "code_generation_time": 6.477524757385254,
            "passed_tests": 17,
            "total_tests": 17,
            "success_rate": 1.0,
            "total_input_tokens": 634,
            "total_output_tokens": 76,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef ctz(n):\n    count = 0\n    while n > 0 and n % 2 == 0:\n        count += 1\n        n //= 2\n    return count\n\ndef solve():\n    n = int(input())\n    print(ctz(n))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2856",
            "difficulty": "medium",
            "total_time": 16.74114727973938,
            "code_generation_time": 15.707331418991089,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 615,
            "total_output_tokens": 178,
            "error": null,
            "traceback": null,
            "code": "def countCompleteSubarrays(nums):\n    n = len(nums)\n    distinct_count = len(set(nums))\n    \n    count = 0\n    for i in range(n):\n        seen = set()\n        for j in range(i, n):\n            seen.add(nums[j])\n            if len(seen) == distinct_count:\n                # All subsequent subarrays starting at i and ending at j or beyond are complete\n                count += n - j\n                break\n    return count\n\n# Read input\nimport sys\ninput_line = sys.stdin.readline().strip()\n# Assuming input is given as a list of integers in the format \"[1, 3, 1, 2, 2]\"\nnums = list(map(int, input_line.strip('[]').split(',')))\n\n# Solve and print result\nresult = countCompleteSubarrays(nums)\nprint(result)",
            "history_file": null
        },
        {
            "question_id": "abc310_f",
            "difficulty": "hard",
            "total_time": 111.46760845184326,
            "code_generation_time": 110.99278974533081,
            "passed_tests": 24,
            "total_tests": 38,
            "success_rate": 0.63,
            "total_input_tokens": 1014,
            "total_output_tokens": 3849,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport math\n\ndef modinv(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef main():\n    MOD = 998244353\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    # dp[i][s] = number of ways to achieve sum s using first i dice\n    # But we only care about sums up to 10\n    # Actually, we need to count for each subset of dice, so let's think differently.\n    \n    # We will compute the probability that NO subset sums to 10\n    # Then answer = 1 - that_prob\n    \n    # However, inclusion-exclusion or direct DP on subsets is too expensive.\n    \n    # Let's use the fact that we only care about sum=10.\n    # We can do DP where dp[s] = probability that sum s is achievable\n    # But we need to be careful about which dice are included.\n    \n    # A better approach:\n    # For each die, it can be included or not.\n    # We want the probability that there EXISTS a subset of dice whose sum is 10.\n    \n    # We'll use the inclusion-exclusion principle or DP on sums.\n    # Let's use DP: dp[s] = probability that sum s is achievable using some subset of processed dice.\n    \n    # Initially, sum 0 is achievable with probability 1 (empty set)\n    dp = [0] * 11\n    dp[0] = 1\n    \n    # For each die\n    for i in range(N):\n        a = A[i]\n        # Probability that this die shows value v is 1/a for v in 1..a\n        # We need to update dp based on including or not including this die\n        \n        # But this is tricky. Let's think of it this way:\n        # For each previous state dp[s], we can either include this die or not.\n        # If we don't include it, dp[s] remains.\n        # If we include it, for each value v from 1 to min(a, 10), \n        # we can reach sum s+v with probability (1/a) * dp[s] (if s+v <= 10)\n        \n        # But we also have the choice of not including the die.\n        # This is getting complex. Let's try a different approach.\n        \n        # Let's compute the probability that it's possible to select a subset that sums to 10.\n        # We can use bitDP or generate all possible sums.\n        # Since target is only 10, we can track all probabilities of achieving each sum.\n        \n        # At any point, for each sum s, we track the probability that s is achievable.\n        # When we get a new die with values 1..a:\n        # For each existing sum s:\n        #   For each value v from 1 to min(a, 10-s):\n        #     We can achieve sum s+v with probability dp[s] * (1/a)\n        # But we also have the option of not using this die at all.\n        \n        # Actually, let's think of it as: for each die, we decide whether to include it or not.\n        # But that's 2^N.\n        \n        # Better approach:\n        # dp[s] = probability that sum s is achievable by selecting a subset of dice processed so far\n        # For a new die with values 1..a:\n        # We can either include it or not.\n        # If we don't include it, probabilities remain the same.\n        # If we include it, for each value v (1 to min(a,10)), \n        # and for each existing sum s, we get to sum s+v with prob dp[s] * (1/a)\n        # But we can't just add them because of overlap.\n        \n        # Let's do this correctly:\n        # For each die, we compute new probabilities considering all ways to use it.\n        # But we must be careful not to double count.\n        \n        # Simpler approach:\n        # At each step, we have current dp.\n        # For the new die, we compute a new_dp where:\n        # new_dp[t] = probability that sum t is achievable after considering this die\n        # This die can contribute to achieving sum t in two ways:\n        # 1. We don't use this die: probability that t was already achievable\n        # 2. We use this die: sum of probabilities that t-v was achievable and die shows v\n        \n        # But this is still not right because \"not using\" and \"using\" are not disjoint events.\n        \n        # Correct approach:\n        # The process is: we have N dice. We throw all of them.\n        # Then we check if there exists a subset of the thrown results that sum to 10.\n        # So for each die i, it shows a value v_i in [1, A_i] with prob 1/A_i.\n        # We want the probability over all possible outcomes that there exists a subset S of dice such that sum_{i in S} v_i = 10.\n        \n        # We can compute this by DP on sums.\n        # But we need to be very careful about the probability space.\n        \n        # Let's define dp[s] = probability that sum s is achievable by selecting a subset of the first i dice.\n        # Initially dp[0] = 1, dp[s] = 0 for s > 0.\n        \n        # For die i with values 1..a:\n        # For each possible sum s (from 10 down to 0):\n        #   The new probability that sum s is achievable is:\n        #   Pr[achievable without using die i] + Pr[achievable by using die i] - Pr[both]\n        #   = dp[s] + (sum over v=1 to min(a,s) of dp[s-v] * (1/a)) - dp[s] * (sum over v=1 to min(a,s) of (1/a))\n        #   = dp[s] * (1 - (min(a,s)/a)) + (1/a) * (sum over v=1 to min(a,s) of dp[s-v])\n        #   = dp[s] * (max(0, a-min(a,s))/a) + (1/a) * (sum over v=1 to min(a,s) of dp[s-v])\n        #   = dp[s] * (max(0, a-min(a,s))/a) + (1/a) * sum_dp\n        \n        # Actually, let's think even more carefully.\n        # The event \"sum s is achievable\" means \"there exists a subset of dice that sum to s\".\n        # When we add a new die, the new event \"sum s is achievable\" is the union of:\n        # - \"sum s was achievable before\" \n        # - \"sum s-v was achievable before\" for some v shown by the new die\n        \n        # Pr[new event] = Pr[old] + Pr[new way] - Pr[both]\n        # But computing Pr[both] is complex.\n        \n        # Simpler and correct approach:\n        # We compute for all possible outcomes of dice throws, what fraction satisfy the condition.\n        # But that's too many outcomes.\n        \n        # Let's go back to DP.\n        # State: for sums 0 to 10, track the probability that this sum is achievable.\n        # Transition: when we get die with values 1..a, for each previous sum s,\n        # for each value v=1..min(a, 10-s), we can form sum s+v.\n        # But we have to be careful about probabilities.\n        \n        # Key insight: \n        # Pr[sum t is achievable after processing die i] = \n        # Pr[sum t was achievable] + Pr[sum t becomes achievable by using die i] - Pr[both]\n        \n        # But let's try a cleaner approach:\n        # We process dice one by one.\n        # At each step, we maintain dp where dp[s] is the probability that sum s is achievable.\n        # For a new die showing values 1..a each with prob 1/a:\n        # New probability for sum t:\n        # We can achieve t in two (possibly overlapping) ways:\n        # 1. It was already achievable (prob dp[s])\n        # 2. We use the new die: there exists v in 1..min(a,t) such that t-v was achievable\n        #    The probability of this is sum_{v=1}^{min(a,t)} dp[t-v] * (1/a)\n        \n        # So: new_dp[t] = dp[t] + (1/a) * sum_{v=1}^{min(a,t)} dp[t-v] - Pr[overlap]\n        # The overlap is when t was already achievable AND we can also make it using the new die.\n        # This is dp[t] * (1/a) * number of ways the die can contribute to making t.\n        # Number of ways = number of v in 1..min(a,t) such that (t-v) was achievable.\n        # This is sum_{v=1}^{min(a,t)} dp[t-v] if we interpret dp as counts, but it's probabilities.\n        \n        # This is getting messy. Let's look for a cleaner DP.\n        \n        # Final clean approach:\n        # dp[s] = probability that sum s can be achieved by selecting a subset of processed dice\n        # For a new die with values 1..a:\n        # Let's compute for each sum t, what is the probability that t is achievable now.\n        # This happens if:\n        # - t was already achievable (prob dp[t]) \n        # - or the new die helps make t achievable\n        # The new die helps if there exists a value v it can show such that (t-v) was achievable.\n        # The probability of this is: sum_{v=1}^{min(a,t)} (1/a) * dp[t-v] \n        # But we have to subtract the overlap.\n        # Overlap occurs when t was achievable AND the die can also be used to make t.\n        # This is: dp[t] * (1/a) * |{v in 1..min(a,t) : (t-v) was achievable}|\n        # The size of that set is sum_{v=1}^{min(a,t)} dp[t-v] if dp tracks 1s and 0s, but it tracks probabilities.\n        \n        # Wait, I think I'm overcomplicating this.\n        # Let's think of dp[s] as the probability that sum s is in the set of achievable sums.\n        # When we add a die:\n        # The set of achievable sums increases.\n        # new_set = old_set union {s + v | s in old_set, v in 1..a}\n        # Pr[s in new_set] = Pr[s in old_set] + Pr[s not in old_set and s-v in old_set for some v] \n        #                  = Pr[s in old_set] + Pr[s not in old_set] * Pr[exists v: s-v in old_set]\n        # But this is also not straightforward.\n        \n        # Let me restart with the most standard approach for this type of problem.\n        \n        # We want Pr[exists subset S of dice such that sum_{i in S} v_i = 10]\n        # where v_i is the value shown by die i.\n        \n        # We can compute this by inclusion-exclusion or DP.\n        # Standard DP approach for subset sum with probabilities:\n        # dp[i][s] = probability that using first i dice, we can achieve sum s\n        # But this is \"can achieve\" which is different from standard subset sum.\n        \n        # Actually, \"can achieve\" means there exists a subset of the first i dice that sum to s.\n        # So it's like subset selection.\n        \n        # dp[s] = probability that sum s is achievable\n        # Initially dp[0] = 1, others 0.\n        # For each die with values 1..a:\n        #   For s from 10 down to 0:\n        #     For v from 1 to min(a, s):\n        #       dp[s] = dp[s] + dp[s-v] * (1/a)\n        # But this counts multiple times if there are multiple ways.\n        \n        # No, this is wrong. This is computing the expected number of ways, not probability of achievability.\n        \n        # Correct DP:\n        # dp[s] = probability that sum s is achievable (i.e., there exists a subset that sums to s)\n        # For new die with values 1..a:\n        # Pr[sum s is achievable now] = \n        # Pr[sum s was achievable] OR Pr[exists v such that (s-v) was achievable and die shows v]\n        # = Pr[old] + Pr[new way] - Pr[both]\n        # = dp[s] + (sum_{v=1}^{min(a,s)} dp[s-v] * (1/a)) - dp[s] * (sum_{v=1}^{min(a,s)} (1/a))\n        # = dp[s] * (1 - min(a,s)/a) + (1/a) * sum_{v=1}^{min(a,s)} dp[s-v]\n        \n        new_dp = [0] * 11\n        for s in range(11):\n            prob_not_use = 1  # probability we don't use this die to make sum s\n            prob_use = 0      # probability we use this die to make sum s\n            \n            min_a_s = min(a, s)\n            prob_use_die = min_a_s / a  # This is not integer, work in modular arithmetic\n            \n            # prob_use = sum_{v=1}^{min(a,s)} dp[s-v] * (1/a)\n            sum_dp = 0\n            for v in range(1, min_a_s + 1):\n                sum_dp = (sum_dp + dp[s - v]) % MOD\n                \n            prob_use = (sum_dp * modinv(a, MOD)) % MOD\n            \n            # prob_not_use for sum s = dp[s] * (probability that die doesn't help make s in addition to what's already there)\n            # Actually, prob_not_use is just dp[s] if we don't use the die\n            # prob_use is if we do use the die\n            # But they're not disjoint events.\n            \n            # Let's just use the formula:\n            # new_dp[s] = dp[s] + prob_use - dp[s] * prob_use\n            #           = dp[s] * (1 - prob_use) + prob_use\n            # No, that's not right either.\n            \n            # Correct formula from inclusion-exclusion:\n            # A = event \"sum s was achievable\"\n            # B = event \"sum s is achievable using the new die\"\n            # Pr[A or B] = Pr[A] + Pr[B] - Pr[A and B]\n            \n            # Pr[A] = dp[s]\n            # Pr[B] = sum_{v=1}^{min(a,s)} Pr[(s-v) was achievable] * Pr[die shows v] \n            #       = (1/a) * sum_{v=1}^{min(a,s)} dp[s-v]\n            # Pr[A and B] = Pr[A] * Pr[B | A]\n            # This is complex.\n            \n            # Simpler view:\n            # After processing die i, \n            # Pr[sum s is achievable] = Pr[there exists subset of dice {1..i} that sum to s]\n            # This can happen in two ways:\n            # 1. Subset doesn't include die i: Pr[sum s achievable with dice {1..i-1}] = old_dp[s]\n            # 2. Subset includes die i: Pr[exists subset of {1..i-1} that sums to s-v] * Pr[die i shows v] for some v\n            #    = sum_{v=1}^{min(a,s)} old_dp[s-v] * (1/a)\n            \n            # But these two events are not disjoint. Their intersection is when \n            # sum s is achievable both with and without die i.\n            \n            # Pr[intersection] = Pr[sum s achievable without i] * Pr[sum s achievable with i | sum s achievable without i]\n            #                  = old_dp[s] * Pr[exists v such that (s-v) achievable without i and die i shows v]\n            #                  = old_dp[s] * sum_{v=1}^{min(a,s)} old_dp[s-v] * (1/a)\n            \n            # So:\n            # new_dp[s] = old_dp[s] + sum_{v=1}^{min(a,s)} old_dp[s-v] * (1/a) \n            #           - old_dp[s] * sum_{v=1}^{min(a,s)} old_dp[s-v] * (1/a)\n            #           = old_dp[s] * (1 - (1/a) * sum_{v=1}^{min(a,s)} old_dp[s-v]) \n            #           + (1/a) * sum_{v=1}^{min(a,s)} old_dp[s-v]\n            \n            sum_prev = 0\n            for v in range(1, min(a, s) + 1):\n                sum_prev = (sum_prev + dp[s - v]) % MOD\n                \n            inv_a = modinv(a, MOD)\n            prob_sum = (sum_prev * inv_a) % MOD\n            \n            new_dp[s] = (dp[s] * (1 - prob_sum) + prob_sum) % MOD\n            if new_dp[s] < 0:\n                new_dp[s] += MOD\n                \n        dp = new_dp\n    \n    print(dp[10])\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "abc333_e",
            "difficulty": "hard",
            "total_time": 87.41627788543701,
            "code_generation_time": 78.44178295135498,
            "passed_tests": 33,
            "total_tests": 44,
            "success_rate": 0.75,
            "total_input_tokens": 1695,
            "total_output_tokens": 2428,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    import sys\n    import threading\n\n    def main():\n        N = int(sys.stdin.readline())\n        events = []\n        potion_count = defaultdict(int)\n        \n        for i in range(N):\n            t, x = map(int, sys.stdin.readline().split())\n            events.append((t, x))\n            if t == 1:\n                potion_count[x] += 1\n        \n        # Check if it's possible at all\n        needed = defaultdict(int)\n        for t, x in events:\n            if t == 2:\n                needed[x] += 1\n        \n        for x in needed:\n            if needed[x] > potion_count[x]:\n                print(-1)\n                return\n        \n        # Now find the minimum maximum number of potions needed\n        # We'll do a binary search on the answer\n        def can_do_with_k(k):\n            # Try to simulate with at most k potions\n            current_potions = defaultdict(int)\n            total_potions = 0\n            \n            for t, x in events:\n                if t == 1:\n                    # We can choose to pick up or not\n                    # For now, let's not pick up, we'll decide later\n                    pass\n                else:\n                    # Must defeat monster of type x\n                    if current_potions[x] == 0:\n                        # Need to have picked up a potion of type x earlier\n                        # We'll check this in actual simulation\n                        pass\n            return True  # Placeholder\n        \n        # Let's think differently. \n        # We process events from left to right.\n        # When we see a monster, we need to have a potion for it.\n        # We can pick up potions earlier, but we want to minimize the max number we hold.\n        \n        # Key insight: when we encounter a monster of type x, \n        # we need to have picked up at least one potion of type x that was found earlier.\n        # We can choose which ones to pick up.\n        \n        # Strategy:\n        # 1. For each potion type, record when (which indices) they appear.\n        # 2. For each monster, record when it appears.\n        # 3. Process events from left to right.\n        # 4. When we see a potion, we can choose to pick it up or not.\n        # 5. When we see a monster, we must have a potion for it.\n        # 6. To minimize max potions held, we should try to delay picking up potions \n        #    until we need them, and discard potions as soon as we don't need them anymore.\n        \n        # Let's think of it this way:\n        # For each potion type x, count how many monsters of type x there are.\n        # The potions of type x must be picked in such a way that whenever a monster \n        # of type x is encountered, we have at least one potion of type x.\n        \n        # This is like a matching problem. For each type, we have a sequence of \n        # potion-find events and monster-encounter events.\n        # We need to match each monster with a potion that was found before it.\n        \n        # For each type x:\n        # - List of times potions are found (indices in events list)\n        # - List of times monsters appear (indices in events list)\n        # For each monster, we need to assign a potion that was found before it.\n        # To minimize max potions held at any time, we should try to assign potions \n        # as close to their monster as possible.\n        \n        # Let's collect for each type the list of potion indices and monster indices\n        potions_of_type = defaultdict(list)  # type -> list of indices where potion is found\n        monsters_of_type = defaultdict(list) # type -> list of indices where monster appears\n        potion_indices = []  # list of indices where t_i = 1, in order\n        \n        for i in range(N):\n            t, x = events[i]\n            if t == 1:\n                potions_of_type[x].append(i)\n                potion_indices.append(i)\n            else:\n                monsters_of_type[x].append(i)\n        \n        # For each type, check if number of potions >= number of monsters\n        for x in monsters_of_type:\n            if len(potions_of_type[x]) < len(monsters_of_type[x]):\n                print(-1)\n                return\n        \n        # Now, for each type, we need to assign potions to monsters\n        # A potion can only be used for a monster that comes after it\n        # We want to minimize the maximum number of potions held at any time\n        \n        # For each potion type, we solve the assignment problem:\n        # Given potions at positions p1 < p2 < ... < pk\n        # And monsters at positions m1 < m2 < ... < ml where k >= l\n        # We need to assign each monster to a potion that comes before it.\n        # To minimize max held, we should try to assign potion as close as possible to monster.\n        # But we also need to consider the order.\n        \n        # Let's think of it as a flow problem or greedy assignment.\n        # For each monster, we assign the latest potion that is before it and not yet assigned.\n        # This minimizes the time a potion is held.\n        \n        # Actually, let's think of it differently.\n        # We simulate the process from left to right.\n        # We keep track of how many potions of each type we currently hold.\n        # When we find a potion, we decide whether to pick it up.\n        # When we meet a monster, we must use a potion.\n        # We want to minimize the maximum number of potions held at any time.\n        \n        # We can binary search on the maximum number of potions.\n        # For a given max number, we check if it's possible.\n        \n        def is_possible(max_potions):\n            # Try to simulate with at most max_potions total potions held\n            current_potions = defaultdict(int)  # type -> count\n            total_held = 0\n            assigned = {}  # for each monster index, which potion index is assigned to it\n            \n            # For each type, we need to assign potions to monsters\n            # We do this optimally to minimize max held\n            for x in monsters_of_type:\n                potion_positions = potions_of_type[x]\n                monster_positions = monsters_of_type[x]\n                \n                # We need to assign each monster to a potion that comes before it\n                # To minimize max held, for each monster, we assign the latest available potion before it\n                # This is a greedy matching\n                # We can do this with a two-pointer approach or by iterating\n                \n                # Let's pair them optimally\n                # For monster at position m, assign the latest potion at position p < m that is not yet assigned\n                # To do this efficiently, for each potion, we can precompute which monster it can be assigned to\n                # Or we can iterate through monsters and for each, find the best potion\n                \n                # Let's iterate through monsters in order\n                potion_idx = 0\n                for monster_idx in monster_positions:\n                    # Find the latest potion before monster_idx\n                    # potion_positions is sorted\n                    # We want the largest potion_idx such that potion_positions[potion_idx] < monster_idx\n                    # and potion_positions[potion_idx] is not already assigned\n                    assigned_potion = -1\n                    while potion_idx < len(potion_positions) and potion_positions[potion_idx] < monster_idx:\n                        if potion_positions[potion_idx] not in assigned:\n                            assigned_potion = potion_positions[potion_idx]\n                        potion_idx += 1\n                    \n                    if assigned_potion == -1:\n                        # Need to look backwards\n                        found = False\n                        for j in range(len(potion_positions)-1, -1, -1):\n                            p_idx = potion_positions[j]\n                            if p_idx < monster_idx and p_idx not in assigned:\n                                assigned_potion = p_idx\n                                found = True\n                                break\n                        if not found:\n                            return False  # Can't assign\n                    \n                    assigned[assigned_potion] = monster_idx\n            \n            # Now simulate to check if max_potions is enough\n            current_potions = defaultdict(int)\n            total_held = 0\n            max_held = 0\n            \n            for i in range(N):\n                t, x = events[i]\n                if t == 1:\n                    # Found a potion\n                    if i in assigned:\n                        # This potion is assigned to defeat a monster\n                        current_potions[x] += 1\n                        total_held += 1\n                        max_held = max(max_held, total_held)\n                        if total_held > max_potions:\n                            return False\n                else:\n                    # Encounter monster\n                    if current_potions[x] <= 0:\n                        return False  # Impossible\n                    current_potions[x] -= 1\n                    total_held -= 1\n            \n            return max_held <= max_potions\n        \n        # Binary search on the answer\n        left, right = 0, N\n        answer = -1\n        while left <= right:\n            mid = (left + right) // 2\n            if is_possible(mid):\n                answer = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        if answer == -1:\n            print(-1)\n            return\n        \n        # Now we need to reconstruct the solution\n        # We run the simulation with answer as the max\n        max_potions = answer\n        current_potions = defaultdict(int)\n        total_held = 0\n        pick_up = [0] * len(potion_indices)  # for each potion event, whether to pick up\n        assigned = {}\n        \n        # Re-do the assignment\n        for x in monsters_of_type:\n            potion_positions = potions_of_type[x]\n            monster_positions = monsters_of_type[x]\n            \n            potion_idx = 0\n            for monster_idx in monster_positions:\n                assigned_potion = -1\n                temp_idx = potion_idx\n                while temp_idx < len(potion_positions) and potion_positions[temp_idx] < monster_idx:\n                    if potion_positions[temp_idx] not in assigned:\n                        assigned_potion = potion_positions[temp_idx]\n                    temp_idx += 1\n                \n                if assigned_potion == -1:\n                    for j in range(len(potion_positions)-1, -1, -1):\n                        p_idx = potion_positions[j]\n                        if p_idx < monster_idx and p_idx not in assigned:\n                            assigned_potion = p_idx\n                            break\n                \n                assigned[assigned_potion] = monster_idx\n                # Update potion_idx to be after this assigned potion\n                for j in range(len(potion_positions)):\n                    if potion_positions[j] == assigned_potion:\n                        potion_idx = j + 1\n                        break\n        \n        # Create mapping from event index to potion index in potion_indices list\n        event_idx_to_potion_idx = {}\n        for i, idx in enumerate(potion_indices):\n            event_idx_to_potion_idx[idx] = i\n        \n        # Set pick_up for assigned potions\n        for potion_event_idx in assigned:\n            if potion_event_idx in event_idx_to_potion_idx:\n                pick_idx = event_idx_to_potion_idx[potion_event_idx]\n                pick_up[pick_idx] = 1\n        \n        print(answer)\n        print(' '.join(map(str, pick_up)))\n    \n    threading.Thread(target=main).start()\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2867",
            "difficulty": "medium",
            "total_time": 8.270127773284912,
            "code_generation_time": 7.239810466766357,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 616,
            "total_output_tokens": 293,
            "error": null,
            "traceback": null,
            "code": "def solve():\n    MOD = 10**9 + 7\n    \n    # Read input\n    nums = list(map(int, input().strip().split('[')[1].strip(']').split(',')))\n    \n    # Find all positions of 1s\n    ones_positions = []\n    for i in range(len(nums)):\n        if nums[i] == 1:\n            ones_positions.append(i)\n    \n    # If there are no 1s, there's no way to split into good subarrays\n    if not ones_positions:\n        print(0)\n        return\n    \n    # If there's only one 1, there's only one way to split\n    if len(ones_positions) == 1:\n        print(1)\n        return\n    \n    # For each pair of consecutive 1s, calculate the number of ways to split between them\n    result = 1\n    for i in range(len(ones_positions) - 1):\n        # The number of ways to split between two 1s is the distance between them\n        # because we can split after any of the 0s between them (including right after the first 1)\n        # but before the next 1\n        distance = ones_positions[i+1] - ones_positions[i]\n        result = (result * distance) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc324_e",
            "difficulty": "hard",
            "total_time": 23.05319905281067,
            "code_generation_time": 20.30683732032776,
            "passed_tests": 7,
            "total_tests": 40,
            "success_rate": 0.17,
            "total_input_tokens": 954,
            "total_output_tokens": 623,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    T = data[1]\n    S = data[2:2+N]\n    \n    # Precompute for each string S_i:\n    # prefix[i][c] = number of character c in T[0:i] that can be matched using prefix of S_i\n    # suffix[i][c] = number of character c in T[i:] that can be matched using suffix of S_i\n    \n    len_T = len(T)\n    \n    # For each string, compute how much prefix of T it can match from the start\n    # and how much suffix of T it can match from the end\n    \n    # prefix_match[i] = max j such that T[0:j] is a subsequence of S_i\n    prefix_match = [0] * N\n    \n    # suffix_match[i] = max j such that T[j:] is a subsequence of S_i\n    suffix_match = [len_T] * N\n    \n    # Compute prefix_match\n    for idx in range(N):\n        s = S[idx]\n        j = 0\n        for char in s:\n            if j < len_T and char == T[j]:\n                j += 1\n        prefix_match[idx] = j\n    \n    # Compute suffix_match\n    for idx in range(N):\n        s = S[idx]\n        j = len_T - 1\n        for char in reversed(s):\n            if j >= 0 and char == T[j]:\n                j -= 1\n        suffix_match[idx] = j + 1  # j+1 is the first index of T that is not matched from the end\n    \n    # Now, for each pair (i,j), we want prefix_match[i] + suffix_match[j] >= len_T\n    # This means that the prefix of T matched by S_i and the suffix of T matched by S_j\n    # together cover the whole T (they may overlap, but that's fine for subsequence)\n    \n    # We can count this efficiently by sorting and using binary search or two pointers\n    \n    # Let's sort suffix_match\n    suffix_sorted = sorted(suffix_match)\n    \n    count = 0\n    for i in range(N):\n        prefix = prefix_match[i]\n        # We need suffix_match[j] >= len_T - prefix\n        target = len_T - prefix\n        # Count how many elements in suffix_sorted are >= target\n        # This is equivalent to N - bisect_left(suffix_sorted, target)\n        left, right = 0, N\n        while left < right:\n            mid = (left + right) // 2\n            if suffix_sorted[mid] >= target:\n                right = mid\n            else:\n                left = mid + 1\n        count += N - left\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc318_d",
            "difficulty": "medium",
            "total_time": 21.189898252487183,
            "code_generation_time": 19.67551898956299,
            "passed_tests": 11,
            "total_tests": 17,
            "success_rate": 0.65,
            "total_input_tokens": 1213,
            "total_output_tokens": 349,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom itertools import combinations\n\ndef main():\n    N = int(sys.stdin.readline())\n    D = [[0]*N for _ in range(N)]\n    \n    for i in range(N-1):\n        row = list(map(int, sys.stdin.readline().split()))\n        for j in range(len(row)):\n            D[i][i+1+j] = row[j]\n            D[i+1+j][i] = row[j]\n    \n    # Dynamic programming with bitmasks\n    # dp[mask] = maximum weight matching for the subset of vertices represented by mask\n    dp = [0] * (1 << N)\n    \n    # For each subset of vertices\n    for mask in range(1 << N):\n        # Count number of vertices in the subset\n        count = bin(mask).count('1')\n        # If odd number of vertices, skip as we can't have a perfect matching\n        if count % 2 == 1:\n            continue\n            \n        # Try all possible pairs of vertices in this subset\n        for i in range(N):\n            if not (mask & (1 << i)):\n                continue\n            for j in range(i+1, N):\n                if not (mask & (1 << j)):\n                    continue\n                # Create a new mask without vertices i and j\n                new_mask = mask ^ (1 << i) ^ (1 << j)\n                # Update dp[mask] with the possibility of matching i and j\n                dp[mask] = max(dp[mask], dp[new_mask] + D[i][j])\n    \n    print(dp[(1 << N) - 1])\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "abc343_c",
            "difficulty": "medium",
            "total_time": 15.286935091018677,
            "code_generation_time": 14.594417095184326,
            "passed_tests": 29,
            "total_tests": 29,
            "success_rate": 1.0,
            "total_input_tokens": 741,
            "total_output_tokens": 318,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef is_palindrome(n):\n    s = str(n)\n    return s == s[::-1]\n\ndef solve():\n    N = int(input().strip())\n    \n    # We need to find the largest cube <= N that is also a palindrome.\n    # Since N can be up to 10^18, the cube root can be up to 10^6.\n    # So we can iterate from the cube root of N downwards.\n    \n    # Find the integer cube root of N\n    # We can use binary search or simply use int(N**(1/3)) and adjust\n    low = 1\n    high = 10**6\n    cube_root_N = 1\n    \n    # Binary search for the largest integer whose cube is <= N\n    while low <= high:\n        mid = (low + high) // 2\n        cube = mid * mid * mid\n        if cube <= N:\n            cube_root_N = mid\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    # Now check from cube_root_N downwards to find the largest palindromic cube\n    for x in range(cube_root_N, 0, -1):\n        cube = x * x * x\n        if cube <= N and is_palindrome(cube):\n            print(cube)\n            return\n            \n    # This should not happen for valid input, but just in case\n    print(1)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc309_e",
            "difficulty": "hard",
            "total_time": 16.70355796813965,
            "code_generation_time": 11.835802555084229,
            "passed_tests": 43,
            "total_tests": 51,
            "success_rate": 0.84,
            "total_input_tokens": 959,
            "total_output_tokens": 505,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    import sys\n    sys.setrecursionlimit(10**6)\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    M = int(data[idx]); idx += 1\n    \n    if N == 1:\n        p = []\n    else:\n        p = list(map(int, data[idx:idx+N-1])); idx += N-1\n    \n    # Build tree: parent -> list of children\n    children = defaultdict(list)\n    for i in range(2, N+1):\n        parent = p[i-2]\n        children[parent].append(i)\n    \n    # For each insurance, we need to cover the person and their descendants up to y generations\n    # We'll do a BFS/DFS from each x_i for y_i generations\n    \n    # To avoid recomputation, we'll track for each person the maximum generations they are covered\n    max_gen = [0] * (N+1)\n    \n    insurances = []\n    for _ in range(M):\n        x = int(data[idx]); idx += 1\n        y = int(data[idx]); idx += 1\n        insurances.append((x, y))\n    \n    # For each insurance, perform BFS to propagate coverage\n    for x, y in insurances:\n        if y > max_gen[x]:\n            max_gen[x] = y\n    \n    # Now propagate the coverage down the tree\n    # We'll do a DFS traversal to propagate max_gen values down\n    def dfs(u, current_gen):\n        if current_gen <= 0:\n            return\n        for v in children[u]:\n            if current_gen - 1 > max_gen[v]:\n                max_gen[v] = current_gen - 1\n                dfs(v, current_gen - 1)\n    \n    # Start DFS from all nodes that have initial coverage\n    for i in range(1, N+1):\n        if max_gen[i] > 0:\n            dfs(i, max_gen[i])\n    \n    # Count how many people have max_gen > 0\n    count = 0\n    for i in range(1, N+1):\n        if max_gen[i] > 0:\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "abc338_d",
            "difficulty": "hard",
            "total_time": 31.371290922164917,
            "code_generation_time": 21.17404294013977,
            "passed_tests": 2,
            "total_tests": 27,
            "success_rate": 0.07,
            "total_input_tokens": 1364,
            "total_output_tokens": 601,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    import sys\n    sys.setrecursionlimit(1 << 25)\n    \n    N, M = map(int, sys.stdin.readline().split())\n    X = list(map(int, sys.stdin.readline().split()))\n    \n    # We can go clockwise or counter-clockwise between any two islands\n    # Distance between island a and b is min((b-a)%N, (a-b)%N)\n    def dist(a, b):\n        if a > b:\n            a, b = b, a\n        return min(b - a, N - (b - a))\n    \n    # Calculate the total distance without removing any bridge\n    total = 0\n    for i in range(M - 1):\n        total += dist(X[i], X[i + 1])\n    \n    # For each bridge, calculate how much we lose by removing it\n    # Bridges are numbered from 1 to N\n    # Bridge i connects island i and island i+1 (with wraparound)\n    loss = [0] * (N + 1)  # loss[i] = loss when removing bridge i\n    \n    for i in range(M - 1):\n        u, v = X[i], X[i + 1]\n        d = dist(u, v)\n        if d == 0:\n            continue\n            \n        # Determine which bridges are used in the shortest path from u to v\n        # There are two paths: clockwise and counter-clockwise\n        if u > v:\n            u, v = v, u\n            \n        cw_dist = v - u\n        ccw_dist = N - (v - u)\n        \n        if cw_dist == ccw_dist:\n            # Both paths have same length, use both\n            # Clockwise path: bridges u, u+1, ..., v-1\n            for j in range(u, v):\n                loss[j] += 1\n            # Counter-clockwise path: bridges v, v+1, ..., N, 1, ..., u-1\n            for j in range(v, N):\n                loss[j] += 1\n            for j in range(1, u):\n                loss[j] += 1\n        elif cw_dist < ccw_dist:\n            # Only clockwise path is used\n            for j in range(u, v):\n                loss[j] += 1\n        else:\n            # Only counter-clockwise path is used\n            for j in range(v, N):\n                loss[j] += 1\n            for j in range(1, u):\n                loss[j] += 1\n    \n    # Find the bridge whose removal causes minimum loss\n    min_loss = min(loss[1:N+1])\n    \n    # The answer is total - min_loss\n    print(total - min_loss)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc329_f",
            "difficulty": "hard",
            "total_time": 21.645679473876953,
            "code_generation_time": 16.40681028366089,
            "passed_tests": 36,
            "total_tests": 42,
            "success_rate": 0.86,
            "total_input_tokens": 1001,
            "total_output_tokens": 251,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    Q = int(data[1])\n    \n    # Read initial colors\n    C = list(map(int, data[2:2+N]))\n    \n    # Initialize boxes: each box contains a set of colors\n    boxes = [set() for _ in range(N + 1)]  # 1-indexed\n    \n    # Fill initial balls\n    for i in range(1, N + 1):\n        boxes[i].add(C[i - 1])\n    \n    # Process queries\n    index = 2 + N\n    results = []\n    \n    for _ in range(Q):\n        a = int(data[index])\n        b = int(data[index + 1])\n        index += 2\n        \n        # Move all balls from box a to box b\n        boxes[b].update(boxes[a])\n        boxes[a].clear()\n        \n        # Print number of different colors in box b\n        results.append(str(len(boxes[b])))\n    \n    print('\\n'.join(results))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc306_c",
            "difficulty": "medium",
            "total_time": 9.822346925735474,
            "code_generation_time": 8.93001914024353,
            "passed_tests": 16,
            "total_tests": 16,
            "success_rate": 1.0,
            "total_input_tokens": 893,
            "total_output_tokens": 199,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    # For each number, store all its positions\n    positions = defaultdict(list)\n    for i in range(3 * N):\n        positions[A[i]].append(i)\n    \n    # For each number, find its middle occurrence position\n    middle_positions = []\n    for i in range(1, N + 1):\n        # positions are 0-indexed, so we take the second one (index 1)\n        middle_pos = positions[i][1]\n        middle_positions.append((middle_pos, i))\n    \n    # Sort by middle position\n    middle_positions.sort()\n    \n    # Extract the numbers in the sorted order\n    result = [str(num) for _, num in middle_positions]\n    print(' '.join(result))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc331_b",
            "difficulty": "easy",
            "total_time": 13.086661338806152,
            "code_generation_time": 12.836092710494995,
            "passed_tests": 21,
            "total_tests": 22,
            "success_rate": 0.95,
            "total_input_tokens": 686,
            "total_output_tokens": 272,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N, S, M, L = map(int, input().split())\n    \n    min_cost = float('inf')\n    \n    # Try all combinations of packs\n    # Since N <= 100, and we have packs of 6, 8, 12\n    # We don't need to check too many combinations\n    for s_count in range(17):  # 16*6 = 96, 17*6 = 102 > 100\n        for m_count in range(13):  # 12*8 = 96, 13*8 = 104 > 100\n            for l_count in range(9):  # 8*12 = 96, 9*12 = 108 > 100\n                total_eggs = 6 * s_count + 8 * m_count + 12 * l_count\n                if total_eggs >= N:\n                    cost = S * s_count + M * m_count + L * l_count\n                    min_cost = min(min_cost, cost)\n    \n    print(min_cost)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2869",
            "difficulty": "medium",
            "total_time": 14.22387146949768,
            "code_generation_time": 13.343145370483398,
            "passed_tests": 0,
            "total_tests": 83,
            "success_rate": 0.0,
            "total_input_tokens": 901,
            "total_output_tokens": 356,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    nums1 = list(map(int, data[1:n+1]))\n    nums2 = list(map(int, data[n+1:2*n+1]))\n    \n    # dp[i][0] = longest non-decreasing subarray ending at i when we choose nums1[i]\n    # dp[i][1] = longest non-decreasing subarray ending at i when we choose nums2[i]\n    dp = [[1, 1] for _ in range(n)]\n    \n    max_len = 1\n    \n    for i in range(1, n):\n        # If we choose nums1[i]\n        if nums1[i] >= nums1[i-1]:\n            dp[i][0] = max(dp[i][0], dp[i-1][0] + 1)\n        if nums1[i] >= nums2[i-1]:\n            dp[i][0] = max(dp[i][0], dp[i-1][1] + 1)\n            \n        # If we choose nums2[i]\n        if nums2[i] >= nums1[i-1]:\n            dp[i][1] = max(dp[i][1], dp[i-1][0] + 1)\n        if nums2[i] >= nums2[i-1]:\n            dp[i][1] = max(dp[i][1], dp[i-1][1] + 1)\n            \n        max_len = max(max_len, dp[i][0], dp[i][1])\n    \n    print(max_len)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc332_d",
            "difficulty": "hard",
            "total_time": 18.827051877975464,
            "code_generation_time": 17.82064700126648,
            "passed_tests": 38,
            "total_tests": 38,
            "success_rate": 1.0,
            "total_input_tokens": 2615,
            "total_output_tokens": 441,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque\n\ndef read_grid(H, W):\n    grid = []\n    for _ in range(H):\n        row = list(map(int, sys.stdin.readline().split()))\n        grid.append(row)\n    return grid\n\ndef grid_to_tuple(grid):\n    return tuple(tuple(row) for row in grid)\n\ndef tuple_to_grid(t):\n    return [list(row) for row in t]\n\ndef get_neighbors(state, H, W):\n    grid = tuple_to_grid(state)\n    neighbors = []\n    \n    # Row swaps\n    for i in range(H - 1):\n        new_grid = [row[:] for row in grid]\n        new_grid[i], new_grid[i+1] = new_grid[i+1], new_grid[i]\n        neighbors.append((grid_to_tuple(new_grid), 1))\n    \n    # Column swaps\n    for j in range(W - 1):\n        new_grid = [row[:] for row in grid]\n        for i in range(H):\n            new_grid[i][j], new_grid[i][j+1] = new_grid[i][j+1], new_grid[i][j]\n        neighbors.append((grid_to_tuple(new_grid), 1))\n    \n    return neighbors\n\ndef bfs(start, target, H, W):\n    if start == target:\n        return 0\n    \n    queue = deque([(start, 0)])\n    visited = {start}\n    \n    while queue:\n        current, dist = queue.popleft()\n        \n        for neighbor, cost in get_neighbors(current, H, W):\n            if neighbor == target:\n                return dist + cost\n            \n            if neighbor not in visited:\n                visited.add(neighbor)\n                queue.append((neighbor, dist + cost))\n    \n    return -1\n\ndef solve():\n    H, W = map(int, sys.stdin.readline().split())\n    A = read_grid(H, W)\n    B = read_grid(H, W)\n    \n    start = grid_to_tuple(A)\n    target = grid_to_tuple(B)\n    \n    result = bfs(start, target, H, W)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc322_c",
            "difficulty": "medium",
            "total_time": 6.112199068069458,
            "code_generation_time": 4.9512269496917725,
            "passed_tests": 27,
            "total_tests": 27,
            "success_rate": 1.0,
            "total_input_tokens": 847,
            "total_output_tokens": 189,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport bisect\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    # For each day i from 1 to N, find the first firework day >= i\n    # Since A is sorted, we can use binary search (bisect_left)\n    \n    for i in range(1, N + 1):\n        # Find the leftmost position in A where A[pos] >= i\n        pos = bisect.bisect_left(A, i)\n        # The first firework day on or after day i is A[pos]\n        firework_day = A[pos]\n        # Number of days from day i to firework_day\n        days_later = firework_day - i\n        print(days_later)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3094",
            "difficulty": "medium",
            "total_time": 7.886641502380371,
            "code_generation_time": 6.956045150756836,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 744,
            "total_output_tokens": 334,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import Counter\n\ndef solve():\n    nums = list(map(int, sys.stdin.readline().strip().split()))\n    \n    # Count frequency of each number\n    freq = Counter(nums)\n    \n    operations = 0\n    \n    for count in freq.values():\n        if count == 1:\n            # If any number appears only once, it's impossible to remove all instances\n            print(-1)\n            return\n        \n        # Calculate minimum operations for this count\n        # We want to minimize operations, so we prefer removing 3 elements at a time\n        # If count is divisible by 3, we use only 3-removals\n        # If count % 3 == 1, we use two 2-removals and rest 3-removals (since 1 is not possible)\n        # If count % 3 == 2, we use one 2-removal and rest 3-removals\n        \n        if count % 3 == 0:\n            operations += count // 3\n        elif count % 3 == 1:\n            # Use two 2-removals (4 elements) and rest 3-removals\n            operations += 2 + (count - 4) // 3\n        else:  # count % 3 == 2\n            # Use one 2-removal and rest 3-removals\n            operations += 1 + (count - 2) // 3\n    \n    print(operations)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc312_b",
            "difficulty": "easy",
            "total_time": 25.2148494720459,
            "code_generation_time": 24.99075698852539,
            "passed_tests": 14,
            "total_tests": 14,
            "success_rate": 1.0,
            "total_input_tokens": 1377,
            "total_output_tokens": 544,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef is_tak_code(grid, start_r, start_c):\n    # Check the 3x3 top-left region (must be all black)\n    for i in range(3):\n        for j in range(3):\n            if grid[start_r + i][start_c + j] != '#':\n                return False\n                \n    # Check the 3x3 bottom-right region (must be all black)\n    for i in range(3):\n        for j in range(3):\n            if grid[start_r + 6 + i][start_c + 6 + j] != '#':\n                return False\n                \n    # Check adjacent cells to top-left 3x3 region (must be all white)\n    # Adjacent cells include the 3x3 region itself and the surrounding cells\n    for i in range(4):\n        for j in range(4):\n            if 0 <= i < 3 and 0 <= j < 3:\n                continue  # Skip the 3x3 region itself\n            r, c = start_r + i, start_c + j\n            if 0 <= r < start_r + 9 and 0 <= c < start_c + 9:\n                if grid[r][c] != '.':\n                    return False\n                    \n    # Check adjacent cells to bottom-right 3x3 region (must be all white)\n    for i in range(5, 9):\n        for j in range(5, 9):\n            if 6 <= i < 9 and 6 <= j < 9:\n                continue  # Skip the 3x3 region itself\n            r, c = start_r + i, start_c + j\n            if 0 <= r < start_r + 9 and 0 <= c < start_c + 9:\n                if grid[r][c] != '.':\n                    return False\n                    \n    return True\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    grid = []\n    for _ in range(N):\n        grid.append(sys.stdin.readline().strip())\n    \n    results = []\n    for i in range(N - 8):  # 9x9 region, so N-8 possible starting rows\n        for j in range(M - 8):  # M-8 possible starting columns\n            if is_tak_code(grid, i, j):\n                results.append((i + 1, j + 1))  # 1-indexed\n    \n    for r, c in results:\n        print(r, c)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "1899_C",
            "difficulty": "hard",
            "total_time": 4.934737205505371,
            "code_generation_time": 3.8269104957580566,
            "passed_tests": 106,
            "total_tests": 106,
            "success_rate": 1.0,
            "total_input_tokens": 948,
            "total_output_tokens": 177,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    n = int(input())\n    a = list(map(int, input().split()))\n    \n    max_sum = float('-inf')\n    current_sum = 0\n    \n    for i in range(n):\n        # If it's the first element or the parity alternates\n        if i == 0 or (a[i] % 2) != (a[i-1] % 2):\n            current_sum = max(a[i], current_sum + a[i])\n        else:\n            # Parity doesn't alternate, start a new subarray\n            current_sum = a[i]\n        \n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum\n\nif __name__ == \"__main__\":\n    t = int(input())\n    for _ in range(t):\n        result = solve()\n        print(result)",
            "history_file": null
        },
        {
            "question_id": "3228",
            "difficulty": "medium",
            "total_time": 15.322821855545044,
            "code_generation_time": 14.427632808685303,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 991,
            "total_output_tokens": 605,
            "error": null,
            "traceback": null,
            "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    n = int(data[0])\n    nums1 = list(map(int, data[1:n+1]))\n    nums2 = list(map(int, data[n+1:2*n+1]))\n    \n    # Convert to sets to get unique elements\n    set1 = set(nums1)\n    set2 = set(nums2)\n    \n    # Get the intersection and unique elements in each set\n    common = set1 & set2\n    only1 = set1 - set2\n    only2 = set2 - set1\n    \n    # Number of elements to remove from each array\n    remove1 = n // 2\n    remove2 = n // 2\n    \n    # Number of elements in each category\n    len_only1 = len(only1)\n    len_only2 = len(only2)\n    len_common = len(common)\n    \n    # First, try to remove elements from the unique parts\n    # Remove from only1 if we have more than what we need to keep\n    removed_from_only1 = max(0, len_only1 - (n // 2))\n    need_to_remove_from_only1 = max(0, remove1 - (len_only1 - (n // 2)) if len_only1 > (n // 2) else remove1)\n    \n    # But we can only remove up to len_only1 from only1\n    actually_remove_from_only1 = min(need_to_remove_from_only1, len_only1)\n    \n    # Similarly for only2\n    removed_from_only2 = max(0, len_only2 - (n // 2))\n    need_to_remove_from_only2 = max(0, remove2 - (len_only2 - (n // 2)) if len_only2 > (n // 2) else remove2)\n    actually_remove_from_only2 = min(need_to_remove_from_only2, len_only2)\n    \n    # After removing from unique parts, see how many more we need to remove\n    remaining_remove1 = remove1 - actually_remove_from_only1\n    remaining_remove2 = remove2 - actually_remove_from_only2\n    \n    # These remaining removals must come from the common elements\n    # We can remove at most len_common elements from common\n    total_remove_from_common = min(len_common, remaining_remove1 + remaining_remove2)\n    \n    # The final set size is:\n    # All unique elements that are kept + common elements that are kept\n    kept_only1 = len_only1 - actually_remove_from_only1\n    kept_only2 = len_only2 - actually_remove_from_only2\n    kept_common = len_common - total_remove_from_common\n    \n    result = kept_only1 + kept_only2 + kept_common\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc318_b",
            "difficulty": "easy",
            "total_time": 5.7326014041900635,
            "code_generation_time": 5.427348852157593,
            "passed_tests": 21,
            "total_tests": 21,
            "success_rate": 1.0,
            "total_input_tokens": 877,
            "total_output_tokens": 321,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(input())\n    rectangles = []\n    for _ in range(N):\n        A, B, C, D = map(int, input().split())\n        rectangles.append((A, B, C, D))\n    \n    # Collect all unique x and y coordinates\n    x_coords = set()\n    y_coords = set()\n    for A, B, C, D in rectangles:\n        x_coords.add(A)\n        x_coords.add(B)\n        y_coords.add(C)\n        y_coords.add(D)\n    \n    # Sort the coordinates\n    x_sorted = sorted(x_coords)\n    y_sorted = sorted(y_coords)\n    \n    total_area = 0\n    \n    # Iterate through each cell in the discretized grid\n    for i in range(len(x_sorted) - 1):\n        for j in range(len(y_sorted) - 1):\n            x1, x2 = x_sorted[i], x_sorted[i+1]\n            y1, y2 = y_sorted[j], y_sorted[j+1]\n            \n            # Check if this cell is covered by any rectangle\n            for A, B, C, D in rectangles:\n                if A <= x1 and x2 <= B and C <= y1 and y2 <= D:\n                    # This cell is covered\n                    total_area += (x2 - x1) * (y2 - y1)\n                    break  # No need to check other rectangles for this cell\n    \n    print(total_area)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc333_c",
            "difficulty": "medium",
            "total_time": 39.323649883270264,
            "code_generation_time": 39.12952280044556,
            "passed_tests": 2,
            "total_tests": 17,
            "success_rate": 0.12,
            "total_input_tokens": 2620,
            "total_output_tokens": 1617,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport heapq\n\ndef solve():\n    N = int(input().strip())\n    \n    # Generate repunits\n    repunits = []\n    num = 1\n    while num <= 10**15:\n        repunits.append(num)\n        num = num * 10 + 1\n    \n    # Use a min-heap\n    heap = [(repunits[0] + repunits[0] + repunits[0], 0, 0, 0)]  # (sum, i, j, k)\n    visited = set()\n    count = 0\n    result = 0\n    \n    while count < N:\n        current_sum, i, j, k = heapq.heappop(heap)\n        \n        if (i, j, k) in visited:\n            continue\n        visited.add((i, j, k))\n        \n        result = current_sum\n        count += 1\n        \n        # Add neighbors\n        if i + 1 < len(repunits):\n            heapq.heappush(heap, (repunits[i+1] + repunits[j] + repunits[k], i+1, j, k))\n        if j + 1 < len(repunits):\n            heapq.heappush(heap, (repunits[i] + repunits[j+1] + repunits[k], i, j+1, k))\n        if k + 1 < len(repunits):\n            heapq.heappush(heap, (repunits[i] + repunits[j] + repunits[k+1], i, j, k+1))\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc314_b",
            "difficulty": "easy",
            "total_time": 19.278064966201782,
            "code_generation_time": 18.982353687286377,
            "passed_tests": 20,
            "total_tests": 20,
            "success_rate": 1.0,
            "total_input_tokens": 1158,
            "total_output_tokens": 240,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline())\n    \n    # Store bets for each person\n    bets = []\n    for i in range(N):\n        C = int(sys.stdin.readline())\n        A = list(map(int, sys.stdin.readline().split()))\n        bets.append(set(A))\n    \n    X = int(sys.stdin.readline())\n    \n    # Find people who bet on X and count their bets\n    candidates = []\n    for i in range(N):\n        if X in bets[i]:\n            candidates.append((len(bets[i]), i + 1))  # (number of bets, person number)\n    \n    if not candidates:\n        print(0)\n        return\n    \n    # Find minimum number of bets among candidates\n    min_bets = min(candidates, key=lambda x: x[0])[0]\n    \n    # Filter candidates with minimum number of bets\n    result = [person for bets_count, person in candidates if bets_count == min_bets]\n    result.sort()\n    \n    print(len(result))\n    if result:\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc324_d",
            "difficulty": "hard",
            "total_time": 21.626521348953247,
            "code_generation_time": 10.993333339691162,
            "passed_tests": 15,
            "total_tests": 43,
            "success_rate": 0.35,
            "total_input_tokens": 950,
            "total_output_tokens": 254,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import Counter\nimport math\n\ndef is_square(n):\n    if n < 0:\n        return False\n    root = int(math.sqrt(n))\n    return root * root == n\n\ndef generate_permutations(s):\n    # Generate all unique permutations of the string s\n    from itertools import permutations\n    unique_perms = set(permutations(s))\n    numbers = set()\n    for perm in unique_perms:\n        num_str = ''.join(perm)\n        if num_str[0] == '0' and len(num_str) > 1:\n            continue  # Skip numbers with leading zeros\n        num = int(num_str)\n        numbers.add(num)\n    return numbers\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    N = int(data[0])\n    S = data[1]\n    \n    # Generate all unique numbers from permutations of S\n    numbers = generate_permutations(S)\n    \n    # Count how many of them are perfect squares\n    count = 0\n    for num in numbers:\n        if is_square(num):\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3019",
            "difficulty": "easy",
            "total_time": 19.789603233337402,
            "code_generation_time": 18.906126737594604,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 674,
            "total_output_tokens": 155,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    moves = input().strip()\n    \n    # Count the fixed moves\n    left_count = moves.count('L')\n    right_count = moves.count('R')\n    underscore_count = moves.count('_')\n    \n    # The furthest distance is achieved by using all underscores \n    # to reinforce the direction with more moves\n    # If left_count > right_count, use all underscores as 'L'\n    # If right_count > left_count, use all underscores as 'R'\n    # If they are equal, it doesn't matter which direction we choose for underscores\n    distance = abs(left_count - right_count) + underscore_count\n    \n    print(distance)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc334_d",
            "difficulty": "medium",
            "total_time": 7.752961158752441,
            "code_generation_time": 5.832031488418579,
            "passed_tests": 24,
            "total_tests": 24,
            "success_rate": 1.0,
            "total_input_tokens": 958,
            "total_output_tokens": 190,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport bisect\n\ndef solve():\n    N, Q = map(int, sys.stdin.readline().split())\n    R = list(map(int, sys.stdin.readline().split()))\n    \n    # Sort the sleighs by required reindeer count\n    R.sort()\n    \n    # Precompute prefix sums\n    prefix_sum = [0] * (N + 1)\n    for i in range(N):\n        prefix_sum[i + 1] = prefix_sum[i] + R[i]\n    \n    # Process queries\n    for _ in range(Q):\n        X = int(sys.stdin.readline())\n        # Find the maximum number of sleighs we can pull\n        # This is the largest k such that prefix_sum[k] <= X\n        idx = bisect.bisect_right(prefix_sum, X) - 1\n        print(idx)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc309_c",
            "difficulty": "medium",
            "total_time": 21.94687056541443,
            "code_generation_time": 19.288045167922974,
            "passed_tests": 27,
            "total_tests": 27,
            "success_rate": 1.0,
            "total_input_tokens": 1514,
            "total_output_tokens": 306,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    K = int(data[1])\n    \n    idx = 2\n    events = []\n    for _ in range(N):\n        a = int(data[idx])\n        b = int(data[idx+1])\n        idx += 2\n        # Event: at day 1, add b pills; at day a+1, subtract b pills\n        events.append((1, b))\n        events.append((a+1, -b))\n    \n    # Sort events by day\n    events.sort()\n    \n    current_pills = 0\n    i = 0\n    day = 1\n    \n    # Process events\n    while i < len(events):\n        current_day = events[i][0]\n        # Check if on the previous day range, we already satisfied the condition\n        # But we need to process all events of the same day together\n        # So we collect all changes for current_day\n        day = current_day\n        total_change = 0\n        while i < len(events) and events[i][0] == current_day:\n            total_change += events[i][1]\n            i += 1\n        current_pills += total_change\n        if current_pills <= K:\n            print(day)\n            return\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "abc343_b",
            "difficulty": "easy",
            "total_time": 12.897931575775146,
            "code_generation_time": 12.578556060791016,
            "passed_tests": 14,
            "total_tests": 14,
            "success_rate": 1.0,
            "total_input_tokens": 1028,
            "total_output_tokens": 138,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline())\n    adj_matrix = []\n    for _ in range(N):\n        row = list(map(int, sys.stdin.readline().split()))\n        adj_matrix.append(row)\n    \n    for i in range(N):\n        connected = []\n        for j in range(N):\n            if adj_matrix[i][j] == 1:\n                connected.append(j + 1)  # Convert to 1-indexed\n        if connected:\n            print(' '.join(map(str, connected)))\n        else:\n            print()  # Print empty line if no connections\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc333_a",
            "difficulty": "easy",
            "total_time": 13.092678546905518,
            "code_generation_time": 12.927208662033081,
            "passed_tests": 7,
            "total_tests": 7,
            "success_rate": 1.0,
            "total_input_tokens": 499,
            "total_output_tokens": 43,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(input().strip())\n    result = str(N) * N\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc312_c",
            "difficulty": "medium",
            "total_time": 7.471759557723999,
            "code_generation_time": 6.56407904624939,
            "passed_tests": 8,
            "total_tests": 41,
            "success_rate": 0.2,
            "total_input_tokens": 885,
            "total_output_tokens": 215,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport bisect\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    A = list(map(int, sys.stdin.readline().split()))\n    B = list(map(int, sys.stdin.readline().split()))\n    \n    A.sort()\n    B.sort()\n    \n    left = 1\n    right = 10**9\n    answer = right\n    \n    while left <= right:\n        mid = (left + right) // 2\n        \n        # Count sellers who can sell at price mid (A_i <= mid)\n        sellers = N - bisect.bisect_left(A, mid)\n        \n        # Count buyers who can buy at price mid (B_i >= mid)\n        buyers = M - bisect.bisect_right(B, mid - 1)\n        \n        if sellers >= buyers:\n            answer = mid\n            right = mid - 1\n        else:\n            left = mid + 1\n    \n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc312_f",
            "difficulty": "hard",
            "total_time": 33.977333307266235,
            "code_generation_time": 22.560431718826294,
            "passed_tests": 22,
            "total_tests": 43,
            "success_rate": 0.51,
            "total_input_tokens": 1031,
            "total_output_tokens": 747,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport heapq\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    pull_tab_cans = []  # T_i = 0\n    regular_cans = []   # T_i = 1\n    openers = []        # T_i = 2\n\n    for _ in range(N):\n        t, x = map(int, sys.stdin.readline().split())\n        if t == 0:\n            pull_tab_cans.append(x)\n        elif t == 1:\n            regular_cans.append(x)\n        else:\n            openers.append(x)\n\n    # Sort in descending order\n    pull_tab_cans.sort(reverse=True)\n    regular_cans.sort(reverse=True)\n    openers.sort(reverse=True)\n\n    # Calculate prefix sums for pull-tab cans\n    pull_prefix = [0]\n    for val in pull_tab_cans:\n        pull_prefix.append(pull_prefix[-1] + val)\n\n    # If we take k openers, we can open min(sum of their capacities, len(regular_cans)) regular cans\n    # We should take the best regular cans possible.\n    # Let's precompute the best regular cans we can open with i openers.\n    \n    # But since number of openers can be large, we need a better approach.\n    # Let's think differently: for a fixed number of openers taken, what's the max happiness?\n    \n    # Let's sort openers in descending order (already done)\n    # For taking i openers, total capacity is sum of top i opener capacities\n    opener_capacity_prefix = [0]\n    for val in openers:\n        opener_capacity_prefix.append(opener_capacity_prefix[-1] + val)\n    \n    max_happiness = 0\n    \n    # Try all possible numbers of openers we can take: from 0 to min(len(openers), M)\n    for num_openers in range(min(len(openers), M) + 1):\n        capacity = opener_capacity_prefix[num_openers]\n        # We take num_openers openers\n        items_taken = num_openers\n        \n        if items_taken > M:\n            continue\n            \n        # We can take up to (M - num_openers) other items\n        remaining_slots = M - num_openers\n        \n        # From regular cans, we can take min(remaining_slots, capacity) cans\n        # But we also need to consider that we have only len(regular_cans) regular cans\n        max_regular_taken = min(len(regular_cans), capacity, remaining_slots)\n        regular_happiness = sum(regular_cans[:max_regular_taken]) if max_regular_taken > 0 else 0\n        \n        # Remaining slots after taking openers and regular cans\n        slots_after_regular = remaining_slots - max_regular_taken\n        \n        # From pull-tab cans, take min(slots_after_regular, len(pull_tab_cans)) best ones\n        pull_taken = min(slots_after_regular, len(pull_tab_cans))\n        pull_happiness = pull_prefix[pull_taken] if pull_taken > 0 else 0\n        \n        total_happiness = regular_happiness + pull_happiness\n        max_happiness = max(max_happiness, total_happiness)\n        \n    # Also consider the case where we take no openers\n    # Take up to M items from pull-tab cans\n    only_pull_happiness = pull_prefix[min(M, len(pull_tab_cans))]\n    max_happiness = max(max_happiness, only_pull_happiness)\n    \n    print(max_happiness)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3225",
            "difficulty": "medium",
            "total_time": 30.348056316375732,
            "code_generation_time": 29.320371627807617,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 879,
            "total_output_tokens": 191,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    # Read input\n    nums = list(map(int, sys.stdin.readline().split()))\n    k = int(sys.stdin.readline().strip())\n    \n    # Sliding window approach\n    left = 0\n    max_length = 0\n    freq = defaultdict(int)\n    \n    for right in range(len(nums)):\n        # Add current element to window\n        freq[nums[right]] += 1\n        \n        # Shrink window until it's good again\n        while freq[nums[right]] > k:\n            freq[nums[left]] -= 1\n            if freq[nums[left]] == 0:\n                del freq[nums[left]]\n            left += 1\n        \n        # Update maximum length\n        max_length = max(max_length, right - left + 1)\n    \n    print(max_length)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc303_e",
            "difficulty": "hard",
            "total_time": 252.52495503425598,
            "code_generation_time": 250.62953972816467,
            "passed_tests": 12,
            "total_tests": 18,
            "success_rate": 0.67,
            "total_input_tokens": 1120,
            "total_output_tokens": 8016,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef main():\n    N = int(input())\n    \n    # Build adjacency list and compute degrees\n    adj = defaultdict(list)\n    degree = [0] * (N + 1)\n    \n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        adj[u].append(v)\n        adj[v].append(u)\n        degree[u] += 1\n        degree[v] += 1\n    \n    # Find all star levels\n    stars = []\n    \n    # Vertices with degree >= 3 are definitely centers\n    for i in range(1, N + 1):\n        if degree[i] >= 3:\n            stars.append(degree[i])\n    \n    # Vertices with degree = 2: check if they are centers\n    # They are centers if they have a neighbor of degree 1\n    for i in range(1, N + 1):\n        if degree[i] == 2:\n            is_center = False\n            for neighbor in adj[i]:\n                if degree[neighbor] == 1:\n                    is_center = True\n                    break\n            if is_center:\n                stars.append(2)\n    \n    stars.sort()\n    print(' '.join(map(str, stars)))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "abc305_a",
            "difficulty": "easy",
            "total_time": 4.358952283859253,
            "code_generation_time": 4.259915590286255,
            "passed_tests": 7,
            "total_tests": 7,
            "success_rate": 1.0,
            "total_input_tokens": 695,
            "total_output_tokens": 194,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(input())\n    \n    # Water stations are at 0, 5, 10, 15, ..., 100\n    # Find the nearest one to N\n    \n    # Find the water station just before or at N\n    lower = (N // 5) * 5\n    # Find the water station just after N\n    upper = lower + 5\n    \n    # Handle edge case where N is exactly at a water station\n    if N % 5 == 0:\n        print(N)\n        return\n    \n    # Calculate distances to nearest water stations\n    dist_to_lower = N - lower\n    dist_to_upper = upper - N\n    \n    # Choose the nearest one\n    if dist_to_lower <= dist_to_upper:\n        print(lower)\n    else:\n        print(upper)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2884",
            "difficulty": "hard",
            "total_time": 7.635818004608154,
            "code_generation_time": 6.7508933544158936,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 720,
            "total_output_tokens": 341,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    word = data[0]\n    n = int(data[1])\n    forbidden = data[2:2+n]\n    \n    # Store forbidden words in a set for O(1) lookup\n    forbidden_set = set(forbidden)\n    \n    # Also group them by their lengths for efficient checking\n    max_len = 0\n    for f in forbidden:\n        max_len = max(max_len, len(f))\n    \n    # Use sliding window approach\n    # For each position, we'll find the longest valid substring ending at that position\n    longest = 0\n    left = 0\n    n = len(word)\n    \n    for right in range(n):\n        # Check all possible forbidden substrings ending at 'right'\n        # We only need to check up to max_len characters back\n        start_check = max(0, right - max_len + 1)\n        # But we also shouldn't go before our current 'left'\n        start_check = max(start_check, left)\n        \n        # Check each possible substring ending at 'right'\n        for i in range(start_check, right + 1):\n            substring = word[i:right+1]\n            if substring in forbidden_set:\n                # Move left pointer to position after the start of forbidden substring\n                left = i + 1\n                \n        # Update the maximum length\n        longest = max(longest, right - left + 1)\n    \n    print(longest)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2866",
            "difficulty": "easy",
            "total_time": 19.284096479415894,
            "code_generation_time": 18.351414442062378,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 857,
            "total_output_tokens": 227,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    # Read input\n    nums = list(map(int, sys.stdin.readline().strip().strip('[]').split(',')))\n    threshold = int(sys.stdin.readline().strip())\n    \n    max_length = 0\n    n = len(nums)\n    \n    # Try each possible starting position\n    for l in range(n):\n        # Check if the first element satisfies the condition (even and <= threshold)\n        if nums[l] % 2 == 0 and nums[l] <= threshold:\n            r = l\n            # Extend the subarray as far as possible\n            while r < n and nums[r] <= threshold:\n                # If we're not at the start, check the alternating condition\n                if r > l and nums[r] % 2 == nums[r-1] % 2:\n                    break\n                r += 1\n            # Update max_length with the length of current valid subarray\n            max_length = max(max_length, r - l)\n    \n    print(max_length)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3320",
            "difficulty": "easy",
            "total_time": 17.339600563049316,
            "code_generation_time": 16.424838304519653,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 689,
            "total_output_tokens": 184,
            "error": null,
            "traceback": null,
            "code": "def max_operations(nums):\n    if len(nums) < 2:\n        return 0\n    \n    # The score of the first operation sets the target score\n    target_score = nums[0] + nums[1]\n    operations = 1  # We've already performed the first operation conceptually\n    \n    # Start from the third element (index 2)\n    i = 2\n    while i + 1 < len(nums):\n        current_score = nums[i] + nums[i + 1]\n        if current_score == target_score:\n            operations += 1\n            i += 2  # Move to the next pair\n        else:\n            break  # Stop if the score doesn't match\n            \n    return operations\n\n# Read input\nnums = list(map(int, input().split()))\n\n# Solve and print result\nresult = max_operations(nums)\nprint(result)",
            "history_file": null
        },
        {
            "question_id": "abc315_b",
            "difficulty": "easy",
            "total_time": 17.632762670516968,
            "code_generation_time": 17.255475521087646,
            "passed_tests": 24,
            "total_tests": 24,
            "success_rate": 1.0,
            "total_input_tokens": 934,
            "total_output_tokens": 122,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    M = int(input())\n    D = list(map(int, input().split()))\n    \n    total_days = sum(D)\n    middle_day = (total_days + 1) // 2\n    \n    current_day = 0\n    for month in range(M):\n        if current_day + D[month] >= middle_day:\n            day_in_month = middle_day - current_day\n            print(month + 1, day_in_month)\n            return\n        current_day += D[month]\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc313_a",
            "difficulty": "easy",
            "total_time": 19.09066414833069,
            "code_generation_time": 18.92606782913208,
            "passed_tests": 12,
            "total_tests": 12,
            "success_rate": 1.0,
            "total_input_tokens": 690,
            "total_output_tokens": 135,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(input())\n    P = list(map(int, input().split()))\n    \n    # Person 1's current ability\n    p1 = P[0]\n    \n    # Find the maximum ability among others\n    max_other = max(P[1:]) if N > 1 else 0\n    \n    # If person 1 is already the strongest\n    if p1 > max_other:\n        return 0\n    \n    # Otherwise, person 1 needs to exceed the maximum\n    return max_other - p1 + 1\n\nif __name__ == \"__main__\":\n    print(solve())",
            "history_file": null
        },
        {
            "question_id": "abc329_e",
            "difficulty": "hard",
            "total_time": 31.718743085861206,
            "code_generation_time": 15.916595935821533,
            "passed_tests": 4,
            "total_tests": 48,
            "success_rate": 0.08,
            "total_input_tokens": 765,
            "total_output_tokens": 612,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    S = sys.stdin.readline().strip()\n    T = sys.stdin.readline().strip()\n    \n    # BFS approach\n    # State: current string (but we'll use a more efficient representation)\n    # We'll use a list to represent the current state of X\n    # '#' means not yet filled, letters mean filled\n    \n    # Since M is at most 5, and we're replacing segments, we can use BFS\n    # But N can be up to 2*10^5, so we can't store the full string in the BFS queue\n    \n    # Better approach: Use BFS with state compression\n    # We only need to track which positions are filled and with what characters\n    # But even that might be too much\n    \n    # Key insight: We can think of this as a graph problem\n    # Each position can be in state '#' or a letter\n    # But transitions are complex\n    \n    # Let's think differently:\n    # We can only place T at positions where it would match S or where there are '#'s\n    # So we can try to \"work backwards\" or use BFS\n    \n    # Actually, let's use BFS on the string states, but represent the string efficiently\n    \n    # Since M <= 5, we can consider the positions where we place T\n    # Let's use BFS where each state is the current configuration of the string\n    \n    # To make it efficient, let's represent the string as a list\n    # '#' for unfilled, actual characters for filled\n    \n    # Start with all '#'\n    start = ['#'] * N\n    \n    # Target is S\n    target = list(S)\n    \n    # BFS\n    queue = deque()\n    queue.append(start[:])  # Add a copy of start\n    visited = set()\n    visited.add(tuple(start))\n    \n    while queue:\n        current = queue.popleft()\n        \n        # Check if we've reached the target\n        if current == target:\n            print(\"Yes\")\n            return\n        \n        # Try placing T at every possible position\n        for i in range(N - M + 1):\n            # Check if we can place T at position i\n            # We can place it if all positions are either '#' or match T\n            can_place = True\n            for j in range(M):\n                if current[i+j] != '#' and current[i+j] != T[j]:\n                    can_place = False\n                    break\n            \n            if can_place:\n                # Create new state\n                new_state = current[:]\n                for j in range(M):\n                    new_state[i+j] = T[j]\n                \n                new_tuple = tuple(new_state)\n                if new_tuple not in visited:\n                    visited.add(new_tuple)\n                    queue.append(new_state)\n    \n    print(\"No\")\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3223",
            "difficulty": "hard",
            "total_time": 25.367114305496216,
            "code_generation_time": 23.473331212997437,
            "passed_tests": 82,
            "total_tests": 100,
            "success_rate": 0.82,
            "total_input_tokens": 641,
            "total_output_tokens": 553,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef countCompleteSubstrings(word, k):\n    n = len(word)\n    \n    # Preprocess to find valid segments where adjacent characters differ by at most 2\n    # Split the word into maximal valid segments\n    segments = []\n    start = 0\n    for i in range(1, n):\n        if abs(ord(word[i]) - ord(word[i-1])) > 2:\n            segments.append((start, i-1))\n            start = i\n    segments.append((start, n-1))\n    \n    count = 0\n    \n    # For each valid segment, count complete substrings\n    for start, end in segments:\n        # Length of current segment\n        seg_len = end - start + 1\n        \n        # Try all possible numbers of unique characters: 1 to min(seg_len//k, 26)\n        max_unique = min(seg_len // k, 26)\n        for unique_chars in range(1, max_unique + 1):\n            window_len = unique_chars * k\n            if window_len > seg_len:\n                break\n                \n            # Sliding window of fixed size window_len\n            char_count = defaultdict(int)\n            \n            # Initialize the first window\n            for i in range(start, start + window_len):\n                char_count[word[i]] += 1\n                \n            # Check if first window is complete\n            valid = True\n            for c, cnt in char_count.items():\n                if cnt != k:\n                    valid = False\n                    break\n            if valid:\n                count += 1\n                \n            # Slide the window\n            for i in range(start + window_len, end + 1):\n                # Remove the leftmost character\n                left_char = word[i - window_len]\n                char_count[left_char] -= 1\n                if char_count[left_char] == 0:\n                    del char_count[left_char]\n                    \n                # Add the new right character\n                right_char = word[i]\n                char_count[right_char] += 1\n                \n                # Check if current window is complete\n                valid = True\n                if len(char_count) != unique_chars:\n                    valid = False\n                else:\n                    for c, cnt in char_count.items():\n                        if cnt != k:\n                            valid = False\n                            break\n                if valid:\n                    count += 1\n                    \n    return count\n\ndef main():\n    # Read input\n    word = input().strip()\n    k = int(input().strip())\n    \n    # Compute and print result\n    result = countCompleteSubstrings(word, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "3017",
            "difficulty": "hard",
            "total_time": 17.659561157226562,
            "code_generation_time": 16.647751808166504,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 805,
            "total_output_tokens": 437,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef count_beautiful(high, k):\n    if high == 0:\n        return 0\n    \n    s = str(high)\n    n = len(s)\n    \n    # Memoization dictionary\n    memo = {}\n    \n    def dp(pos, even_count, odd_count, mod, tight, started):\n        if pos == n:\n            if started and even_count == odd_count and mod == 0:\n                return 1\n            return 0\n            \n        if (pos, even_count, odd_count, mod, tight, started) in memo:\n            return memo[(pos, even_count, odd_count, mod, tight, started)]\n        \n        limit = int(s[pos]) if tight else 9\n        res = 0\n        \n        for digit in range(0, limit + 1):\n            new_tight = tight and (digit == limit)\n            new_started = started or (digit > 0)\n            \n            if not new_started:\n                # Leading zeros\n                res += dp(pos + 1, even_count, odd_count, mod, new_tight, new_started)\n            else:\n                # Count even and odd digits\n                new_even_count = even_count + (1 if digit % 2 == 0 else 0)\n                new_odd_count = odd_count + (1 if digit % 2 == 1 else 0)\n                new_mod = (mod * 10 + digit) % k\n                \n                res += dp(pos + 1, new_even_count, new_odd_count, new_mod, new_tight, new_started)\n        \n        memo[(pos, even_count, odd_count, mod, tight, started)] = res\n        return res\n    \n    return dp(0, 0, 0, 0, True, False)\n\ndef solve():\n    low = int(sys.stdin.readline())\n    high = int(sys.stdin.readline())\n    k = int(sys.stdin.readline())\n    \n    result = count_beautiful(high, k) - count_beautiful(low - 1, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc301_a",
            "difficulty": "easy",
            "total_time": 17.640227794647217,
            "code_generation_time": 17.451152324676514,
            "passed_tests": 12,
            "total_tests": 12,
            "success_rate": 1.0,
            "total_input_tokens": 700,
            "total_output_tokens": 305,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(input())\n    S = input().strip()\n    \n    # Count total wins\n    takahashi_wins = S.count('T')\n    aoki_wins = S.count('A')\n    \n    # If one has more wins, that's the winner\n    if takahashi_wins > aoki_wins:\n        print('T')\n        return\n    elif aoki_wins > takahashi_wins:\n        print('A')\n        return\n    \n    # If they're equal, find who reached that number first\n    # We need to find when each player reached the same number of wins\n    t_count = 0\n    a_count = 0\n    \n    for i in range(N):\n        if S[i] == 'T':\n            t_count += 1\n        else:  # S[i] == 'A'\n            a_count += 1\n            \n        # Check if either player has reached the total win count\n        if t_count == takahashi_wins and a_count == aoki_wins:\n            # Both reached at the same time (which means last game)\n            # This shouldn't happen as one must reach first\n            pass\n        elif t_count == takahashi_wins:\n            print('T')\n            return\n        elif a_count == aoki_wins:\n            print('A')\n            return\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3210",
            "difficulty": "medium",
            "total_time": 8.55430817604065,
            "code_generation_time": 7.748271703720093,
            "passed_tests": 97,
            "total_tests": 100,
            "success_rate": 0.97,
            "total_input_tokens": 895,
            "total_output_tokens": 184,
            "error": null,
            "traceback": null,
            "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    s = data[0]\n    k = int(data[1])\n    \n    vowels = set('aeiou')\n    n = len(s)\n    count = 0\n    \n    # For each starting index\n    for i in range(n):\n        vowel_count = 0\n        consonant_count = 0\n        # For each ending index\n        for j in range(i, n):\n            if s[j] in vowels:\n                vowel_count += 1\n            else:\n                consonant_count += 1\n            \n            # Check if beautiful\n            if vowel_count == consonant_count and (vowel_count * consonant_count) % k == 0:\n                count += 1\n                \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3200",
            "difficulty": "medium",
            "total_time": 35.611586570739746,
            "code_generation_time": 34.77475953102112,
            "passed_tests": 87,
            "total_tests": 87,
            "success_rate": 1.0,
            "total_input_tokens": 718,
            "total_output_tokens": 993,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    MOD = 10**9 + 7\n    \n    n = int(sys.stdin.readline())\n    \n    if n < 4:\n        print(0)\n        return\n    \n    # Precompute factorials and inverse factorials\n    max_n = n\n    fact = [1] * (max_n + 1)\n    for i in range(1, max_n + 1):\n        fact[i] = (fact[i-1] * i) % MOD\n    \n    # Function to compute modular inverse using Fermat's little theorem\n    def modinv(x):\n        return pow(x, MOD - 2, MOD)\n    \n    inv_fact = [1] * (max_n + 1)\n    inv_fact[max_n] = modinv(fact[max_n])\n    for i in range(max_n - 1, -1, -1):\n        inv_fact[i] = (inv_fact[i+1] * (i+1)) % MOD\n    \n    # Function to compute nCr\n    def comb(n, r):\n        if r < 0 or r > n:\n            return 0\n        return (fact[n] * inv_fact[r] % MOD) * inv_fact[n-r] % MOD\n    \n    # Inclusion-exclusion principle\n    # We need at least 1 'l', 2 'e's, and 1 't'\n    \n    # Total strings with lowercase letters\n    total = pow(26, n, MOD)\n    \n    # Subtract strings that don't have enough of each required character\n    # A1: strings with no 'l'\n    # A2: strings with <2 'e's (0 or 1 'e')\n    # A3: strings with no 't'\n    \n    # |A1|: no 'l'\n    no_l = pow(25, n, MOD)\n    \n    # |A2|: <2 'e's\n    no_e = pow(25, n, MOD)  # 0 'e's\n    one_e = (n * pow(25, n-1, MOD)) % MOD  # 1 'e'\n    lt_2_e = (no_e + one_e) % MOD\n    \n    # |A3|: no 't'\n    no_t = pow(25, n, MOD)\n    \n    # |A1 \u2229 A2|: no 'l' and <2 'e's\n    no_l_no_e = pow(24, n, MOD)  # no 'l', no 'e'\n    no_l_one_e = (n * pow(24, n-1, MOD)) % MOD  # no 'l', one 'e'\n    no_l_lt_2_e = (no_l_no_e + no_l_one_e) % MOD\n    \n    # |A1 \u2229 A3|: no 'l' and no 't'\n    no_l_no_t = pow(24, n, MOD)\n    \n    # |A2 \u2229 A3|: <2 'e's and no 't'\n    no_t_no_e = pow(24, n, MOD)  # no 'e', no 't'\n    no_t_one_e = (n * pow(24, n-1, MOD)) % MOD  # one 'e', no 't'\n    lt_2_e_no_t = (no_t_no_e + no_t_one_e) % MOD\n    \n    # |A1 \u2229 A2 \u2229 A3|: no 'l', <2 'e's, no 't'\n    no_l_no_t_no_e = pow(23, n, MOD)  # no 'l', no 'e', no 't'\n    no_l_no_t_one_e = (n * pow(23, n-1, MOD)) % MOD  # no 'l', one 'e', no 't'\n    no_l_lt_2_e_no_t = (no_l_no_t_no_e + no_l_no_t_one_e) % MOD\n    \n    # Apply inclusion-exclusion\n    result = total\n    result = (result - no_l) % MOD\n    result = (result - lt_2_e) % MOD\n    result = (result - no_t) % MOD\n    result = (result + no_l_lt_2_e) % MOD\n    result = (result + no_l_no_t) % MOD\n    result = (result + lt_2_e_no_t) % MOD\n    result = (result - no_l_lt_2_e_no_t) % MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc329_c",
            "difficulty": "medium",
            "total_time": 26.827425956726074,
            "code_generation_time": 21.42017650604248,
            "passed_tests": 13,
            "total_tests": 17,
            "success_rate": 0.76,
            "total_input_tokens": 682,
            "total_output_tokens": 214,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline().strip())\n    S = sys.stdin.readline().strip()\n    \n    # Use a set to store unique substrings that are repetitions of one character\n    unique_substrings = set()\n    \n    # Iterate through the string\n    i = 0\n    while i < N:\n        # Count consecutive identical characters\n        j = i\n        while j < N and S[j] == S[i]:\n            j += 1\n        \n        # For a sequence of k identical characters,\n        # we can form k substrings: c, cc, ccc, ..., ccccc...c (k times)\n        # But we only count unique ones, so we add all possible lengths to the set\n        char = S[i]\n        for length in range(1, j - i + 1):\n            unique_substrings.add(char * length)\n        \n        i = j\n    \n    print(len(unique_substrings))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3025",
            "difficulty": "hard",
            "total_time": 30.034315586090088,
            "code_generation_time": 29.17592740058899,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 915,
            "total_output_tokens": 486,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import Counter\n\ndef solve():\n    # Read input\n    nums = list(map(int, sys.stdin.readline().split()))\n    target = int(sys.stdin.readline().strip())\n    \n    # Count frequency of each power of 2\n    count = Counter(nums)\n    \n    # Check if total sum is less than target\n    total_sum = sum(nums)\n    if total_sum < target:\n        print(-1)\n        return\n    \n    operations = 0\n    # Process each bit from least significant to most significant\n    for i in range(31):  # Since nums[i] <= 2^30\n        bit_val = 1 << i  # 2^i\n        \n        # If this bit is not needed in target, continue\n        if (target & bit_val) == 0:\n            # If we have two of current bit, we can combine them to form the next higher bit\n            count[bit_val * 2] = count.get(bit_val * 2, 0) + (count.get(bit_val, 0) // 2)\n            continue\n        \n        # If this bit is needed in target\n        if count.get(bit_val, 0) > 0:\n            # We have this bit, use it\n            count[bit_val] -= 1\n        else:\n            # We don't have this bit, need to create it by breaking down higher bits\n            found = False\n            # Look for a higher bit that we can break down\n            for j in range(i + 1, 31):\n                larger_bit_val = 1 << j\n                if count.get(larger_bit_val, 0) > 0:\n                    # Break down this larger bit\n                    count[larger_bit_val] -= 1\n                    # Add operations: j - i steps to get from 2^j to 2^i\n                    operations += (j - i)\n                    # All intermediate bits get one count each\n                    for k in range(i, j):\n                        count[1 << k] = count.get(1 << k, 0) + 1\n                    found = True\n                    break\n            \n            if not found:\n                print(-1)\n                return\n    \n    print(operations)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc323_d",
            "difficulty": "hard",
            "total_time": 25.130800485610962,
            "code_generation_time": 14.710184812545776,
            "passed_tests": 4,
            "total_tests": 30,
            "success_rate": 0.13,
            "total_input_tokens": 933,
            "total_output_tokens": 307,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    N = int(sys.stdin.readline())\n    slimes = []\n    for _ in range(N):\n        s, c = map(int, sys.stdin.readline().split())\n        slimes.append((s, c))\n    \n    # Group slimes by their size and count total count for each size\n    size_count = defaultdict(int)\n    for s, c in slimes:\n        size_count[s] += c\n    \n    # Convert to list of (size, count) and sort by size\n    sizes = sorted(size_count.keys())\n    \n    # Process each size from smallest to largest\n    for size in sizes:\n        count = size_count[size]\n        # How many pairs can we make?\n        pairs = count // 2\n        if pairs > 0:\n            # These pairs create new slimes of size 2*size\n            size_count[2 * size] += pairs\n            # Remaining slimes of current size\n            size_count[size] = count % 2\n            # If we now have slimes of size 2*size, ensure it's in our sizes list\n            if 2 * size not in sizes:\n                sizes.append(2 * size)\n                sizes.sort()\n    \n    # Count total remaining slimes\n    total_slimes = sum(count for count in size_count.values() if count > 0)\n    print(total_slimes)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc334_e",
            "difficulty": "hard",
            "total_time": 30.57004952430725,
            "code_generation_time": 20.1430401802063,
            "passed_tests": 2,
            "total_tests": 31,
            "success_rate": 0.06,
            "total_input_tokens": 1149,
            "total_output_tokens": 585,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque\n\ndef modinv(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef main():\n    MOD = 998244353\n    H, W = map(int, sys.stdin.readline().split())\n    grid = [sys.stdin.readline().strip() for _ in range(H)]\n    \n    # Count red cells\n    red_cells = []\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '.':\n                red_cells.append((i, j))\n    \n    total_red = len(red_cells)\n    if total_red == 0:\n        # No red cells to repaint, but problem guarantees at least one\n        return\n    \n    # Function to count connected components of green cells\n    def count_components(modified_cell=None):\n        visited = [[False]*W for _ in range(H)]\n        comp_count = 0\n        for i in range(H):\n            for j in range(W):\n                if (i, j) == modified_cell:\n                    color = '#'\n                else:\n                    color = grid[i][j]\n                \n                if color == '#' and not visited[i][j]:\n                    comp_count += 1\n                    queue = deque()\n                    queue.append((i, j))\n                    visited[i][j] = True\n                    while queue:\n                        x, y = queue.popleft()\n                        for dx, dy in [(-1,0),(1,0),(0,-1),(0,1)]:\n                            nx, ny = x + dx, y + dy\n                            if 0 <= nx < H and 0 <= ny < W:\n                                if (nx, ny) == modified_cell:\n                                    ncolor = '#'\n                                else:\n                                    ncolor = grid[nx][ny]\n                                if ncolor == '#' and not visited[nx][ny]:\n                                    visited[nx][ny] = True\n                                    queue.append((nx, ny))\n        return comp_count\n    \n    # Precompute initial components\n    initial_components = count_components()\n    \n    # For each red cell, compute the change in component count\n    total_expectation = 0\n    \n    # We will compute the expected value as sum of component counts / total_red\n    # So we compute sum of component counts, then divide by total_red\n    \n    for cell in red_cells:\n        new_count = count_components(modified_cell=cell)\n        total_expectation = (total_expectation + new_count) % MOD\n    \n    # Now we have sum of component counts. We need to divide by total_red\n    # That is, multiply by modular inverse of total_red\n    result = (total_expectation * modinv(total_red, MOD)) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "abc325_d",
            "difficulty": "hard",
            "total_time": 24.771070957183838,
            "code_generation_time": 21.855339765548706,
            "passed_tests": 13,
            "total_tests": 44,
            "success_rate": 0.3,
            "total_input_tokens": 1021,
            "total_output_tokens": 300,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport heapq\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    products = []\n    index = 1\n    for i in range(N):\n        T = int(data[index])\n        D = int(data[index+1])\n        products.append((T, T + D, i))\n        index += 2\n    \n    # Sort products by their end time\n    products.sort(key=lambda x: x[1])\n    \n    # Priority queue to keep track of the latest possible start times\n    # We'll use a min-heap with negative values to simulate a max-heap\n    heap = []\n    last_print_time = -1\n    \n    for start, end, idx in products:\n        # Remove all items from heap that are no longer valid\n        while heap and -heap[0] > end:\n            heapq.heappop(heap)\n        \n        # Check if we can print this product\n        # The earliest we can print is max(start, last_print_time + 1)\n        earliest_print_time = max(start, last_print_time + 1)\n        \n        if earliest_print_time <= end:\n            # We can print this product\n            last_print_time = earliest_print_time\n            heapq.heappush(heap, -earliest_print_time)\n    \n    print(len(heap))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "3151",
            "difficulty": "medium",
            "total_time": 12.880326509475708,
            "code_generation_time": 12.179545402526855,
            "passed_tests": 0,
            "total_tests": 53,
            "success_rate": 0.0,
            "total_input_tokens": 1030,
            "total_output_tokens": 210,
            "error": null,
            "traceback": null,
            "code": "def solve():\n    import sys\n    import heapq\n\n    # Read input\n    processorTime = list(map(int, sys.stdin.readline().split()))\n    tasks = list(map(int, sys.stdin.readline().split()))\n\n    # Sort processors by availability time (ascending)\n    processorTime.sort()\n    # Sort tasks by duration (descending)\n    tasks.sort(reverse=True)\n\n    n = len(processorTime)\n    max_time = 0\n\n    # For each processor, assign the next 4 longest tasks\n    for i in range(n):\n        processor_available_time = processorTime[i]\n        # Take the 4 longest remaining tasks\n        # Since tasks are sorted descending, take the next 4\n        for j in range(4):\n            task_index = i * 4 + j\n            completion_time = processor_available_time + tasks[task_index]\n            if completion_time > max_time:\n                max_time = completion_time\n\n    print(max_time)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2844",
            "difficulty": "easy",
            "total_time": 16.833383321762085,
            "code_generation_time": 16.02712321281433,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 784,
            "total_output_tokens": 144,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    # Read input\n    nums = list(map(int, sys.stdin.readline().strip()[1:-1].split(',')))\n    \n    n = len(nums)\n    result = 0\n    \n    # Check each position (1-indexed) to see if it divides n\n    for i in range(1, n + 1):\n        if n % i == 0:\n            # i is 1-indexed, but nums is 0-indexed, so we use i-1\n            result += nums[i - 1] * nums[i - 1]\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc341_d",
            "difficulty": "medium",
            "total_time": 19.539385318756104,
            "code_generation_time": 19.238258361816406,
            "passed_tests": 32,
            "total_tests": 32,
            "success_rate": 1.0,
            "total_input_tokens": 759,
            "total_output_tokens": 282,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef lcm(a, b):\n    return a * b // gcd(a, b)\n\ndef count_up_to(x, n, m, lcm_nm):\n    # Count numbers <= x that are divisible by exactly one of n or m\n    # This is (count divisible by n) + (count divisible by m) - 2*(count divisible by both)\n    count_n = x // n\n    count_m = x // m\n    count_both = x // lcm_nm\n    return count_n + count_m - 2 * count_both\n\ndef solve():\n    N, M, K = map(int, sys.stdin.readline().split())\n    \n    # Calculate LCM of N and M\n    L = lcm(N, M)\n    \n    # Binary search for the K-th number\n    left, right = 1, K * max(N, M)\n    \n    while left < right:\n        mid = (left + right) // 2\n        count = count_up_to(mid, N, M, L)\n        if count < K:\n            left = mid + 1\n        else:\n            right = mid\n    \n    print(left)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2816",
            "difficulty": "easy",
            "total_time": 13.416683435440063,
            "code_generation_time": 12.513380765914917,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 728,
            "total_output_tokens": 149,
            "error": null,
            "traceback": null,
            "code": "def solve():\n    s = input().strip()\n    n = len(s)\n    s_list = list(s)\n    \n    # Use two pointers from both ends\n    left = 0\n    right = n - 1\n    \n    while left < right:\n        # If characters don't match, replace both with the lexicographically smaller one\n        if s_list[left] != s_list[right]:\n            smaller_char = min(s_list[left], s_list[right])\n            s_list[left] = smaller_char\n            s_list[right] = smaller_char\n        left += 1\n        right -= 1\n    \n    print(''.join(s_list))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc343_d",
            "difficulty": "medium",
            "total_time": 17.220447063446045,
            "code_generation_time": 15.591739177703857,
            "passed_tests": 19,
            "total_tests": 19,
            "success_rate": 1.0,
            "total_input_tokens": 1297,
            "total_output_tokens": 277,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    T = int(data[1])\n    \n    # Read all updates\n    updates = []\n    idx = 2\n    for _ in range(T):\n        A = int(data[idx])\n        B = int(data[idx+1])\n        updates.append((A, B))\n        idx += 2\n    \n    # Initialize scores and frequency map\n    scores = [0] * (N+1)  # 1-indexed\n    freq = defaultdict(int)\n    freq[0] = N  # Initially all N players have score 0\n    \n    results = []\n    \n    for A, B in updates:\n        old_score = scores[A]\n        new_score = old_score + B\n        scores[A] = new_score\n        \n        # Update frequency map\n        freq[old_score] -= 1\n        if freq[old_score] == 0:\n            del freq[old_score]\n        \n        freq[new_score] += 1\n        \n        # Number of distinct scores\n        results.append(len(freq))\n    \n    # Output results\n    for res in results:\n        print(res)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "abc305_e",
            "difficulty": "hard",
            "total_time": 28.990267992019653,
            "code_generation_time": 18.897120237350464,
            "passed_tests": 13,
            "total_tests": 31,
            "success_rate": 0.42,
            "total_input_tokens": 1260,
            "total_output_tokens": 423,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque, defaultdict\n\ndef solve():\n    import sys\n    from collections import deque, defaultdict\n\n    input = sys.stdin.read\n    data = input().split()\n    \n    idx = 0\n    N = int(data[idx]); idx += 1\n    M = int(data[idx]); idx += 1\n    K = int(data[idx]); idx += 1\n    \n    # Build adjacency list\n    adj = defaultdict(list)\n    for _ in range(M):\n        a = int(data[idx]) - 1; idx += 1\n        b = int(data[idx]) - 1; idx += 1\n        adj[a].append(b)\n        adj[b].append(a)\n    \n    # Read guards\n    guards = []\n    for _ in range(K):\n        p = int(data[idx]) - 1; idx += 1\n        h = int(data[idx]); idx += 1\n        guards.append((p, h))\n    \n    # BFS from each guard up to their stamina\n    guarded = [False] * N\n    for p, h in guards:\n        if h < 0:\n            continue\n        queue = deque()\n        queue.append((p, 0))\n        visited = [-1] * N\n        visited[p] = 0\n        if 0 <= h:\n            guarded[p] = True\n        while queue:\n            u, dist = queue.popleft()\n            if dist >= h:\n                continue\n            for v in adj[u]:\n                if visited[v] == -1:\n                    visited[v] = dist + 1\n                    guarded[v] = True\n                    queue.append((v, dist + 1))\n    \n    # Collect guarded vertices\n    result = []\n    for i in range(N):\n        if guarded[i]:\n            result.append(i + 1)\n    \n    print(len(result))\n    if result:\n        print(' '.join(map(str, result)))\n    else:\n        print()\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc311_c",
            "difficulty": "medium",
            "total_time": 20.170995712280273,
            "code_generation_time": 19.18155813217163,
            "passed_tests": 14,
            "total_tests": 51,
            "success_rate": 0.27,
            "total_input_tokens": 1036,
            "total_output_tokens": 303,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    # Convert to 0-indexed\n    adj = [a - 1 for a in A]\n    \n    # Track visited status: 0 = unvisited, 1 = in current path, 2 = processed\n    visited = [0] * N\n    parent = [-1] * N\n    \n    # DFS to find a cycle\n    for start in range(N):\n        if visited[start] == 0:\n            current = start\n            path = []\n            path_indices = {}\n            \n            # Follow the path until we hit a visited node\n            while visited[current] == 0:\n                visited[current] = 1\n                path.append(current)\n                path_indices[current] = len(path) - 1\n                parent[current] = len(path) - 1\n                current = adj[current]\n            \n            # If we found a cycle (hit a node in current path)\n            if visited[current] == 1:\n                # The cycle starts at 'current'\n                cycle_start_idx = path_indices[current]\n                cycle = path[cycle_start_idx:]\n                \n                # Convert back to 1-indexed and output\n                print(len(cycle))\n                print(' '.join(str(x + 1) for x in cycle))\n                return\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc326_e",
            "difficulty": "hard",
            "total_time": 23.80694842338562,
            "code_generation_time": 21.38988447189331,
            "passed_tests": 1,
            "total_tests": 27,
            "success_rate": 0.04,
            "total_input_tokens": 1135,
            "total_output_tokens": 635,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef modinv(a, mod):\n    return pow(a, mod - 2, mod)\n\ndef main():\n    MOD = 998244353\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    # We will compute E[x] for x = 1 to N\n    # E[x] = (1/N) * (sum_{y=x+1}^N (A[y] + E[y]) + sum_{y=1}^x E[x])\n    # E[x] = (1/N) * (sum_{y=x+1}^N A[y] + sum_{y=x+1}^N E[y] + x * E[x])\n    # E[x] = (1/N) * (S_A[x+1] + S_E[x+1] + x * E[x]) where S_A and S_E are suffix sums\n    # N * E[x] = S_A[x+1] + S_E[x+1] + x * E[x]\n    # (N - x) * E[x] = S_A[x+1] + S_E[x+1]\n    # E[x] = (S_A[x+1] + S_E[x+1]) / (N - x)\n    \n    # For x = N, E[N] = (1/N) * (A[N] + (N-1)*E[N])\n    # N * E[N] = A[N] + (N-1) * E[N]\n    # E[N] = A[N]\n    \n    E = [0] * (N + 2)  # E[N+1] = 0\n    S_E = 0  # Suffix sum of E\n    S_A = 0  # Suffix sum of A\n    \n    for x in range(N, 0, -1):\n        # S_A is sum of A[y] for y = x+1 to N\n        # S_E is sum of E[y] for y = x+1 to N\n        if x == N:\n            E[x] = A[x-1]\n        else:\n            numerator = (S_A + S_E) % MOD\n            denominator = (N - x) % MOD\n            E[x] = (numerator * modinv(denominator, MOD)) % MOD\n        \n        S_E = (S_E + E[x]) % MOD\n        S_A = (S_A + A[x-1]) % MOD\n    \n    # The answer is E[0] = (1/N) * (sum_{y=1}^N (A[y] + E[y]))\n    total = 0\n    for i in range(N):\n        total = (total + A[i] + E[i+1]) % MOD\n    \n    result = (total * modinv(N, MOD)) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "3298",
            "difficulty": "hard",
            "total_time": 17.52121067047119,
            "code_generation_time": 16.54887104034424,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 676,
            "total_output_tokens": 213,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n = int(sys.stdin.readline())\n    nums = list(map(int, sys.stdin.readline().split()))\n    \n    # Sort the array to process in order\n    nums.sort()\n    \n    # dp[v] represents the maximum length of consecutive sequence ending at value v\n    dp = defaultdict(int)\n    \n    for num in nums:\n        # We can either keep the number as is or increase it by 1\n        # If we keep it as is, we try to extend sequence ending at num-1\n        # If we increase it by 1, we try to extend sequence ending at num\n        dp[num + 1] = max(dp[num + 1], dp[num] + 1)\n        dp[num] = max(dp[num], dp[num - 1] + 1)\n    \n    # Return the maximum value in dp\n    return max(dp.values())\n\nif __name__ == \"__main__\":\n    result = solve()\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "2824",
            "difficulty": "easy",
            "total_time": 18.518937826156616,
            "code_generation_time": 17.674177885055542,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 655,
            "total_output_tokens": 223,
            "error": null,
            "traceback": null,
            "code": "def is_fascinating(n):\n    # Calculate 2*n and 3*n\n    double_n = 2 * n\n    triple_n = 3 * n\n    \n    # Concatenate the three numbers as strings\n    concatenated = str(n) + str(double_n) + str(triple_n)\n    \n    # Check if the concatenated string has exactly 9 digits\n    if len(concatenated) != 9:\n        return False\n    \n    # Check if it contains all digits from 1 to 9 exactly once and no 0s\n    digit_set = set(concatenated)\n    \n    # It should not contain '0'\n    if '0' in digit_set:\n        return False\n    \n    # It should contain exactly the digits 1-9\n    return digit_set == set('123456789')\n\ndef solve():\n    n = int(input().strip())\n    result = is_fascinating(n)\n    print(\"true\" if result else \"false\")\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc313_c",
            "difficulty": "medium",
            "total_time": 46.8533399105072,
            "code_generation_time": 46.09999871253967,
            "passed_tests": 27,
            "total_tests": 27,
            "success_rate": 1.0,
            "total_input_tokens": 869,
            "total_output_tokens": 279,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport math\n\ndef solve():\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    if N == 1:\n        print(0)\n        return\n    \n    total = sum(A)\n    target_low = total // N\n    target_high = target_low + 1\n    \n    # Calculate operations needed to make all elements equal to target_low or target_high\n    # In optimal distribution, some elements will be target_low and some target_high\n    # The number of high targets is total % N\n    high_count = total % N\n    low_count = N - high_count\n    \n    # Create target array: low_count elements of target_low, high_count elements of target_high\n    targets = [target_low] * low_count + [target_high] * high_count\n    \n    # Sort A to match with sorted targets optimally\n    A.sort()\n    \n    # Calculate total operations needed\n    operations = 0\n    for i in range(N):\n        operations += abs(A[i] - targets[i])\n    \n    # Since each operation moves 1 unit, and we're counting absolute differences,\n    # we need to divide by 2 (as each operation affects two elements)\n    print(operations // 2)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc307_e",
            "difficulty": "hard",
            "total_time": 44.186405420303345,
            "code_generation_time": 43.81443476676941,
            "passed_tests": 1,
            "total_tests": 21,
            "success_rate": 0.05,
            "total_input_tokens": 739,
            "total_output_tokens": 366,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    MOD = 998244353\n    \n    def pow_mod(base, exp, mod):\n        result = 1\n        base %= mod\n        while exp > 0:\n            if exp & 1:\n                result = result * base % mod\n            base = base * base % mod\n            exp >>= 1\n        return result\n    \n    N, M = map(int, sys.stdin.readline().split())\n    \n    if M == 1:\n        print(0)\n        return\n    \n    if N == 1:\n        print(M % MOD)\n        return\n    \n    # For a circle:\n    # Let f(n) be the number of ways to color a path of length n with M colors\n    # such that no two adjacent nodes have the same color.\n    # f(n) = M * (M-1)^(n-1)\n    #\n    # Let g(n) be the number of ways to color a cycle of length n with M colors\n    # such that no two adjacent nodes have the same color.\n    #\n    # For the cycle, we can use inclusion-exclusion or direct formula:\n    # g(n) = (M-1)^n + (-1)^n * (M-1)\n    \n    base = M - 1\n    power_n = pow_mod(base, N, MOD)\n    \n    if N % 2 == 0:\n        result = (power_n + base) % MOD\n    else:\n        result = (power_n - base + MOD) % MOD\n        \n    # Multiply by M for the first choice\n    result = result * M % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        }
    ]
}
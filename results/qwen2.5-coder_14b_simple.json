{
    "model": "qwen2.5-coder:14b",
    "architecture": "simple",
    "total_test_time": 1677.3274700641632,
    "total_input_tokens": 86777,
    "total_output_tokens": 32858,
    "score": 25.292592592592595,
    "tokens_per_second": 19.589496139798555,
    "difficulty_stats": {
        "easy": {
            "total": 30,
            "passed": 12,
            "percentage": 40.0
        },
        "medium": {
            "total": 30,
            "passed": 4,
            "percentage": 13.333333333333334
        },
        "hard": {
            "total": 30,
            "passed": 2,
            "percentage": 6.666666666666667
        }
    },
    "completed_at": "2025-12-03T14:52:49.340902",
    "results": [
        {
            "question_id": "abc341_b",
            "difficulty": "easy",
            "total_time": 22.208565950393677,
            "code_generation_time": 21.096834659576416,
            "passed_tests": 0,
            "total_tests": 22,
            "success_rate": 0.0,
            "total_input_tokens": 1116,
            "total_output_tokens": 534,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    \n    def main():\n        N = int(sys.stdin.readline().strip())\n        \n        # Read initial amounts\n        A = list(map(int, sys.stdin.readline().split()))\n        \n        # Read exchange rates\n        S_T_pairs = []\n        for _ in range(N - 1):\n            Si, Ti = map(int, sys.stdin.readline().split())\n            S_T_pairs.append((Si, Ti))\n    \n        max_units_Nth_country = [A[-1]]\n        current_amounts = A[:-1]\n        \n        for i in reversed(range(1, N)):\n            Si, Ti = S_T_pairs[i - 1]\n            \n            while current_amounts[i - 1] >= Si:\n                current_amounts[i - 1] -= Si\n                current_amounts[i] += Ti\n            \n            if i > 1:\n                current_amounts[i - 1] += max_units_Nth_country[0]\n                \n            max_units_Nth_country.insert(0, current_amounts[i])\n        \n        print(max_units_Nth_country[0])\n\n    if __name__ == \"__main__\":\n        main()\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "1899_B",
            "difficulty": "hard",
            "total_time": 18.02196216583252,
            "code_generation_time": 17.17170810699463,
            "passed_tests": 39,
            "total_tests": 39,
            "success_rate": 1.0,
            "total_input_tokens": 1399,
            "total_output_tokens": 381,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    \n    def max_difference(n, a):\n        prefix_sums = [0] * (n + 1)\n        for i in range(1, n + 1):\n            prefix_sums[i] = prefix_sums[i - 1] + a[i - 1]\n        \n        max_diff = 0\n        \n        # Check all possible k values\n        for k in range(1, n // 2 + 1):\n            if n % k == 0:\n                num_trucks = n // k\n                min_weight = float('inf')\n                max_weight = float('-inf')\n                \n                for j in range(num_trucks):\n                    truck_start = j * k\n                    truck_end = (j + 1) * k\n                    truck_weight = prefix_sums[truck_end] - prefix_sums[truck_start]\n                    \n                    min_weight = min(min_weight, truck_weight)\n                    max_weight = max(max_weight, truck_weight)\n                \n                max_diff = max(max_diff, abs(max_weight - min_weight))\n        \n        return max_diff\n    \n    t = int(sys.stdin.readline())\n    \n    results = []\n    for _ in range(t):\n        n = int(sys.stdin.readline().strip())\n        a = list(map(int, sys.stdin.readline().split()))\n        result = max_difference(n, a)\n        results.append(result)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc332_b",
            "difficulty": "easy",
            "total_time": 13.717466115951538,
            "code_generation_time": 13.399755716323853,
            "passed_tests": 30,
            "total_tests": 30,
            "success_rate": 1.0,
            "total_input_tokens": 930,
            "total_output_tokens": 262,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    \n    def simulate_operations(K, G, M):\n        # Initial state\n        glass = 0\n        mug = 0\n        \n        for _ in range(K):\n            if glass == G:\n                # If the glass is full, discard its contents\n                glass = 0\n            elif mug == 0:\n                # If the mug is empty, fill it up\n                mug = M\n            else:\n                # Otherwise, transfer water from the mug to the glass\n                amount_to_transfer = min(mug, G - glass)\n                glass += amount_to_transfer\n                mug -= amount_to_transfer\n        \n        return glass, mug\n    \n    K, G, M = map(int, input().split())\n    \n    final_glass_amount, final_mug_amount = simulate_operations(K, G, M)\n    \n    print(final_glass_amount, final_mug_amount)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc337_e",
            "difficulty": "hard",
            "total_time": 18.028979778289795,
            "code_generation_time": 17.80241823196411,
            "passed_tests": 0,
            "total_tests": 25,
            "success_rate": 0.0,
            "total_input_tokens": 1322,
            "total_output_tokens": 266,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import math\n    \n    # Read N from standard input\n    N = int(sys.stdin.readline().strip())\n    \n    # Calculate the minimum number of friends needed using binary representation\n    M = math.ceil(math.log2(N))\n    \n    # Print the number of friends\n    print(M)\n    \n    # Distribute the juices based on binary representation\n    distributions = []\n    for i in range(1, M + 1):\n        distribution = [j + 1 for j in range(N) if (j >> (M - i)) & 1]\n        distributions.append(distribution)\n        print(len(distribution), *distribution)\n    \n    # Receive responses from the judge\n    results = sys.stdin.readline().strip()\n    \n    # Determine which bottle is bad\n    spoiled_bottle = sum((int(results[i]) << (M - i - 1)) for i in range(M))\n    \n    # Output the result\n    print(spoiled_bottle)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3207",
            "difficulty": "easy",
            "total_time": 15.327560663223267,
            "code_generation_time": 14.605502843856812,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 643,
            "total_output_tokens": 307,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef find_common_prefix_length(s1, s2, s3):\n    min_len = min(len(s1), len(s2), len(s3))\n    common_length = 0\n    \n    for i in range(min_len):\n        if s1[i] == s2[i] == s3[i]:\n            common_length += 1\n        else:\n            break\n            \n    return common_length\n\ndef calculate_operations_needed(s1, s2, s3):\n    common_length = find_common_prefix_length(s1, s2, s3)\n    \n    if common_length == 0:\n        return -1\n    \n    total_chars_to_remove = sum(len(s) for s in [s1, s2, s3]) - 3 * common_length\n    return total_chars_to_remove\n\nif __name__ == \"__main__\":\n    import sys\n    input = lambda : sys.stdin.readline().strip()\n    \n    s1 = input()\n    s2 = input()\n    s3 = input()\n    \n    result = calculate_operations_needed(s1, s2, s3)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "2837",
            "difficulty": "medium",
            "total_time": 13.887906551361084,
            "code_generation_time": 13.075786828994751,
            "passed_tests": 32,
            "total_tests": 100,
            "success_rate": 0.32,
            "total_input_tokens": 697,
            "total_output_tokens": 259,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef min_operations(num1, num2):\n    if num1 < num2:\n        return -1\n    \n    target = num1 - num2 * k\n    count_ones = bin(target).count('1')\n    \n    while target >= k and count_ones > k:\n        k += 1\n        target -= num2\n        count_ones = bin(target).count('1')\n    \n    if target >= 0 and count_ones == k:\n        return k\n    else:\n        return -1\n\nif __name__ == \"__main__\":\n    import sys\n    input = lambda: sys.stdin.readline().strip()\n    \n    num1 = int(input())\n    num2 = int(input())\n    \n    result = min_operations(num1, num2)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "3331",
            "difficulty": "easy",
            "total_time": 12.38688349723816,
            "code_generation_time": 11.72653865814209,
            "passed_tests": 0,
            "total_tests": 57,
            "success_rate": 0.0,
            "total_input_tokens": 802,
            "total_output_tokens": 187,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    # Read input\n    n = int(sys.stdin.readline())\n    nums = list(map(int, sys.stdin.readline().split()))\n    k = int(sys.stdin.readline())\n    \n    # Use a min-heap to efficiently get and remove the smallest elements\n    heapq.heapify(nums)\n    \n    count_operations = 0\n    while nums[0] < k:\n        heapq.heappop(nums)  # Remove the smallest element\n        count_operations += 1\n    \n    print(count_operations)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc322_e",
            "difficulty": "hard",
            "total_time": 21.606608867645264,
            "code_generation_time": 15.950481176376343,
            "passed_tests": 17,
            "total_tests": 44,
            "success_rate": 0.39,
            "total_input_tokens": 1048,
            "total_output_tokens": 349,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom itertools import combinations\n\ndef solve():\n    import sys\n    \n    def can_achieve_goal(selected_plans):\n        current_values = [0] * K\n        for plan_index in selected_plans:\n            c, *a = plans[plan_index]\n            for j in range(K):\n                current_values[j] += a[j]\n        \n        return all(value >= P for value in current_values)\n    \n    N, K, P = map(int, input().split())\n    plans = []\n    for _ in range(N):\n        line = list(map(int, input().split()))\n        C = line[0]\n        A = line[1:]\n        plans.append((C, *A))\n    \n    min_cost = float('inf')\n    found_solution = False\n    \n    # Check all possible subsets of development plans\n    for r in range(1, N+1):\n        if not found_solution and sum(plan[0] for plan in plans) < min_cost:\n            for subset in combinations(range(N), r):\n                if can_achieve_goal(subset):\n                    cost = sum(plans[i][0] for i in subset)\n                    if cost < min_cost:\n                        min_cost = cost\n                        found_solution = True\n    \n    if found_solution:\n        print(min_cost)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc315_f",
            "difficulty": "hard",
            "total_time": 44.00541400909424,
            "code_generation_time": 23.228413105010986,
            "passed_tests": 0,
            "total_tests": 66,
            "success_rate": 0.0,
            "total_input_tokens": 1193,
            "total_output_tokens": 612,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom math import sqrt\n\ndef euclidean_distance(x1, y1, x2, y2):\n    return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef solve():\n    N = int(sys.stdin.readline())\n    \n    checkpoints = []\n    for _ in range(N):\n        X, Y = map(int, sys.stdin.readline().split())\n        checkpoints.append((X, Y))\n    \n    # Calculate distances between consecutive points and store them with their indices\n    dists_with_indices = [(euclidean_distance(checkpoints[i][0], checkpoints[i][1], checkpoints[j][0], checkpoints[j][1]), i+1, j-1)\n                          for i in range(1, len(checkpoints)-1) for j in range(i+2, len(checkpoints))]\n    \n    # Sort by distance descendingly so we can use a greedy approach starting from skipping no one\n    dists_with_indices.sort(reverse=True)\n    \n    min_cost = float('inf')\n    visited = set()\n    skipped_count = [0] * N\n    \n    def dfs(current_index, current_penalty, total_dist):\n        nonlocal min_cost\n        \n        if current_index == N-1:\n            cost = total_dist + (current_penalty if current_penalty > 0 else 0)\n            min_cost = min(min_cost, cost)\n            return\n        \n        next_checkpoint_options = [\n            (i, d) for d, start_i, end_j in dists_with_indices\n                  if start_i <= current_index < end_j and not any(skipped_count[k] >= 2 for k in range(start_i, end_j))]\n\n        for option in sorted(next_checkpoint_options, key=lambda o: (-o[1])):  # Prioritize longer jumps first\n            _, jump_length = option\n            \n            new_skips = list(skipped_count[:])\n            \n            for idx_to_skip in range(jump_length):  \n                skip_idx = current_index + idx_to_skip + 1\n                \n                if skip_idx != N-1 and skip_idx not in visited:\n                    new_skips[idx_to_skip] += 1\n                    \n            penalty_increase = sum([max(new_skips[x]-skipped_count[x], 0)*pow(2,x-skipped_count[x]) for x in range(len(new_skips))])\n\n            dfs(option[0]+jump_length, max(penalty_increase,current_penalty), \n                 total_dist+jumps[(option[0], option[0]+jump_length)])\n        \n    # Precompute all possible direct jumps to avoid recomputation during DFS.\n    jumps = {}\n    for i in range(N-1):\n        jumps.update({(i,i+1): euclidean_distance(*checkpoints[i],*checkpoints[i+1]),\n                     })\n                    \n    dfs(-1, 0, 0)\n\n    print(f\"{min_cost:.5f}\")\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc335_a",
            "difficulty": "easy",
            "total_time": 8.87379789352417,
            "code_generation_time": 8.645843982696533,
            "passed_tests": 17,
            "total_tests": 17,
            "success_rate": 1.0,
            "total_input_tokens": 678,
            "total_output_tokens": 79,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    if s.endswith(\"2023\"):\n        result = s[:-1] + \"4\"\n    else:\n        raise ValueError(\"Invalid input: The string does not end with '2023'\")\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc304_b",
            "difficulty": "easy",
            "total_time": 13.180713176727295,
            "code_generation_time": 12.966997861862183,
            "passed_tests": 5,
            "total_tests": 18,
            "success_rate": 0.28,
            "total_input_tokens": 859,
            "total_output_tokens": 247,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import math\n    \n    # Read input\n    N = int(sys.stdin.readline().strip())\n    \n    if N <= 10**3 - 1:\n        print(N)\n    elif N < 10**4:\n        print(int(math.floor(N / 10)))\n    elif N < 10**5:\n        print(int(math.floor(N / 100)))\n    elif N < 10**6:\n        print(int(math.floor(N / 1000)))\n    elif N < 10**7:\n        print(int(math.floor(N / 10000)))\n    elif N < 10**8:\n        print(int(math.floor(N / 100000)))\n    else:\n        print(int(math.floor(N / 1000000)))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc341_a",
            "difficulty": "easy",
            "total_time": 8.020618915557861,
            "code_generation_time": 7.883516073226929,
            "passed_tests": 9,
            "total_tests": 9,
            "success_rate": 1.0,
            "total_input_tokens": 580,
            "total_output_tokens": 69,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef generate_alternating_string(N):\n    return \"1\" + (\"01\") * N\n\ndef main():\n    import sys\n    N = int(sys.stdin.read().strip())\n    result = generate_alternating_string(N)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "2877",
            "difficulty": "medium",
            "total_time": 16.13068985939026,
            "code_generation_time": 15.29460096359253,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 743,
            "total_output_tokens": 362,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef overlap(a, b):\n    \"\"\"Find the maximum overlap between two strings.\"\"\"\n    max_overlap = 0\n    for i in range(1, min(len(a), len(b)) + 1):\n        if a[-i:] == b[:i]:\n            max_overlap = i\n    return max_overlap\n\ndef merge_with_min_length(s1, s2):\n    \"\"\"Merge two strings with minimal additional characters.\"\"\"\n    best_merge = s1 + s2\n    for i in range(overlap(s1, s2)):\n        candidate = s1[:-i] + s2\n        if len(candidate) < len(best_merge):\n            best_merge = candidate\n    return best_merge\n\ndef solve():\n    import itertools\n    \n    # Read input\n    lines = []\n    while True:\n        line = sys.stdin.readline().strip()\n        if not line:\n            break\n        lines.append(line)\n    \n    a, b, c = lines\n    \n    # Generate all permutations of merging three strings\n    candidates = [\n        merge_with_min_length(\n            merge_with_min_length(x, y),\n            z\n        )\n        for x, y, z in itertools.permutations([a, b, c])\n    ]\n    \n    # Find the shortest and then lexicographically smallest result\n    answer = min(candidates, key=lambda s: (len(s), s))\n    \n    # Print the result\n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2878",
            "difficulty": "medium",
            "total_time": 18.907730102539062,
            "code_generation_time": 18.13236117362976,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 691,
            "total_output_tokens": 462,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef can_make_zero(nums, k):\n    n = len(nums)\n    \n    # If we have fewer than k elements, it's impossible to perform any operation\n    if n < k:\n        return False\n    \n    # Create a difference array to track changes in values\n    diff = [nums[0]] + [0] * (n - 1)\n    \n    for i in range(1, n):\n        diff[i] += diff[i - 1]\n    \n    # Apply the operations using the prefix sum approach\n    for i in range(n):\n        current_value = diff[i]\n        \n        # If the value at this position is zero, no need to change anything here\n        if current_value == 0:\n            continue\n        \n        # Check if there are enough remaining positions to apply the operation\n        if i > n - k:\n            return False\n        \n        # Decrease the next k elements by current_value\n        diff[i] -= current_value\n        if i + k < n:\n            diff[i + k] += current_value\n    \n    # Finally check if all numbers became zero after applying all operations\n    final_values = []\n    cumulative_sum = 0\n    for d in diff:\n        cumulative_sum += d\n        final_values.append(cumulative_sum)\n    \n    return all(x == 0 for x in final_values)\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().split()\n    nums = list(map(int, input_data[:-1]))\n    k = int(input_data[-1])\n    \n    result = \"true\" if can_make_zero(nums, k) else \"false\"\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "3263",
            "difficulty": "easy",
            "total_time": 13.739308595657349,
            "code_generation_time": 12.830394506454468,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 827,
            "total_output_tokens": 245,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    # Read input\n    line = sys.stdin.readline().strip()\n    if not line:\n        return\n    nums = list(map(int, line.split()))\n    \n    # First element is always part of one subarray's cost\n    first_element_cost = nums[0]\n    \n    # We need two more elements with the smallest values after the first element\n    min_heap = []\n    for num in nums[1:]:\n        heapq.heappush(min_heap, num)\n    \n    second_min_cost = heapq.heappop(min_heap)\n    third_min_cost = heapq.heappop(min_heap) if len(nums) > 2 else float('inf')\n    \n    # Calculate the minimum sum of costs\n    result = first_element_cost + second_min_cost + third_min_cost\n    \n    # Print the result\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc339_d",
            "difficulty": "medium",
            "total_time": 20.817573308944702,
            "code_generation_time": 20.225741624832153,
            "passed_tests": 0,
            "total_tests": 52,
            "success_rate": 0.0,
            "total_input_tokens": 994,
            "total_output_tokens": 516,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque\n\ndef parse_input():\n    import sys\n    data = []\n    while True:\n        line = sys.stdin.readline().strip()\n        if not line:\n            break\n        data.append(line)\n    return data\n\ndef find_players(grid):\n    positions = [(i, j) for i in range(len(grid)) for j in range(len(grid[0])) if grid[i][j] == 'P']\n    return tuple(positions)\n\ndef bfs(start_pos, end_pos, grid):\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    queue = deque([(start_pos, 0)])\n    visited = set([start_pos])\n    \n    while queue:\n        pos, steps = queue.popleft()\n        \n        # Check all possible movements of both players simultaneously\n        x1, y1 = start_pos\n        x2, y2 = end_pos\n        \n        new_positions = [\n            ((x + dx, y + dy), (ex + dx, ey + dy))\n            for dx, dy in directions\n            if 0 <= x + dx < len(grid) and 0 <= y + dy < len(grid[0]) and grid[x + dx][y + dy] != '#'\n            and 0 <= ex + dx < len(grid) and 0 <= ey + dy < len(grid[0]) and grid[ex + dx][ey + dy] != '#'            \n        ]\n        \n        for np1, np2 in new_positions:\n            if np1 == np2:\n                return steps + 1\n            \n            key = (np1, np2)\n            if key not in visited:\n                visited.add(key)\n                queue.append((key, steps + 1))\n\n    return float('inf')\n\ndef solve():\n    N = int(sys.stdin.readline())\n    grid = [sys.stdin.readline().strip() for _ in range(N)]\n\n    player1_start, player2_start = find_players(grid)\n    result = bfs(player1_start, player2_start, grid)\n    \n    if result == float('inf'):\n        print('-1')\n    else:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3309",
            "difficulty": "easy",
            "total_time": 10.93604564666748,
            "code_generation_time": 10.06645679473877,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 883,
            "total_output_tokens": 137,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    \n    def is_prefix_and_suffix(str1, str2):\n        return str1 == str2[:len(str1)] and str1 == str2[-len(str1):]\n    \n    n = int(sys.stdin.readline().strip())\n    words = [sys.stdin.readline().strip() for _ in range(n)]\n    \n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if is_prefix_and_suffix(words[i], words[j]):\n                count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2873",
            "difficulty": "medium",
            "total_time": 15.001645803451538,
            "code_generation_time": 13.871944427490234,
            "passed_tests": 94,
            "total_tests": 94,
            "success_rate": 1.0,
            "total_input_tokens": 614,
            "total_output_tokens": 293,
            "error": null,
            "traceback": null,
            "code": "import math\nimport sys\n\ndef sieve_of_eratosthenes(max_num):\n    \"\"\"Returns a boolean list where True indicates a prime number.\"\"\"\n    is_prime = [True] * (max_num + 1)\n    p = 2\n    while (p * p <= max_num):\n        if (is_prime[p] == True):\n            for i in range(p * p, max_num + 1, p):\n                is_prime[i] = False\n        p += 1\n    is_prime[0] = is_prime[1] = False\n    return is_prime\n\ndef find_prime_pairs(n):\n    primes = sieve_of_eratosthenes(n)\n    result = []\n\n    for x in range(2, n // 2 + 1):\n        if primes[x]:\n            y = n - x\n            if y >= x and primes[y]:\n                result.append([x, y])\n    \n    return result\n\nif __name__ == \"__main__\":\n    import sys\n    \n    def input():\n        return sys.stdin.readline().strip()\n    \n    n = int(input())\n    prime_pairs = find_prime_pairs(n)\n    print(prime_pairs)",
            "history_file": null
        },
        {
            "question_id": "abc322_a",
            "difficulty": "easy",
            "total_time": 9.143434762954712,
            "code_generation_time": 9.030213594436646,
            "passed_tests": 8,
            "total_tests": 8,
            "success_rate": 1.0,
            "total_input_tokens": 678,
            "total_output_tokens": 105,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    \n    def main():\n        import sys\n        \n        N = int(sys.stdin.readline().strip())\n        S = sys.stdin.readline().strip()\n        \n        for i in range(N - 2):\n            if S[i:i + 3] == \"ABC\":\n                print(i + 1)\n                return\n        print(-1)\n    \n    if __name__ == \"__main__\":\n        main()\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3203",
            "difficulty": "hard",
            "total_time": 26.285348415374756,
            "code_generation_time": 25.722227334976196,
            "passed_tests": 0,
            "total_tests": 79,
            "success_rate": 0.0,
            "total_input_tokens": 1329,
            "total_output_tokens": 684,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import collections\n    \n    def can_form_palindrome(freq):\n        odd_count = sum(1 for count in freq.values() if count % 2 != 0)\n        return odd_count <= 2\n    \n    def get_frequency(s):\n        return collections.Counter(s)\n    \n    def process_query(query, left_freq, right_freq):\n        a, b, c, d = query\n        \n        # Extract frequencies within the ranges\n        left_range_freq = {}\n        right_range_freq = {}\n        \n        for char in range(a, b + 1):\n            left_char = s[char]\n            left_range_freq[left_char] += 1\n            \n        for char in range(c, d + 1):\n            right_char = s[char]\n            right_range_freq[right_char] -= 1\n        \n        # Adjust overall frequency based on current operations\n        adjusted_left_freq = {char: left_freq.get(char, 0) - left_range_freq.get(char, 0) for char in set(left_freq)}\n        adjusted_right_freq = {char: right_freq.get(char, 0) - right_range_freq.get(char, 0) for char in set(right_freq)}\n        \n        combined_freq = adjusted_left_freq.copy()\n        combined_freq.update({char: value for char, value in adjusted_right_freq.items()})\n        \n        return can_form_palindrome(combined_freq)\n    \n    input_data = sys.stdin.read().splitlines()\n    s = input_data[0].strip()\n    q = int(input_data[1])\n    queries = []\n    \n    index = 2\n    while len(queries) < q:\n        line = list(map(int, input_data[index].split()))\n        queries.append(line)\n        index += 1\n    \n    n = len(s)\n    half_n = n // 2\n    \n    left_half = s[:half_n]\n    right_half_reversed = s[half_n:]\n    \n    left_prefix_sum = [collections.defaultdict(int)]\n    right_suffix_sum = [collections.defaultdict(int)]\n    \n    curr_freq = collections.defaultdict(int)\n    for i, char in enumerate(left_half):\n        curr_freq[char] += 1\n        left_prefix_sum.append(curr_freq.copy())\n    \n    curr_freq = collections.defaultdict(int)\n    for j in reversed(range(half_n)):\n        curr_freq[s[j]] += 1\n        right_suffix_sum.insert(0, curr_freq.copy())\n    \n    result = []\n    \n    for query in queries:\n        a, b, c, d = map(lambda x: max(x, 0), query)\n        a, b = min(max(b, a), half_n-1), min(max(a, b), half_n-1)\n        c, d = min(d+1-halfln, half_n), min(min(c,d)+1-half_n,half_n)\n\n        if (b-a+1)%2==0 and (d-c+1)%2==0:\n            lfreq=left_prefix_sum[b+1].copy() \n            rfreq=right_suffix_sum[c].copy()\n\n            ans=True\n\n            for ch in string.ascii_lowercase:\n                cnt=(lfreq[ch]-rfreq[ch])%2\n                if cnt>0:\n                    ans=False\n                    break\n            \n            print(\"YES\" if ans else \"NO\")",
            "history_file": null
        },
        {
            "question_id": "3297",
            "difficulty": "medium",
            "total_time": 32.732396602630615,
            "code_generation_time": 31.851283073425293,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 2092,
            "total_output_tokens": 710,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport math\n\ndef min_time_to_revert(word, k):\n    n = len(word)\n\n    # If k equals n, we need just one step to get back to initial state\n    if k == n:\n        return 1\n\n    # Number of complete removals before considering partial ones\n    num_full_steps = n // k\n    remainder_len = n % k\n\n    for i in range(num_full_steps + 1): \n        start_index = i * k + remainder_len\n        end_index = start_index + remainder_len\n        if word[start_index:end_index] == word[:remainder_len]:\n            return i\n    \n    raise ValueError(\"Unexpected case encountered\")\n\nif __name__ == \"__main__\":\n    import sys\n    data = sys.stdin.readline().strip().split()\n\n    word = data[0].strip('\"')\n    k = int(data[1])\n\n    try:\n        result = min_time_to_revert(word, k)\n        print(result)\n    except Exception as e:\n        print(f\"Error occurred during execution: {e}\")",
            "history_file": null
        },
        {
            "question_id": "3212",
            "difficulty": "hard",
            "total_time": 15.611562252044678,
            "code_generation_time": 14.653462648391724,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 719,
            "total_output_tokens": 305,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\nMOD = int(1e9) + 7\n\ndef count_good_partitions(nums):\n    n = len(nums)\n    \n    # Find the last occurrence index of each element\n    last_occurrence = {}\n    for i in range(n):\n        last_occurrence[nums[i]] = i\n    \n    # Initialize variables\n    end_of_current_partition = -1\n    num_partitions = 0\n    \n    # Iterate through the array\n    for i in range(n):\n        # Update the end of the current partition\n        end_of_current_partition = max(end_of_current_partition, last_occurrence[nums[i]])\n        \n        # If we reach the end of a valid partition\n        if i == end_of_current_partition:\n            num_partitions += 1\n    \n    # Calculate the number of ways to split into `num_partitions` parts\n    result = pow(2, num_partitions - 1, MOD)\n    \n    return result\n\nif __name__ == \"__main__\":\n    input_line = sys.stdin.readline().strip()\n    nums = list(map(int, input_line.split()))\n    output = count_good_partitions(nums)\n    print(output)",
            "history_file": null
        },
        {
            "question_id": "abc315_e",
            "difficulty": "hard",
            "total_time": 19.481642246246338,
            "code_generation_time": 18.939672708511353,
            "passed_tests": 0,
            "total_tests": 34,
            "success_rate": 0.0,
            "total_input_tokens": 1088,
            "total_output_tokens": 453,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    def topological_sort(n, prerequisites):\n        # Create adjacency list and indegree array\n        adj_list = [[] for _ in range(n + 1)]\n        indegree = [0] * (n + 1)\n        \n        for i in range(1, n + 1):\n            c_i = prerequisites[i][0]\n            p_ij = prerequisites[i][1:]\n            for j in p_ij:\n                adj_list[j].append(i)\n                indegree[i] += 1\n        \n        # Initialize queue with nodes having zero indegree\n        queue = deque([i for i in range(1, n + 1) if indegree[i] == 0])\n        result = []\n        \n        while queue:\n            node = queue.popleft()\n            result.append(node)\n            \n            for neighbor in adj_list[node]:\n                indegree[neighbor] -= 1\n                if indegree[neighbor] == 0:\n                    queue.append(neighbor)\n        \n        return result[::-1]\n\n    input = sys.stdin.read().splitlines()\n    N = int(input[0])\n    \n    prerequisites = {}\n    index = 1\n    \n    for i in range(N):\n        line = list(map(int, input[index]))\n        C_i = line[0]\n        P_ij = line[1:] if C_i > 0 else []\n        prerequisites[i + 1] = (C_i, P_ij)\n        index += 1\n    \n    order = topological_sort(N, prerequisites)\n    \n    # Find books that need to be read before book 1\n    required_books = set(order[:order.index(1)])\n    required_books.discard(1)\n    \n    print(\" \".join(map(str, sorted(required_books))))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc323_c",
            "difficulty": "medium",
            "total_time": 24.78882336616516,
            "code_generation_time": 24.639648914337158,
            "passed_tests": 0,
            "total_tests": 11,
            "success_rate": 0.0,
            "total_input_tokens": 1292,
            "total_output_tokens": 643,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    import sys\n    \n    def parse_input():\n        N, M = map(int, input().split())\n        A = list(map(int, input().split()))\n        S = [input().strip() for _ in range(N)]\n        return N, M, A, S\n    \n    def calculate_scores(A, S):\n        scores = []\n        for s in S:\n            score = sum(a if c == 'o' else 0 for a, c in zip(A, s))\n            scores.append(score)\n        return scores\n    \n    def find_min_problems_to_exceed(scores, A, S):\n        results = []\n        max_score = max(scores)\n        \n        for i in range(len(S)):\n            current_score = scores[i]\n            unsolved_indices = [j for j, c in enumerate(S[i]) if c == 'x']\n            \n            # Sort problems by their value descendingly\n            sorted_unsolved_by_value = sorted(unsolved_indices, key=lambda x: -A[x])\n            \n            additional_points_needed = max(max_score + len(results) + 1 - current_score, 0)\n            total_additional_points = 0\n            \n            count = 0\n            while total_additional_points < additional_points_needed and count < len(sorted_unsolved_by_value):\n                total_additional_points += A[sorted_unsolved_by_value[count]]\n                count += 1\n            \n            results.append(count)\n        \n        return results\n    \n    N, M, A, S = parse_input()\n    scores = calculate_scores(A, S)\n    results = find_min_problems_to_exceed(scores, A, S)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "3172",
            "difficulty": "easy",
            "total_time": 16.45707678794861,
            "code_generation_time": 15.618374347686768,
            "passed_tests": 48,
            "total_tests": 100,
            "success_rate": 0.48,
            "total_input_tokens": 866,
            "total_output_tokens": 351,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import math\n    \n    def calculate_sum(n):\n        # Sum of first k natural numbers formula: k * (k + 1) // 2\n        return n * (n + 1) // 2\n    \n    def count_multiples_in_range(m, limit):\n        # Count how many multiples of m exist up to a certain number using floor division\n        if m == 0 or limit < m:\n            return 0\n        else:\n            return limit // m\n    \n    n = int(sys.stdin.readline().strip())\n    m = int(sys.stdin.readline().strip())\n\n    total_sum_natural_numbers = calculate_sum(n)\n    \n    count_divisible_by_m = count_multiples_in_range(m, n)\n    last_multiple_of_m_within_limit = count_divisible_by_m * m\n    \n    sum_all_multiples_of_m_up_to_last_one = calculate_sum(last_multiple_of_m_within_limit)\n    \n    sum_non_divisibles = total_sum_natural_numbers - sum_all_multiples_of_m_up_to_last_one\n    \n    result = sum_non_divisibles - sum_all_multiples_of_m_up_to_last_one\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc305_b",
            "difficulty": "easy",
            "total_time": 13.972424507141113,
            "code_generation_time": 13.828524589538574,
            "passed_tests": 11,
            "total_tests": 11,
            "success_rate": 1.0,
            "total_input_tokens": 679,
            "total_output_tokens": 268,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef calculate_distance(p, q):\n    # Define the sequence of points and their respective distances\n    points = ['A', 'B', 'C', 'D', 'E', 'F', 'G']\n    distances = [3, 1, 4, 1, 5, 9]\n    \n    # Find the indices of p and q\n    index_p = points.index(p)\n    index_q = points.index(q)\n    \n    # Ensure index_p < index_q without loss of generality\n    if index_p > index_q:\n        index_p, index_q = index_q, index_p\n    \n    # Calculate the total distance between p and q\n    total_distance = sum(distances[index_p:index_q])\n    \n    return total_distance\n\nif __name__ == \"__main__\":\n    import sys\n    input_data = sys.stdin.read().strip()\n    p, q = input_data.split()\n    result = calculate_distance(p, q)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc340_a",
            "difficulty": "easy",
            "total_time": 10.086668014526367,
            "code_generation_time": 9.981470584869385,
            "passed_tests": 10,
            "total_tests": 10,
            "success_rate": 1.0,
            "total_input_tokens": 623,
            "total_output_tokens": 118,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef generate_arithmetic_sequence(A, B, D):\n    sequence = []\n    current_term = A\n    \n    while current_term <= B:\n        sequence.append(current_term)\n        current_term += D\n    \n    return sequence\n\ndef main():\n    import sys\n    input_line = sys.stdin.readline().strip()\n    A, B, D = map(int, input_line.split())\n    \n    sequence = generate_arithmetic_sequence(A, B, D)\n    print(\" \".join(map(str, sequence)))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "abc314_c",
            "difficulty": "medium",
            "total_time": 18.797613382339478,
            "code_generation_time": 18.123878002166748,
            "passed_tests": 0,
            "total_tests": 27,
            "success_rate": 0.0,
            "total_input_tokens": 1012,
            "total_output_tokens": 402,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    \n    def rotate_subsequence(s, indices):\n        if len(indices) <= 1:\n            return s\n        last_char = s[indices[-1]]\n        rotated_s = [last_char]\n        for idx in reversed(indices[:-1]):\n            rotated_s.append(s[idx])\n        for idx, char in zip(reversed(indices), rotated_s):\n            s[idx] = char\n        return ''.join(s)\n    \n    # Read input\n    n, m = map(int, sys.stdin.readline().split())\n    s = list(sys.stdin.readline().strip())\n    colors = list(map(int, sys.stdin.readline().split()))\n    \n    color_to_indices = [[] for _ in range(m + 1)]\n    for i in range(n):\n        color_to_indices[colors[i]].append(i)\n    \n    result = []\n    for i in range(1, m + 1):\n        subseq_indices = sorted(color_to_indices[i], reverse=True)\n        new_string = rotate_subsequence(list(''.join(result)), subseq_indices)\n        remaining_part = ''\n        j = 0\n        for k in range(len(new_string)):\n            while j < len(subseq_indices) and k == subseq_indices[j]:\n                j += 1\n            else:\n                remaining_part += new_string[k]\n        \n        result.extend([new_string[subseq_index - len(result)] for subseq_index in subseq_indices[::-1]])\n        result.extend(remaining_part[len(result):n])\n    \n    print(''.join(result))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc336_b",
            "difficulty": "easy",
            "total_time": 8.995711326599121,
            "code_generation_time": 8.76978850364685,
            "passed_tests": 7,
            "total_tests": 17,
            "success_rate": 0.41,
            "total_input_tokens": 634,
            "total_output_tokens": 69,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef ctz(N):\n    return bin(N).count('0') - 1 if '0' in bin(N)[::-1] else 0\n\nif __name__ == \"__main__\":\n    N = int(sys.stdin.readline().strip())\n    result = ctz(N)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "2856",
            "difficulty": "medium",
            "total_time": 14.394410848617554,
            "code_generation_time": 13.412763833999634,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 615,
            "total_output_tokens": 248,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import Counter\n\ndef count_complete_subarrays(nums):\n    total_unique_count = len(set(nums))\n    \n    def at_least_k_distinct(k):\n        left = 0\n        current_count = Counter()\n        result = 0\n        \n        for right, num in enumerate(nums):\n            current_count[num] += 1\n            \n            while len(current_count) >= k:\n                result += len(nums) - right\n                current_count[nums[left]] -= 1\n                if current_count[nums[left]] == 0:\n                    del current_count[nums[left]]\n                left += 1\n                \n        return result\n    \n    return at_least_k_distinct(total_unique_count)\n\nif __name__ == \"__main__\":\n    input_line = sys.stdin.readline().strip()\n    nums = list(map(int, input_line.split()))\n    output = count_complete_subarrays(nums)\n    print(output)",
            "history_file": null
        },
        {
            "question_id": "abc310_f",
            "difficulty": "hard",
            "total_time": 27.227349042892456,
            "code_generation_time": 26.67470121383667,
            "passed_tests": 2,
            "total_tests": 38,
            "success_rate": 0.05,
            "total_input_tokens": 1014,
            "total_output_tokens": 754,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom functools import lru_cache\n\nMOD = 998244353\n\ndef extended_gcd(a, b):\n    \"\"\" Extended Euclidean Algorithm \"\"\"\n    if a == 0:\n        return b, 0, 1\n    gcd, x1, y1 = extended_gcd(b % a, a)\n    x = y1 - (b // a) * x1\n    y = x1\n    return gcd, x, y\n\n@lru_cache(None)\ndef mod_inverse(a, m=MOD):\n    \"\"\" Modulo Inverse using Extended GCD \"\"\"\n    _, x, _ = extended_gcd(a, m)\n    return x % m\n\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    \n    N = int(data[0])\n    A = list(map(int, data[1:N+1]))\n    \n    # dp[i][j] will store number of ways to get sum j with i-th die included or excluded\n    dp = [[0] * 11 for _ in range(N + 1)]\n    dp[0][0] = 1\n    \n    total_ways = [1]\n    \n    for i in range(1, N + 1):\n        current_total = 0\n        new_dp = [dp[j][:] for j in range(i)] + [[]]\n        \n        for s in range(sum(dp[i-1]) + max(A[:i])):\n            count_s = 0\n            \n            for k in range(max(s-A[i-1], 0), min(len(dp[i-1]), s)+1):\n                count_s += dp[i-1][k]\n            \n            new_dp[s].append(count_s)\n            current_total += count_s\n        \n        dp.append(new_dp[-1])\n        total_ways.append(current_total)\n    \n    valid_sum_count = sum(dp[N][s] for s in range(1, 11))\n    \n    probability_numerator = valid_sum_count\n    probability_denominator = pow(total_ways[-1], MOD - 2, MOD)\n    \n    result = (probability_numerator * probability_denominator) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc333_e",
            "difficulty": "hard",
            "total_time": 23.34134578704834,
            "code_generation_time": 22.07733464241028,
            "passed_tests": 13,
            "total_tests": 44,
            "success_rate": 0.3,
            "total_input_tokens": 1695,
            "total_output_tokens": 569,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    N = int(sys.stdin.readline())\n    \n    events = []\n    potions_needed = [0] * (N + 1)\n    potion_counts = defaultdict(int)\n    \n    # Read all events and count needed potions\n    for _ in range(N):\n        t_i, x_i = map(int, sys.stdin.readline().split())\n        if t_i == 2:\n            potions_needed[x_i] += 1\n    \n    # If any monster type is not found at least once, it's impossible to defeat them all\n    if max(potions_needed) > sum(1 for event in events if event[0] == 1 and event[1] <= N):\n        print(-1)\n        return\n    \n    actions = [-1] * len(events)\n    current_potion_count = 0\n    min_K = float('inf')\n    \n    # Process each event in order\n    for i, (t_i, x_i) in enumerate(events):\n        if t_i == 1:\n            action_taken = False\n            \n            while potions_needed[x_i]:\n                if current_potion_count < K_min - 1:\n                    break\n                \n                # Try using a potion of another type first\n                used_type = None\n                for j in range(len(actions)):\n                    if actions[j] != -1 and events[j][0] == 1 and events[j][1] != x_i and potion_counts[events[j][1]] > 0:\n                        used_type = events[j][1]\n                        potion_counts[used_type] -= 1\n                        actions[j] = 0\n                        break\n                \n                if used_type is None:\n                    # No other types available, use this one\n                    potion_counts[x_i] -= 1\n                    actions[i] = 1\n                    action_taken = True\n                    break\n        \n        elif t_i == 2:\n            if potion_counts[x_i] >= potions_needed[x_i]:\n                potion_counts[x_i] -= 1\n            else:\n                print(-1)\n                return\n    \n    # Calculate minimum K\n    for i, (t_i, x_i) in enumerate(events):\n        if t_i == 1:\n            current_potion_count += actions[i]\n            min_K = min(min_K, current_potion_count)\n    \n    print(K_min)\n    print(\" \".join(map(str, actions)))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2867",
            "difficulty": "medium",
            "total_time": 15.192749977111816,
            "code_generation_time": 14.27947211265564,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 616,
            "total_output_tokens": 264,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = int(1e9) + 7\n\ndef count_ways_to_split(nums):\n    n = len(nums)\n    \n    # Find all positions of '1' in the array\n    ones_positions = []\n    for i in range(n):\n        if nums[i] == 1:\n            ones_positions.append(i)\n    \n    # If there's no '1', we cannot form any good subarray\n    if not ones_positions:\n        return 0\n    \n    # Calculate the number of ways to split between each pair of consecutive '1's\n    num_splits = len(ones_positions) - 1\n    result = 1\n    for _ in range(num_splits):\n        result *= 2\n        result %= MOD\n    \n    return result\n\nif __name__ == \"__main__\":\n    input_line = sys.stdin.readline().strip()\n    nums = list(map(int, input_line.split()))\n    output = count_ways_to_split(nums)\n    print(output)",
            "history_file": null
        },
        {
            "question_id": "abc324_e",
            "difficulty": "hard",
            "total_time": 19.868321657180786,
            "code_generation_time": 19.02417492866516,
            "passed_tests": 0,
            "total_tests": 40,
            "success_rate": 0.0,
            "total_input_tokens": 954,
            "total_output_tokens": 470,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import bisect\n    \n    def find_subseq_indices(s, t):\n        indices = [[] for _ in range(26)]\n        idx = {}\n        \n        # Map each character to its index list\n        for i, char in enumerate(t):\n            if char not in idx:\n                idx[char] = len(indices)\n                indices[idx[char]] = []\n            indices[idx[char]].append(i)\n            \n        return [indices[ord(char) - ord('a')] for char in s]\n    \n    N, T = input().split()\n    strings = [input() for _ in range(int(N))]\n    \n    count = 0\n    target_positions = [[bisect.bisect_left(pos_list, x + 1) for pos_list in positions] for x in range(len(T))]\n\n    for Si in strings:\n        positions = find_subseq_indices(Si, T)\n        dp = [False] * len(target_positions)\n        dp[-1] = True\n        \n        for k in reversed(range(len(positions))):\n            new_dp = [dp[j] or j == len(target_positions[k]) - 1 and dp[j+1] for j in range(len(dp)-1)] + [True]\n            for p in positions[k]:\n                if p < len(new_dp):\n                    new_dp[p] |= dp[p-1] if p > 0 else False\n            \n            dp = new_dp\n        \n        count += any(dp[:len(target_positions)])\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc318_d",
            "difficulty": "medium",
            "total_time": 22.881856203079224,
            "code_generation_time": 22.69442844390869,
            "passed_tests": 0,
            "total_tests": 17,
            "success_rate": 0.0,
            "total_input_tokens": 1213,
            "total_output_tokens": 592,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom itertools import combinations\n\ndef solve():\n    N = int(sys.stdin.readline())\n    \n    # Read the distance matrix\n    D = []\n    for i in range(N):\n        row = list(map(int, sys.stdin.readline().split()))\n        if i > 0:\n            D.append([row[j] for j in range(i+1)])\n    \n    def is_valid_matching(matching):\n        used_vertices = set()\n        for u, v in matching:\n            if u in used_vertices or v in used_vertices:\n                return False\n            used_vertices.add(u)\n            used_vertices.add(v)\n        return True\n    \n    max_weight = 0\n    \n    # Iterate over all possible matchings of size k where 1 <= k <= floor(N/2)\n    for k in range(1, (N // 2) + 1):\n        for edges in combinations(range(len(D)), k):\n            current_edges = [(i, j) for idx, edge in enumerate(edges) for i in range(edge + 1) for j in range(idx * (idx - 1) // 2 + len(D[idx][:edge]), idx * (idx - 1) // 2 + len(D[idx]))]\n            \n            if not is_valid_matching(current_edges):\n                continue\n            \n            weight_sum = sum(D[u][v-u-1] for u, v in current_edges)\n            max_weight = max(max_weight, weight_sum)\n    \n    print(max_weight)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc343_c",
            "difficulty": "medium",
            "total_time": 13.253049850463867,
            "code_generation_time": 12.669606924057007,
            "passed_tests": 17,
            "total_tests": 29,
            "success_rate": 0.59,
            "total_input_tokens": 741,
            "total_output_tokens": 221,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef is_palindrome(s):\n    return s == s[::-1]\n\ndef largest_palindromic_cube(N):\n    # Start checking from the largest possible cube root down to 1\n    max_x = int(pow(N, 1/3))\n    \n    for x in range(max_x, 0, -1):\n        cube = x ** 3\n        if cube <= N and is_palindrome(str(cube)):\n            return cube\n    \n    return None\n\nif __name__ == \"__main__\":\n    import sys\n    N = int(sys.stdin.readline().strip())\n    result = largest_palindromic_cube(N)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc309_e",
            "difficulty": "hard",
            "total_time": 34.82121396064758,
            "code_generation_time": 19.335820198059082,
            "passed_tests": 0,
            "total_tests": 51,
            "success_rate": 0.0,
            "total_input_tokens": 959,
            "total_output_tokens": 451,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    def dfs(node, depth):\n        if node in visited:\n            return False\n        visited.add(node)\n        \n        # Check if this node should be counted as covered\n        count = int(depth <= generations[node])\n        \n        # Traverse children\n        for child in tree[node]:\n            count += dfs(child, depth + 1)\n        \n        return count\n    \n    N, M = map(int, input().split())\n    \n    parents = list(map(int, input().split()))\n    tree = defaultdict(list)\n    root = None\n    \n    for i in range(1, len(parents) + 1):\n        parent = parents[i - 1]\n        if parent == 1:\n            root = i\n        else:\n            tree[parent].append(i)\n    \n    insurances = []\n    for _ in range(M):\n        x_i, y_i = map(int, input().split())\n        insurances.append((x_i, y_i))\n    \n    total_covered = set()\n    \n    for start_node, gens in insurances:\n        generations = {i: float('inf') for i in range(1, N + 1)}\n        current_depth = [gens] * (N + 1)\n        queue = [(start_node, gens)]\n        \n        while queue:\n            new_queue = []\n            for node, gen_left in queue:\n                if gen_left > 0 and node not in total_covered:\n                    total_covered.add(node)\n                for child in tree.get(node, []):\n                    if child not in total_covered:\n                        new_gen_left = max(gen_left - 1, 0)\n                        if new_gen_left < current_depth[child]:\n                            current_depth[child] = new_gen_left\n                            new_queue.append((child, new_gen_left))\n            \n            queue = new_queue\n    \n    print(len(total_covered))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc338_d",
            "difficulty": "hard",
            "total_time": 26.950940370559692,
            "code_generation_time": 25.385364532470703,
            "passed_tests": 0,
            "total_tests": 27,
            "success_rate": 0.0,
            "total_input_tokens": 1364,
            "total_output_tokens": 694,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    \n    def find(x):\n        if parent[x] != x:\n            parent[x] = find(parent[x])\n        return parent[x]\n    \n    def union(a, b):\n        rootA = find(a)\n        rootB = find(b)\n        if rank[rootA] > rank[rootB]:\n            parent[rootB] = rootA\n        elif rank[rootA] < rank[rootB]:\n            parent[rootA] = rootB\n        else:\n            parent[rootB] = rootA\n            rank[rootA] += 1\n    \n    N, M = map(int, input().split())\n    X = list(map(int, input().split()))\n    \n    # Initialize Union-Find structures\n    parent = list(range(N + 1))\n    rank = [0] * (N + 1)\n    \n    # Calculate distances between consecutive islands in the tour\n    dists = []\n    for i in range(M - 1):\n        a, b = min(X[i], X[i+1]), max(X[i], X[i+1])\n        d = abs(X[i] - X[i+1]) % N\n        dists.append(min(d, N - d) + int((X[i] == X[i+1])))\n    \n    # Try closing each bridge and calculate the minimum length of the tour\n    total_length = sum(dists)\n    best_min_dist = float('inf')\n    \n    for close_bridge in range(1, N + 1):\n        current_dists = dists[:]\n        \n        # Find the segment affected by closing this bridge\n        prev_segment_end = None\n        new_segments = []\n        for j in range(len(current_dists)):\n            start_island = X[j]\n            end_island = X[(j + 1) % len(X)]\n            \n            if close_bridge >= min(start_island, end_island) and close_bridge <= max(start_island, end_island):\n                continue\n            \n            if not prev_segment_end or prev_segment_end[1] != start_island:\n                new_segments.append([start_island, end_island])\n            else:\n                _, last_end = new_segments[-1]\n                if last_end == start_island:\n                    del new_segments[-1]\n                \n                new_start, _ = new_segments.pop()\n                next_new_start = end_island\n                \n                combined_distance = (\n                    min(abs(new_start - next_new_start), N - abs(new_start - next_new_start)) +\n                    int(next_new_start == new_start)\n                )\n                new_segments.append([new_start, next_new_start])\n                current_dists[new_segments.index([new_start, next_new_start])] = combined_distance\n        \n        # Recalculate the distance with one less segment due to closed bridge\n        remaining_distances = sorted(set(sum(x) for x in zip(*current_dists)))\n        if len(remaining_distances) > 2:\n            second_best_option = remaining_distances[1]\n        elif len(remaining_distances) < 3:\n            second_best_option = remaining_distances[0]\n        else:\n            raise Exception(\"Unexpected number of unique sums\")\n        \n        candidate_answer = total_length - second_best_option\n        best_min_dist = min(best_min_dist, candidate_answer)\n    \n    print(int(best_min_dist))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc329_f",
            "difficulty": "hard",
            "total_time": 23.783137321472168,
            "code_generation_time": 17.702786445617676,
            "passed_tests": 36,
            "total_tests": 42,
            "success_rate": 0.86,
            "total_input_tokens": 1001,
            "total_output_tokens": 436,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    import sys\n    \n    def main():\n        import sys\n        \n        # Read input\n        data = sys.stdin.read().split()\n        \n        index = 0\n        N = int(data[index])\n        Q = int(data[index + 1])\n        colors = list(map(int, data[2:index + 2 + N]))\n        queries = []\n        \n        for i in range(Q):\n            a = int(data[index + 2 + N + 2 * i]) - 1\n            b = int(data[index + 2 + N + 2 * i + 1]) - 1\n            queries.append((a, b))\n        \n        # Initialize boxes with sets to track unique colors\n        boxes = [set() for _ in range(N)]\n        \n        # Populate initial boxes with their respective colors\n        for i in range(N):\n            if colors[i] != 0:\n                boxes[i].add(colors[i])\n        \n        # Process each query\n        results = []\n        for a, b in queries:\n            # Move all colors from box 'a' to box 'b'\n            if len(boxes[a]) > 0:\n                boxes[b].update(boxes[a])\n                boxes[a].clear()\n            \n            # Count unique colors in box 'b'\n            num_colors_b = len(boxes[b])\n            results.append(num_colors_b)\n        \n        # Print results\n        for result in results:\n            print(result)\n    \n    if __name__ == \"__main__\":\n        main()\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc306_c",
            "difficulty": "medium",
            "total_time": 13.851314067840576,
            "code_generation_time": 13.138992071151733,
            "passed_tests": 16,
            "total_tests": 16,
            "success_rate": 1.0,
            "total_input_tokens": 893,
            "total_output_tokens": 255,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import collections\n    \n    # Read input\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    \n    # Dictionary to store indices of occurrences of each number\n    index_map = {i+1: [] for i in range(n)}\n    \n    # Fill the dictionary with indices\n    for idx, value in enumerate(a):\n        if len(index_map[value]) == 2:\n            continue\n        index_map[value].append(idx + 1)\n    \n    # Extract middle occurrence indices\n    mid_indices = [(value, data[1]) for value, data in index_map.items()]\n    \n    # Sort by middle occurrence indices\n    sorted_values = [x[0] for x in sorted(mid_indices, key=lambda x: x[1])]\n    \n    # Print result\n    print(\" \".join(map(str, sorted_values)))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc331_b",
            "difficulty": "easy",
            "total_time": 16.369332790374756,
            "code_generation_time": 16.108577251434326,
            "passed_tests": 8,
            "total_tests": 22,
            "success_rate": 0.36,
            "total_input_tokens": 686,
            "total_output_tokens": 389,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef min_cost_to_buy_eggs(N, S, M, L):\n    # Initialize dp array where dp[i] represents the minimum cost to get exactly i eggs\n    dp = [float('inf')] * (N + 1)\n    \n    # Base case: no eggs needed means zero cost\n    dp[0] = 0\n    \n    # Fill the dp table considering all possible combinations of egg packs\n    for i in range(6, N + 1):\n        if i >= 6:\n            dp[i] = min(dp[i], dp[i - 6] + S)\n        if i >= 8:\n            dp[i] = min(dp[i], dp[i - 8] + M)\n        if i >= 12:\n            dp[i] = min(dp[i], dp[i - 12] + L)\n    \n    # Find the minimum cost to have at least N eggs by checking costs starting from N down to 0\n    result = float('inf')\n    for i in range(N, -1, -1):\n        if dp[i] != float('inf'):\n            result = dp[i]\n            break\n    \n    return result\n\nif __name__ == \"__main__\":\n    import sys\n    input_data = sys.stdin.read().split()\n    N = int(input_data[0])\n    S = int(input_data[1])\n    M = int(input_data[2])\n    L = int(input_data[3])\n    \n    answer = min_cost_to_buy_eggs(N, S, M, L)\n    print(answer)",
            "history_file": null
        },
        {
            "question_id": "2869",
            "difficulty": "medium",
            "total_time": 20.30374312400818,
            "code_generation_time": 19.583168983459473,
            "passed_tests": 0,
            "total_tests": 83,
            "success_rate": 0.0,
            "total_input_tokens": 901,
            "total_output_tokens": 523,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    \n    def max_non_decreasing_length(nums):\n        if not nums:\n            return 0\n        \n        dp = [[1] * len(nums) for _ in range(2)]\n        \n        for i in range(1, len(nums)):\n            if nums[i] >= nums[i - 1]:\n                dp[0][i] = dp[0][i - 1] + 1\n            else:\n                dp[0][i] = 1\n            \n            if nums[i] >= nums[i - 1]:\n                dp[1][i] = dp[1][i - 1] + 1\n            else:\n                dp[1][i] = 1\n        \n        return max(max(row) for row in dp)\n    \n    input = sys.stdin.read().split()\n    n = int(input[0])\n    nums1 = list(map(int, input[1:n+1]))\n    nums2 = list(map(int, input[n+1:2*n+1]))\n    \n    # Create combined arrays by choosing either element at each position\n    combined_nums = []\n    for num1, num2 in zip(nums1, nums2):\n        combined_nums.append([num1, num2])\n    \n    best_length = 0\n    for start_index in range(n):\n        current_best = 0\n        last_chosen = None\n        current_sequence = []\n        \n        for index in range(start_index, n):\n            options = []\n            \n            if last_chosen is None or combined_nums[index][0] >= last_chosen:\n                options.append(combined_nums[index][0])\n            \n            if last_chosen is None or combined_nums[index][1] >= last_chosen:\n                options.append(combined_nums[index][1])\n            \n            chosen_value = min(options)\n            current_sequence.append(chosen_value)\n            last_chosen = chosen_value\n        \n        current_best = max(current_best, max_non_decreasing_length(current_sequence))\n        best_length = max(best_length, current_best)\n    \n    print(best_length)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc332_d",
            "difficulty": "hard",
            "total_time": 15.362469673156738,
            "code_generation_time": 14.959263324737549,
            "passed_tests": 19,
            "total_tests": 38,
            "success_rate": 0.5,
            "total_input_tokens": 2615,
            "total_output_tokens": 256,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    \n    def is_permutation(a, b):\n        return sorted(a) == sorted(b)\n    \n    H, W = map(int, input().split())\n    \n    A = [list(map(int, input().split())) for _ in range(H)]\n    B = [list(map(int, input().split())) for _ in range(H)]\n    \n    if not all(is_permutation(A[i], B[i]) for i in range(W)):\n        print(-1)\n        return\n    \n    row_swaps = sum(1 for r in zip(*A) if list(r) != sorted(list(r)))\n    col_swaps = sum(1 for c in A if c != sorted(c))\n    \n    total_operations = (row_swaps + col_swaps) // 2\n    \n    print(total_operations)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc322_c",
            "difficulty": "medium",
            "total_time": 13.675956726074219,
            "code_generation_time": 12.497158288955688,
            "passed_tests": 27,
            "total_tests": 27,
            "success_rate": 1.0,
            "total_input_tokens": 847,
            "total_output_tokens": 236,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import bisect\n    \n    # Read input\n    data = sys.stdin.read().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    \n    firework_days = list(map(int, data[2:]))\n    \n    results = []\n    \n    for i in range(1, N + 1):\n        index = bisect.bisect_left(firework_days, i)\n        if index == len(firework_days):\n            results.append(N - i)\n        else:\n            results.append(firework_days[index] - i)\n    \n    for result in results:\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3094",
            "difficulty": "medium",
            "total_time": 14.884953498840332,
            "code_generation_time": 13.854246139526367,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 744,
            "total_output_tokens": 285,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import Counter\n\ndef min_operations_to_empty_array(nums):\n    count = Counter(nums)\n    \n    total_ops = 0\n    \n    for freq in count.values():\n        if freq == 1:\n            return -1\n        \n        # Calculate the minimum number of operations needed\n        ops_of_3 = freq // 3\n        remainder = freq % 3\n        \n        if remainder == 1:\n            # If there's a remainder of 1, adjust by using one more group of two instead of one fewer group of three\n            ops_of_3 -= 1\n            remainder += 3\n        \n        # Now remainder must be either 0 or 2\n        assert remainder == 0 or remainder == 2\n        \n        ops_of_2 = remainder // 2\n        \n        total_ops += ops_of_3 + ops_of_2\n    \n    return total_ops\n\nif __name__ == \"__main__\":\n    input_line = sys.stdin.readline().strip()\n    nums = list(map(int, input_line.split()))\n    result = min_operations_to_empty_array(nums)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc312_b",
            "difficulty": "easy",
            "total_time": 20.588301181793213,
            "code_generation_time": 20.356693029403687,
            "passed_tests": 1,
            "total_tests": 14,
            "success_rate": 0.07,
            "total_input_tokens": 1377,
            "total_output_tokens": 528,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef is_tak_code(grid):\n    # Check top-left and bottom-right 3x3 regions are black\n    if not all(all(cell == '#' for cell in row[0:3]) for row in grid[:3]):\n        return False\n    if not all(all(cell == '#' for cell in row[-3:]) for row in grid[-3:]):\n        return False\n    \n    # Check cells adjacent to top-left and bottom-right 3x3 regions are white\n    directions = [(-1,-1), (-1,0), (-1,1),\n                  (0,-1),         (0,1),\n                  (1,-1), (1,0), (1,1)]\n    \n    def check_adjacent(x, y):\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < len(grid) and 0 <= ny < len(grid[x]):\n                if grid[nx][ny] != '.':\n                    return False\n        return True\n    \n    # Top-left corner of Tak Code\n    if any(not check_adjacent(i, j) for i in range(3) for j in range(3)):\n        return False\n    \n    # Bottom-right corner of Tak Code\n    if any(not check_adjacent(len(grid)-i-4, len(grid[i])-j-4) for i in range(3) for j in range(3)):\n        return False\n    \n    return True\n\ndef solve():\n    import sys\n    input = sys.stdin.read().split()\n    \n    N = int(input[0])\n    M = int(input[1])\n    S = input[2:]\n    \n    results = []\n    \n    for i in range(N - 9 + 1):\n        for j in range(M - 9 + 1):\n            subgrid = [S[k][j:j+9] for k in range(i, i+9)]\n            if is_tak_code(subgrid):\n                results.append((i + 1, j + 1))\n    \n    for result in sorted(results):\n        print(result[0], result[1])\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "1899_C",
            "difficulty": "hard",
            "total_time": 17.952046155929565,
            "code_generation_time": 16.884485244750977,
            "passed_tests": 106,
            "total_tests": 106,
            "success_rate": 1.0,
            "total_input_tokens": 948,
            "total_output_tokens": 411,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef max_alternating_subarray_sum(arr):\n    if len(arr) == 1:\n        return arr[0]\n    \n    # Initialize variables to keep track of maximum sums ending with odd and even numbers\n    max_odd = float('-inf')\n    max_even = float('-inf')\n    \n    current_max_odd = 0\n    current_max_even = 0\n    \n    result = float('-inf')\n    \n    for num in arr:\n        if num % 2 != 0:  # Odd number\n            new_current_max_odd = max(num + current_max_even, num)\n            current_max_even = 0\n            current_max_odd = new_current_max_odd\n            max_odd = max(max_odd, current_max_odd)\n        else:  # Even number\n            new_current_max_even = max(num + current_max_odd, num)\n            current_max_odd = 0\n            current_max_even = new_current_max_even\n            max_even = max(max_even, current_max_even)\n        \n        result = max(result, max_odd, max_even)\n    \n    return result\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    index = 0\n    t = int(data[index])\n    index += 1\n    \n    results = []\n    \n    for _ in range(t):\n        n = int(data[index])\n        index += 1\n        \n        arr = list(map(int, data[index:index+n]))\n        index += n\n        \n        results.append(str(max_alternating_subarray_sum(arr)))\n    \n    print(\"\\n\".join(results))",
            "history_file": null
        },
        {
            "question_id": "3228",
            "difficulty": "medium",
            "total_time": 16.796570301055908,
            "code_generation_time": 15.801570892333984,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 991,
            "total_output_tokens": 355,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import Counter\n\ndef solve():\n    def get_unique_elements(arr):\n        return len(set(arr))\n    \n    # Read input\n    n = int(sys.stdin.readline())\n    nums1 = list(map(int, sys.stdin.readline().split()))\n    nums2 = list(map(int, sys.stdin.readline().split()))\n    \n    # Count unique elements in each array\n    unique_count_1 = get_unique_elements(nums1)\n    unique_count_2 = get_unique_elements(nums2)\n    \n    # Find common elements between both sets\n    intersection_size = len(set(nums1) & set(nums2))\n    \n    # Calculate max possible size of the resulting set\n    total_removals_needed = n // 2\n    \n    # Remove duplicates within each array first if needed\n    remaining_in_set_1 = min(unique_count_1 - intersection_size + total_removals_needed, unique_count_1)\n    remaining_in_set_2 = min(unique_count_2 - intersection_size + total_remoals_needed, unique_count_2)\n    \n    # The final result will include all unique elements minus those already counted twice due to intersection\n    result = remaining_in_set_1 + remaining_in_set_2 - intersection_size\n    \n    # Ensure we do not exceed the limit imposed by removing exactly half from each array\n    result = min(result, n)\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc318_b",
            "difficulty": "easy",
            "total_time": 23.294508457183838,
            "code_generation_time": 22.95014238357544,
            "passed_tests": 0,
            "total_tests": 21,
            "success_rate": 0.0,
            "total_input_tokens": 877,
            "total_output_tokens": 627,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import collections\n    \n    def intersect(interval1, interval2):\n        start = max(interval1[0], interval2[0])\n        end = min(interval1[1], interval2[1])\n        return [start, end] if start < end else None\n    \n    n = int(sys.stdin.readline())\n    \n    # Read all rectangles into a list\n    rects = []\n    for _ in range(n):\n        ai, bi, ci, di = map(int, sys.stdin.readline().split())\n        rects.append((ai, bi, ci, di))\n    \n    # Sort rectangles by their x-intervals\n    rects.sort(key=lambda rect: rect[0])\n    \n    total_area = 0\n    \n    # Process each rectangle's y-projections\n    active_y_intervals = []  # List of tuples (y_start, y_end)\n    \n    for i in range(len(rects)):\n        current_rect = rects[i]\n        \n        new_active_y_intervals = []\n        overlap_found = False\n        \n        for j in range(i + 1, len(rects)):\n            next_rect = rects[j]\n            \n            # Check intersection on x-axis first\n            if not (current_rect[1] <= next_rect[0] or next_rect[1] <= current_rect[0]):\n                continue\n            \n            # If they are adjacent horizontally and share some vertical space\n            common_x_interval = sorted([rects[k][0:k+2] for k in [i, j]])\n            combined_width = sum(b - a for a, b in zip(common_x_interval[:-1], common_x_interval[1:]))\n\n            # Find overlapping intervals vertically\n            for ay, by in [(ci, di), (next_rect[2], next_rect[3])]:\n                for cy, dy in active_y_intervals:\n                    iy = intersect([(ay, by)], [(cy, dy)])\n                    \n                    if iy is not None:\n                        overlap_found = True\n                        \n                        # Add non-overlapping parts before and after the intersection\n                        if iy[0] > cy:\n                            new_active_y_intervals.append((cy, iy[0]))\n                        \n                        if iy[1] < dy:\n                            new_active_y_intervals.append((iy[1], dy))\n                \n                # Also add this part as it might be completely inside another one later\n                new_active_y_intervals.extend(active_y_intervals)\n\n            break\n        \n        if not overlap_found:\n            # No overlaps found with any other sheet to its right; calculate area directly\n            width_sum = sum(current_rect[1] - current_rect[0] for r in rects[:i+1])\n            height_max = max(r[3] - r[2] for r in rects[:i+1])\n\n            total_area += width_sum * height_max\n\n        else:\n            # Update our set of currently considered Y ranges based on intersections above.\n            active_y_intervals.clear()\n            active_y_intervals.extend(new_active_y_intervals)\n    \n    print(total_area)\n\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc333_c",
            "difficulty": "medium",
            "total_time": 14.879626989364624,
            "code_generation_time": 14.686971426010132,
            "passed_tests": 14,
            "total_tests": 17,
            "success_rate": 0.82,
            "total_input_tokens": 637,
            "total_output_tokens": 328,
            "error": null,
            "traceback": null,
            "code": "import itertools\nimport bisect\n\ndef generate_repunits(limit):\n    \"\"\"Generates repunits up to a certain limit.\"\"\"\n    repunits = []\n    num_ones = 1\n    while True:\n        repunit = int('1' * num_ones)\n        if repunit > limit:\n            break\n        repunits.append(repunit)\n        num_ones += 1\n    return repunits\n\ndef find_nth_trio_sum(n):\n    \"\"\"Finds the n-th smallest number expressible as the sum of exactly three repunits.\"\"\"\n    max_limit = 4000000000  # Arbitrary large enough limit based on constraints\n    repunits = generate_repunits(max_limit)\n    \n    trio_sums = set()\n    for r1, r2, r3 in itertools.combinations_with_replacement(repunits, 3):\n        trio_sum = r1 + r2 + r3\n        if trio_sum <= max_limit:\n            trio_sums.add(trio_sum)\n    \n    sorted_trio_sums = sorted(list(trio_sums))\n    return sorted_trio_sums[n - 1]\n\nif __name__ == \"__main__\":\n    import sys\n    input_line = sys.stdin.readline().strip()\n    N = int(input_line)\n    result = find_nth_trio_sum(N)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc314_b",
            "difficulty": "easy",
            "total_time": 20.557364463806152,
            "code_generation_time": 20.335715532302856,
            "passed_tests": 18,
            "total_tests": 20,
            "success_rate": 0.9,
            "total_input_tokens": 1158,
            "total_output_tokens": 529,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    \n    def parse_input():\n        lines = sys.stdin.read().splitlines()\n        \n        # Read first line which contains N\n        index = 0\n        N = int(lines[index])\n        index += 1\n        \n        players_bets_count = []\n        players_bets_numbers = []\n        \n        # Parse data about each player's bets\n        for _ in range(N):\n            Ci = int(lines[index])\n            Ai = list(map(int, lines[index + 1].strip().split()))\n            \n            assert len(Ai) == Ci\n            \n            players_bets_count.append(Ci)\n            players_bets_numbers.append(set(Ai))\n            \n            index += 2\n        \n        # Last line is the result of roulette spin\n        X = int(lines[-1])\n        \n        return N, players_bets_count, players_bets_numbers, X\n    \n    \n    def find_winners(players_bets_count, players_bets_numbers, X):\n        winners_indices = [i+1 for i, numbers_set in enumerate(players_bets_numbers) if X in numbers_set]\n        \n        min_bet_size = float('inf')\n        smallest_group_of_players_with_minimal_number_of_wagers = None\n        \n        for winner_index in sorted(winners_indices):  \n            current_player_num_of_wagers = players_bets_count[winner_index - 1] \n            \n            if current_player_num_of_wagers < min_bet_size:\n                min_bet_size = current_player_num_of_wagers\n                \n                smallest_group_of_players_with_minimal_number_of_wagers = {winner_index}\n                \n            elif current_player_num_of_wagers == min_bet_size:\n                smallest_group_of_players_with_minimal_number_of_wagers.add(winner_index)\n        \n        \n        return smallest_group_of_players_with_minimal_number_of_wagers\n    \n\n    \n    N, players_bets_count, players_bets_numbers, X = parse_input() \n    \n    res = find_winners(players_bets_count, players_bets_numbers, X)\n\n    K = len(res)\n    B_list_strs = map(str,res)\n    \n    \n    print(K)\n    print(\" \".join(B_list_strs))\n\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc324_d",
            "difficulty": "hard",
            "total_time": 23.23922109603882,
            "code_generation_time": 12.778530597686768,
            "passed_tests": 14,
            "total_tests": 43,
            "success_rate": 0.33,
            "total_input_tokens": 950,
            "total_output_tokens": 226,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom itertools import permutations\n\ndef solve():\n    n = int(sys.stdin.readline().strip())\n    s = sys.stdin.readline().strip()\n    \n    # Generate all possible permutations of the string S\n    permuted_numbers = set(int(\"\".join(p)) for p in permutations(s))\n    \n    count = 0\n    \n    # Check each permutation to see if it is a perfect square\n    for num in permuted_numbers:\n        root = int(num**0.5)\n        if root * root == num and str(root).startswith('0') == False:\n            count += 1\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3019",
            "difficulty": "easy",
            "total_time": 10.310752153396606,
            "code_generation_time": 9.537019729614258,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 674,
            "total_output_tokens": 117,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve(moves):\n    count_L = moves.count('L')\n    count_R = moves.count('R')\n    count_blank = moves.count('_')\n\n    # Calculate net effect of Ls and Rs\n    balance = abs(count_L - count_R)\n    \n    # Furthest point will be reached by using all '_' in the direction that has more counts\n    return balance + count_blank\n\nif __name__ == \"__main__\":\n    input_line = sys.stdin.readline().strip()\n    result = solve(input_line)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc334_d",
            "difficulty": "medium",
            "total_time": 25.016751050949097,
            "code_generation_time": 14.73350477218628,
            "passed_tests": 0,
            "total_tests": 24,
            "success_rate": 0.0,
            "total_input_tokens": 958,
            "total_output_tokens": 296,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom typing import List\n\ndef solve():\n    def max_sleighs(reindeer_counts: List[int], x: int) -> int:\n        left, right = 0, len(reindeer_counts)\n        while left < right:\n            mid = (left + right + 1) // 2\n            if sum(sorted(reindeer_counts)[:mid]) <= x:\n                left = mid\n            else:\n                right = mid - 1\n        return left\n\n    # Read input\n    N, Q = map(int, sys.stdin.readline().split())\n    R = list(map(int, sys.stdin.readline().split()))\n    \n    queries = []\n    for _ in range(Q):\n        X = int(sys.stdin.readline())\n        queries.append(X)\n    \n    # Process each query and output results\n    sorted_R = sorted(R)\n    for X in queries:\n        result = max_sleighs(sorted_R, X)\n        print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc309_c",
            "difficulty": "medium",
            "total_time": 38.51690745353699,
            "code_generation_time": 36.532910108566284,
            "passed_tests": 1,
            "total_tests": 27,
            "success_rate": 0.04,
            "total_input_tokens": 3532,
            "total_output_tokens": 833,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom itertools import repeat\nfrom typing import List, Tuple\n\ndef find_first_day(N: int, K: int, medicines: List[Tuple[int, int]]) -> int:\n    # Sort medicines by their end day in descending order\n    medicines.sort(key=lambda x: -x[0])\n\n    total_pills = sum(b_i for _, b_i in medicines)\n    if total_pills <= K:\n        return 1\n    \n    days_taken = [a_i + i * a_i for i, (a_i, _) in enumerate(medicines)]\n    pills_needed: List[Tuple[int, int]] = []\n    \n    current_total_days = 0\n    for index, medicine in enumerate(days_taken):\n        while len(pills_needed) > 0 and pills_needed[-1][0] >= medicine:\n            pills_needed.pop()\n        \n        pills_needed.append((medicine, medicines[index][1]))\n        current_total_days += medicines[index][1]\n\n        if current_total_days <= K:\n            return max(day for day, _ in pills_needed)\n\n    return -1\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().splitlines()\n    N, K = map(int, input_data[0].strip().split())\n    medicines = [(int(a), int(b)) for line in input_data[1:] \n                 for a, b in zip(line.strip().split(), repeat(2))]\n    \n    result = find_first_day(N, K, medicines[:N*2:N+1])\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc343_b",
            "difficulty": "easy",
            "total_time": 21.976766347885132,
            "code_generation_time": 21.81870198249817,
            "passed_tests": 14,
            "total_tests": 14,
            "success_rate": 1.0,
            "total_input_tokens": 2334,
            "total_output_tokens": 549,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    N = int(sys.stdin.readline().strip())\n\n    adjacency_matrix = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\n\n    results = []\n\n    for i in range(N):\n        connections = [j+1 for j in range(N) if adjacency_matrix[i][j] == 1]\n        results.append(connections)\n\n    for connection_list in results:\n        if connection_list:\n            print(' '.join(map(str, sorted(connection_list))))\n        else:\n            print()\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc333_a",
            "difficulty": "easy",
            "total_time": 8.224340915679932,
            "code_generation_time": 8.148306846618652,
            "passed_tests": 7,
            "total_tests": 7,
            "success_rate": 1.0,
            "total_input_tokens": 499,
            "total_output_tokens": 45,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    n = int(sys.stdin.read().strip())\n    result = str(n) * n\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc312_c",
            "difficulty": "medium",
            "total_time": 17.1062114238739,
            "code_generation_time": 16.058958053588867,
            "passed_tests": 10,
            "total_tests": 41,
            "success_rate": 0.24,
            "total_input_tokens": 885,
            "total_output_tokens": 345,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom bisect import bisect_left, bisect_right\n\ndef solve():\n    import sys\n    \n    def main():\n        import sys\n        \n        # Read inputs\n        data = sys.stdin.read().split()\n        \n        N = int(data[0])\n        M = int(data[1])\n        \n        As = list(map(int, data[2:N+2]))\n        Bs = list(map(int, data[N+2:N+M+2]))\n        \n        # Sort both lists\n        As.sort()\n        Bs.sort()\n        \n        # Binary search for the minimum X that satisfies the condition\n        left, right = min(As), max(Bs)\n        result = -1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            count_sellers_ge_mid = len(As) - bisect_left(As, mid)\n            count_buyers_le_mid = bisect_right(Bs, mid)\n            \n            if count_sellers_ge_mid >= count_buyers_le_mid:\n                result = mid\n                right = mid - 1\n            else:\n                left = mid + 1\n        \n        print(result)\n    \n    if __name__ == \"__main__\":\n        main()\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc312_f",
            "difficulty": "hard",
            "total_time": 19.906221866607666,
            "code_generation_time": 18.377307891845703,
            "passed_tests": 4,
            "total_tests": 43,
            "success_rate": 0.09,
            "total_input_tokens": 1031,
            "total_output_tokens": 427,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    \n    pull_tabs = []\n    regular_cans = []\n    openers = []\n\n    for _ in range(N):\n        T_i, X_i = map(int, sys.stdin.readline().split())\n        if T_i == 0:\n            pull_tabs.append(X_i)\n        elif T_i == 1:\n            regular_cans.append((X_i))\n        else:\n            openers.append(-X_i)  # Use negative because we want max heap behavior with heapq\n    \n    pull_tabs.sort(reverse=True)\n    regular_cans.sort()\n    openers.sort()\n\n    total_happiness = sum(pull_tabs[:M])\n    remaining_slots = M - len(pull_tabs)\n\n    opener_count = 0\n    i, j = 0, 0\n\n    while remaining_slots > 0 and (i < len(regular_cans) or j < len(openers)):\n        if j >= len(openers) or (i < len(regular_cans) and regular_cans[i] <= abs(openers[j])):\n            use_can_opener = False\n        else:\n            use_can_opener = True\n        \n        if not use_can_opener:\n            if opener_count > 0:\n                total_happiness += regular_cans[i]\n                opener_count -= 1\n            i += 1\n        else:\n            opener_count += abs(openers[j]) // min(remaining_slots, len(regular_cans) + opener_count * 2)\n            j += 1\n        \n        remaining_slots -= 1\n\n    print(total_happiness)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3225",
            "difficulty": "medium",
            "total_time": 15.214154243469238,
            "code_generation_time": 14.244245290756226,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 879,
            "total_output_tokens": 299,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    def max_length_subarray(nums, k):\n        freq_map = defaultdict(int)\n        left = 0\n        max_len = 0\n        \n        for right in range(len(nums)):\n            num = nums[right]\n            freq_map[num] += 1\n            \n            while freq_map[num] > k:\n                freq_map[nums[left]] -= 1\n                if freq_map[nums[left]] == 0:\n                    del freq_map[nums[left]]\n                left += 1\n            \n            max_len = max(max_len, right - left + 1)\n        \n        return max_len\n    \n    # Read input\n    import sys\n    data = sys.stdin.read().split()\n    \n    n = int(data[0])\n    nums = list(map(int, data[1:n+1]))\n    k = int(data[n+1])\n    \n    result = max_length_subarray(nums, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc303_e",
            "difficulty": "hard",
            "total_time": 21.56761908531189,
            "code_generation_time": 20.081888675689697,
            "passed_tests": 0,
            "total_tests": 18,
            "success_rate": 0.0,
            "total_input_tokens": 1120,
            "total_output_tokens": 496,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict, deque\n\ndef solve():\n    def find_stars(tree):\n        # Find leaves with degree 1 and their parents\n        leaf_parents = {}\n        degrees = {node: len(neighbors) for node, neighbors in tree.items()}\n        \n        queue = deque([node for node, deg in degrees.items() if deg == 1])\n        while queue:\n            current = queue.popleft()\n            parent = next(iter(tree[current]))\n            \n            if degrees[parent] > 2:\n                continue\n            \n            leaf_parents[current] = parent\n            degrees[parent] -= 1\n            if degrees[parent] == 1:\n                queue.append(parent)\n        \n        return leaf_parents\n    \n    def count_levels(leaf_parents):\n        levels_count = defaultdict(int)\n        visited = set()\n        \n        for child, parent in leaf_parents.items():\n            level = 1\n            current = parent\n            while current not in visited:\n                visited.add(current)\n                if current in leaf_parents:\n                    current = leaf_parents[current]\n                    level += 1\n                else:\n                    break\n            levels_count[level - 1] += 1\n        \n        sorted_levels = [level + 1 for level, count in sorted(levels_count.items())]\n        return ' '.join(map(str, sorted_levels))\n    \n    N = int(sys.stdin.readline())\n    tree = defaultdict(list)\n    \n    for _ in range(N-1):\n        u, v = map(int, sys.stdin.readline().split())\n        tree[u].append(v)\n        tree[v].append(u)\n    \n    leaf_parents = find_stars(tree)\n    result = count_levels(leaf_parents)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc305_a",
            "difficulty": "easy",
            "total_time": 12.297245025634766,
            "code_generation_time": 12.174458742141724,
            "passed_tests": 2,
            "total_tests": 7,
            "success_rate": 0.29,
            "total_input_tokens": 695,
            "total_output_tokens": 205,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef find_nearest_water_station(N):\n    if N % 5 != 0:\n        lower = (N // 5) * 5 + 5\n        upper = ((N // 5) + 1) * 5 - 5\n        return min(lower, key=lambda x: abs(x - N))\n    else:\n        return N\n\ndef main():\n    import sys\n    N = int(sys.stdin.readline().strip())\n    result = find_nearest_water_station(N)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "2884",
            "difficulty": "hard",
            "total_time": 16.143402338027954,
            "code_generation_time": 15.235900640487671,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 720,
            "total_output_tokens": 330,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef findLongestValidSubstring(word, forbidden):\n    max_length = len(max(forbidden, key=len))\n    n = len(word)\n    \n    def isValid(start, end):\n        for i in range(end - start + 1):\n            sub_str = word[start:end+1-i]\n            if sub_str in forbidden_set:\n                return False\n        return True\n    \n    left = right = maxLength = 0\n    while right < n:\n        currentLength = right - left + 1\n        \n        # Check validity by moving left pointer at most `max_length` steps back\n        while not isValid(left, right) and left <= right:\n            left += 1\n            currentLength -= 1\n        \n        maxLength = max(currentLength, maxLength)\n        \n        right += 1\n    \n    return maxLength\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().split()\n    word = input_data[0]\n    forbidden_count = int(input_data[1])\n    forbidden_list = []\n    index = 2\n    for _ in range(forbidden_count):\n        forbidden_list.append(input_data[index])\n        index += 1\n    \n    forbidden_set = set(forbidden_list)\n    result = findLongestValidSubstring(word, forbidden_set)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "2866",
            "difficulty": "easy",
            "total_time": 17.98485255241394,
            "code_generation_time": 17.19762134552002,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 857,
            "total_output_tokens": 402,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    \n    def find_longest_subarray(nums, threshold):\n        max_length = 0\n        current_length = 0\n        \n        n = len(nums)\n        \n        # Iterate through each element starting with even numbers\n        i = 0\n        while i < n:\n            if nums[i] % 2 == 0 and nums[i] <= threshold:\n                start_index = i\n                end_index = i + 1\n                \n                # Continue extending the subarray as long as it alternates between odd/even and stays within threshold\n                while end_index < n and abs((nums[end_index - 1]) % 2 - (nums[end_index]) % 2) == 1 and nums[end_index] <= threshold:\n                    end_index += 1\n                    \n                # Update the longest found so far\n                max_length = max(max_length, end_index - start_index)\n                \n                # Move index past the last valid number in the current sequence\n                i = end_index\n            else:\n                i += 1\n            \n        return max_length\n    \n    input_data = sys.stdin.read().split()\n    \n    nums = list(map(int, input_data[:-1]))\n    threshold = int(input_data[-1])\n    \n    result = find_longest_subarray(nums, threshold)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3320",
            "difficulty": "easy",
            "total_time": 12.65532374382019,
            "code_generation_time": 11.808116674423218,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 689,
            "total_output_tokens": 195,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef max_operations_with_same_score(nums):\n    if len(nums) < 2:\n        return 0\n    \n    target_sum = nums[0] + nums[1]\n    count = 0\n    i = 0\n    \n    while i + 1 < len(nums):\n        if nums[i] + nums[i + 1] == target_sum:\n            count += 1\n            i += 2\n        else:\n            break\n    \n    return count\n\nif __name__ == \"__main__\":\n    input_line = sys.stdin.readline().strip()\n    nums = list(map(int, input_line.split()))\n    \n    result = max_operations_with_same_score(nums)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc315_b",
            "difficulty": "easy",
            "total_time": 14.49349570274353,
            "code_generation_time": 14.234419107437134,
            "passed_tests": 24,
            "total_tests": 24,
            "success_rate": 1.0,
            "total_input_tokens": 934,
            "total_output_tokens": 284,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    \n    def main():\n        # Read input\n        data = sys.stdin.read().split()\n        \n        M = int(data[0])\n        Ds = list(map(int, data[1:]))\n        \n        # Calculate the total number of days\n        total_days = sum(Ds)\n        \n        # Find the position of the middle day\n        target_day_position = (total_days + 1) // 2\n        \n        current_month = 1\n        cumulative_days = 0\n        \n        # Iterate through each month and its days\n        for i in range(M):\n            if cumulative_days < target_day_position <= cumulative_days + Ds[i]:\n                b = target_day_position - cumulative_days\n                break\n            else:\n                cumulative_days += Ds[i]\n                current_month += 1\n        \n        # Print result\n        print(current_month, b)\n    \n    if __name__ == \"__main__\":\n        main()\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc313_a",
            "difficulty": "easy",
            "total_time": 11.59998369216919,
            "code_generation_time": 11.430878639221191,
            "passed_tests": 7,
            "total_tests": 12,
            "success_rate": 0.58,
            "total_input_tokens": 690,
            "total_output_tokens": 185,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    \n    def main():\n        n = int(sys.stdin.readline())\n        scores = list(map(int, sys.stdin.readline().split()))\n        \n        p1_score = scores[0]\n        max_other_scores = max(scores[1:])\n        \n        if p1_score >= max_other_scores:\n            result = 0\n        else:\n            result = max_other_scores - p1_score + 1\n        \n        print(result)\n    \n    if __name__ == \"__main__\":\n        main()\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc329_e",
            "difficulty": "hard",
            "total_time": 13.929273128509521,
            "code_generation_time": 13.22458291053772,
            "passed_tests": 27,
            "total_tests": 48,
            "success_rate": 0.56,
            "total_input_tokens": 765,
            "total_output_tokens": 261,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import collections\n    \n    def check_substring(s, t):\n        n = len(s)\n        m = len(t)\n        \n        # Create a counter for all substrings of s of length m\n        substring_counter = collections.defaultdict(int)\n        for i in range(n - m + 1):\n            substring_counter[s[i:i+m]] += 1\n        \n        return t in substring_counter or '#' * m == t\n\n    # Read input\n    data = sys.stdin.read().split()\n    \n    N = int(data[0])\n    M = int(data[1])\n    S = data[2]\n    T = data[3]\n\n    result = \"Yes\" if check_substring(S, T) else \"No\"\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3223",
            "difficulty": "hard",
            "total_time": 21.512722969055176,
            "code_generation_time": 15.4840726852417,
            "passed_tests": 79,
            "total_tests": 100,
            "success_rate": 0.79,
            "total_input_tokens": 641,
            "total_output_tokens": 353,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import Counter\n\ndef count_complete_substrings(word, k):\n    def valid_window(s, start, end, k):\n        counter = Counter(s[start:end+1])\n        return all(count == k for count in counter.values())\n\n    n = len(word)\n    total_count = 0\n    \n    max_unique_chars = min(26, n // k)  # Maximum possible unique chars that can appear 'k' times\n    \n    for num_unique_chars in range(1, max_unique_chars + 1):\n        left = right = 0\n        \n        while right < n:\n            current_length = right - left + 1\n            \n            if current_length >= num_unique_chars * k:\n                window_size = num_unique_chars * k\n                \n                if valid_window(word, left, right, k):\n                    total_count += 1\n                    \n                left += 1\n                continue\n            \n            if ord(word[right]) - ord(word[left]) > 2 or \\\n               (right > left and abs(ord(word[right]) - ord(word[right-1])) > 2):\n                \n                left = right\n            \n            right += 1\n    \n    return total_count\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().split()\n    word = input_data[0]\n    k = int(input_data[1])\n    \n    result = count_complete_substrings(word, k)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "3017",
            "difficulty": "hard",
            "total_time": 24.01675033569336,
            "code_generation_time": 23.246500730514526,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 805,
            "total_output_tokens": 655,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    def dp(pos, tight, sum_even, sum_odd, mod_k):\n        if pos == len(num_str):\n            return int(sum_even == sum_odd) * (mod_k % k == 0)\n        \n        limit = num_int[pos] if tight else 9\n        res = 0\n        \n        for d in range(limit + 1):\n            new_tight = tight and (d == limit)\n            new_sum_even = sum_even + (d % 2 == 0)\n            new_sum_odd = sum_odd + (d % 2 != 0)\n            \n            res += dp(pos + 1, new_tight, new_sum_even, new_sum_odd, (mod_k * 10 + d))\n        \n        memo[(pos, tight, sum_even, sum_odd, mod_k)] = res\n        return res\n    \n    def count_beautiful_numbers(n):\n        global num_str, num_int, memo\n        num_str = str(n)\n        num_int = list(map(int, num_str))\n        memo = {}\n        return dp(0, True, 0, 0, 0)\n    \n    low -= 1\n    high_count = count_beautiful_numbers(high)\n    low_count = count_beautiful_numbers(low)\n    result = high_count - low_count\n    print(result)\n\nif __name__ == \"__main__\":\n    import sys\n    input = lambda: sys.stdin.readline().strip()\n    \n    low = int(input())\n    high = int(input())\n    k = int(input())\n    \n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc301_a",
            "difficulty": "easy",
            "total_time": 14.632806539535522,
            "code_generation_time": 14.457740306854248,
            "passed_tests": 9,
            "total_tests": 12,
            "success_rate": 0.75,
            "total_input_tokens": 700,
            "total_output_tokens": 300,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef determine_winner(N, S):\n    takahashi_wins = 0\n    aoki_wins = 0\n    \n    for char in S:\n        if char == 'T':\n            takahashi_wins += 1\n        elif char == 'A':\n            aoki_wins += 1\n        \n        # Check for early exit condition\n        if takahashi_wins > aoki_wins:\n            return 'T'\n        elif aoki_wins > takahashi_wins:\n            return 'A'\n    \n    # If we reach here, both have equal wins but since we checked earlier,\n    # this means Takahashi must have reached his win count first.\n    return 'T'\n\nif __name__ == \"__main__\":\n    import sys\n    data = sys.stdin.read().split()\n    N = int(data[0])\n    S = data[1]\n    result = determine_winner(N, S)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "3210",
            "difficulty": "medium",
            "total_time": 16.9493465423584,
            "code_generation_time": 15.783417701721191,
            "passed_tests": 97,
            "total_tests": 100,
            "success_rate": 0.97,
            "total_input_tokens": 895,
            "total_output_tokens": 352,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import collections\n    \n    def count_beautiful_substrings(s, k):\n        n = len(s)\n        vowel_set = set('aeiou')\n        \n        # Function to check if a character is a vowel\n        def is_vowel(c):\n            return c in vowel_set\n        \n        total_count = 0\n        \n        # Iterate over all possible starting points of substrings\n        for start in range(n):\n            vowel_count = 0\n            consonant_count = 0\n            \n            # Check each substring ending at 'end'\n            for end in range(start, n):\n                if is_vowel(s[end]):\n                    vowel_count += 1\n                else:\n                    consonant_count += 1\n                \n                # If the number of vowels equals the number of consonants,\n                # and their product is divisible by k, it's a beautiful substring\n                if vowel_count == consonant_count and (vowel_count * consonant_count) % k == 0:\n                    total_count += 1\n        \n        return total_count\n\n    input_data = sys.stdin.read().split()\n    s = input_data[0]\n    k = int(input_data[1])\n    \n    result = count_beautiful_substrings(s, k)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "3200",
            "difficulty": "medium",
            "total_time": 21.613295793533325,
            "code_generation_time": 19.9185893535614,
            "passed_tests": 0,
            "total_tests": 87,
            "success_rate": 0.0,
            "total_input_tokens": 718,
            "total_output_tokens": 508,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import Counter\n\nMOD = int(1e9 + 7)\n\ndef count_good_strings(n):\n    def factorial_mod(x):\n        result = 1\n        for i in range(2, x + 1):\n            result = result * i % MOD\n        return result\n    \n    def comb_mod(n, k):\n        numerator = factorial_mod(n)\n        denominator = (factorial_mod(k) * factorial_mod(n - k)) % MOD\n        inv_denominator = pow(denominator, MOD - 2, MOD)\n        return (numerator * inv_denominator) % MOD\n    \n    # Total possible strings of length n using lowercase English letters\n    total_strings = pow(26, n, MOD)\n    \n    # Subtract bad strings that do not contain all 'l', 'e', 'e', 't'\n    bad_count = 0\n    \n    # Case where one or more required character is missing\n    for l in [0, 1]:\n        for e in [0, 1, 2]:  # At least two 'e's needed\n            if l == 0 and e < 2:\n                continue\n            t_needed = max(1, 1 - l)  # Ensure at least one 't' when no 'l'\n            \n            remaining_chars = n - (l + e + t_needed)\n            bad_case_count = pow(26, remaining_chars, MOD)\n            \n            # Choose positions for each letter\n            choose_l_positions = comb_mod(n, l)\n            choose_e_positions = comb_mod(n - l, e)\n            choose_t_positions = comb_mod(n - l - e, t_needed)\n            \n            bad_case_total = ((choose_l_positions * choose_e_positions) % MOD *\n                             choose_t_positions) % MOD\n            \n            bad_count += bad_case_total\n            bad_count %= MOD\n    \n    good_count = (total_strings - bad_count + MOD) % MOD\n    return good_count\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().strip()\n    n = int(input_data)\n    result = count_good_strings(n)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "abc329_c",
            "difficulty": "medium",
            "total_time": 14.22673225402832,
            "code_generation_time": 13.958798885345459,
            "passed_tests": 0,
            "total_tests": 17,
            "success_rate": 0.0,
            "total_input_tokens": 682,
            "total_output_tokens": 285,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef count_repetitive_substrings(s):\n    n = len(s)\n    total_count = 0\n    \n    i = 0\n    while i < n:\n        char = s[i]\n        j = i + 1\n        \n        # Find the extent of this segment with repeating characters\n        while j < n and s[j] == char:\n            j += 1\n        \n        # Length of current segment\n        seg_length = j - i\n        \n        # Number of single-character substrings within this segment\n        single_char_subs = seg_length\n        \n        # Add all possible multi-char repetitive substrings\n        total_count += ((seg_length * (seg_length + 1)) // 2) - single_char_subs\n        \n        # Move to next different character\n        i = j\n    \n    return total_count\n\nif __name__ == \"__main__\":\n    import sys\n    data = sys.stdin.read().split()\n    \n    N = int(data[0])\n    S = data[1]\n    \n    result = count_repetitive_substrings(S)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "3025",
            "difficulty": "hard",
            "total_time": 25.440639972686768,
            "code_generation_time": 24.564483880996704,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 915,
            "total_output_tokens": 666,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import Counter\n\ndef solve():\n    def min_operations(nums, target):\n        # If total sum of nums is less than target, it's impossible to form such a subsequence\n        if sum(nums) < target:\n            return -1\n        \n        # Count occurrences of each power of 2 in nums\n        count = Counter()\n        \n        for num in nums:\n            while num > 0 and num & (num - 1):  # Check if num is not a power of 2\n                num >>= 1\n            if num > 0:\n                count[num.bit_length() - 1] += 1\n        \n        ops = 0\n        required_bits = []\n        \n        # Determine bits needed to represent target\n        i = 0\n        while target > 0:\n            if target % 2 == 1:\n                required_bits.append(i)\n            target //= 2\n            i += 1\n        \n        current_bit_sum = 0\n        \n        # Try to satisfy higher bit requirements first using lower bits available\n        for bit in range(31, -1, -1):\n            if bit in required_bits:\n                current_bit_sum += count[bit]\n            \n            if bit + 1 in required_bits:\n                if current_bit_sum >= 2:\n                    current_bit_sum -= 2\n                else:\n                    ops += 1\n            \n            current_bit_sum *= 2\n        \n        return ops\n    \n    input_data = sys.stdin.read().splitlines()\n    \n    n = int(input_data[0])\n    nums = list(map(int, input_data[1].strip().split()))\n    target = int(input_data[2])\n    \n    result = min_operations(nums, target)\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc323_d",
            "difficulty": "hard",
            "total_time": 30.91433358192444,
            "code_generation_time": 20.626964807510376,
            "passed_tests": 1,
            "total_tests": 30,
            "success_rate": 0.03,
            "total_input_tokens": 933,
            "total_output_tokens": 541,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    n = int(sys.stdin.readline())\n    \n    # Dictionary to store counts of each unique power level\n    count_dict = {}\n    \n    for _ in range(n):\n        s, c = map(int, sys.stdin.readline().split())\n        \n        if s not in count_dict:\n            count_dict[s] = []\n            \n        while c > 0:\n            remainder = c % 2\n            count_dict[s].append(remainder)\n            c //= 2\n            \n            if c == 0:\n                break\n    \n    total_slimes = len(count_dict) * [0]\n    \n    max_power_level = -float('inf')\n    min_non_zero_count = float('inf')\n\n    for i, key in enumerate(sorted(count_dict.keys())):\n        current_counts = sorted(count_dict[key])\n        non_zeros = sum(current_counts[1:])\n        ones_needed_for_next_merge = 1\n        \n        j = 0\n        k = 0\n        merged_size = 0\n        \n        while j < len(total_slimes) and k < len(current_counts):\n            if total_slimes[j] >= current_counts[k]:\n                total_slimes[j] -= current_counts[k]\n                k += 1\n                \n                if k < len(current_counts) and current_counts[k] != 0:\n                    merged_size += 1\n                    \n                    if merged_size == ones_needed_for_next_merge:\n                        total_slimes.append(merged_size + 1)\n                        \n                        if merged_size + 1 <= len(total_slimes):\n                            total_slimes[-1] = 0\n                        \n                        ones_needed_for_next_merge *= 2\n            else:\n                j += 1\n        \n        remaining_ones = sum([x for x in current_counts if x != 0]) - non_zeros\n        total_slimes.extend([remaining_ones // ones_needed_for_next_merge] * (non_zeros // ones_needed_for_next_merge))\n        \n        if remaining_ones % ones_needed_for_next_merge != 0 or non_zeros % ones_needed_for_next_merge != 0:\n            total_slimes.append((remaining_ones % ones_needed_for_next_merge) + (non_zeros % ones_needed_for_next_merge))\n\n        max_power_level = max(max_power_level, key)\n\n    result = len(list(filter(lambda x: x != 0, total_slimes)))\n    print(result)\n\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc334_e",
            "difficulty": "hard",
            "total_time": 23.494613885879517,
            "code_generation_time": 20.840792417526245,
            "passed_tests": 0,
            "total_tests": 31,
            "success_rate": 0.0,
            "total_input_tokens": 1149,
            "total_output_tokens": 543,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque\n\nMOD = 998244353\n\ndef find_components(grid):\n    h, w = len(grid), len(grid[0])\n    visited = [[False] * w for _ in range(h)]\n    \n    def bfs(x, y):\n        queue = deque([(x, y)])\n        while queue:\n            cx, cy = queue.popleft()\n            if not visited[cx][cy]:\n                visited[cx][cy] = True\n                for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    nx, ny = cx + dx, cy + dy\n                    if 0 <= nx < h and 0 <= ny < w and grid[nx][ny] == '#':\n                        queue.append((nx, ny))\n    \n    component_count = 0\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == '#' and not visited[i][j]:\n                bfs(i, j)\n                component_count += 1\n    \n    return component_count\n\ndef main():\n    input = sys.stdin.read().splitlines()\n    H, W = map(int, input[0].split())\n    grid = input[1:H+1]\n    \n    total_red_cells = sum(row.count('.') for row in grid)\n    current_green_components = find_components([list(row) for row in grid])\n    \n    expected_value_numerator = current_green_components * total_red_cells\n    \n    # Calculate each possible new configuration by changing one '.' to '#'\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '.':\n                temp_grid = [row[:] for row in grid]\n                temp_grid[i][j] = '#'\n                new_component_count = find_components(temp_grid)\n                expected_value_numerator += new_component_count\n    \n    denominator = total_red_cells ** 2\n    gcd = math.gcd(expected_value_numerator, denominator)\n    expected_value_numerator //= gcd\n    denominator //= gcd\n    \n    result = (expected_value_numerator * pow(denominator, MOD-2, MOD)) % MOD\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "abc325_d",
            "difficulty": "hard",
            "total_time": 21.28417205810547,
            "code_generation_time": 17.783918142318726,
            "passed_tests": 0,
            "total_tests": 44,
            "success_rate": 0.0,
            "total_input_tokens": 1021,
            "total_output_tokens": 428,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom typing import List, Tuple\n\ndef max_prints(products: List[Tuple[int, int]]) -> int:\n    # Sort by end times first, then start times if they are equal\n    events = []\n    \n    for i, (start, duration) in enumerate(products):\n        end_time = start + duration - 1\n        events.append((end_time, 'e', i))  # End event\n    \n    # Add a dummy charge time at t=0 to handle edge cases easily\n    events.sort()\n    \n    count = 0\n    last_charge_end = float('-inf')\n    \n    for _, eventType, index in events:\n        if eventType == 'e':\n            current_start = products[index][0]\n            \n            # Check if we can use this product without charging again\n            if current_start >= last_charge_end + 1:\n                count += 1\n                last_charge_end = current_start + products[index][1] - 1\n                \n    return count\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read\n    data = list(map(int, input().split()))\n    \n    N = data[0]\n    T_D_pairs = [(data[i * 2 + 1], data[i * 2 + 2]) for i in range(N)]\n    \n    result = max_prints(T_D_pairs)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "3151",
            "difficulty": "medium",
            "total_time": 16.98734211921692,
            "code_generation_time": 16.069404125213623,
            "passed_tests": 0,
            "total_tests": 53,
            "success_rate": 0.0,
            "total_input_tokens": 1030,
            "total_output_tokens": 355,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import heapq\n    \n    def min_processing_time(processorTime, tasks):\n        # Sort processors in ascending order\n        processorTime.sort()\n        \n        # Sort tasks in descending order\n        tasks.sort(reverse=True)\n        \n        # Each task will be assigned to a core starting with the earliest available processor\n        result = []\n        heap = [(time, i) for i, time in enumerate(processorTime)]\n        heapq.heapify(heap)\n        \n        for task in tasks:\n            start_time, proc_index = heapq.heappop(heap)\n            end_time = start_time + task\n            \n            # Push back into heap with updated availability time\n            heapq.heappush(heap, (end_time, proc_index))\n            \n            if not result or end_time > result[-1]:\n                result.append(end_time)\n                \n        return result[-1]\n    \n    input = sys.stdin.read().splitlines()\n    processorTime = list(map(int, input[0].strip('[]').split(', ')))\n    tasks = list(map(int, input[1].strip('[]').split(', ')))\n\n    output = min_processing_time(processorTime, tasks)\n    print(output)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "2844",
            "difficulty": "easy",
            "total_time": 11.439887523651123,
            "code_generation_time": 10.665159225463867,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 784,
            "total_output_tokens": 137,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    import sys\n    \n    def sum_of_squares(nums):\n        n = len(nums)\n        total_sum = 0\n        for i in range(1, n + 1):\n            if n % i == 0:\n                total_sum += nums[i - 1] ** 2\n        return total_sum\n    \n    # Read input\n    line = sys.stdin.readline().strip()\n    nums = list(map(int, line.split()))\n    \n    # Calculate result\n    result = sum_of_squares(nums)\n    \n    # Print output\n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc341_d",
            "difficulty": "medium",
            "total_time": 12.460360765457153,
            "code_generation_time": 12.035336971282959,
            "passed_tests": 32,
            "total_tests": 32,
            "success_rate": 1.0,
            "total_input_tokens": 759,
            "total_output_tokens": 200,
            "error": null,
            "traceback": null,
            "code": "import math\nimport sys\n\ndef find_kth_smallest(N, M, K):\n    lcm = abs(N * M) // math.gcd(N, M)\n    \n    def count(x):\n        return x // N + x // M - 2 * (x // lcm)\n    \n    low, high = min(N, M), max(K * min(N, M), K * max(N, M))\n    \n    while low < high:\n        mid = (low + high) >> 1\n        if count(mid) >= K:\n            high = mid\n        else:\n            low = mid + 1\n    \n    return low\n\nif __name__ == \"__main__\":\n    input_data = sys.stdin.read().split()\n    N = int(input_data[0])\n    M = int(input_data[1])\n    K = int(input_data[2])\n    result = find_kth_smallest(N, M, K)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "2816",
            "difficulty": "easy",
            "total_time": 13.438802719116211,
            "code_generation_time": 12.687116622924805,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 728,
            "total_output_tokens": 210,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef min_operations_to_palindrome(s):\n    n = len(s)\n    result = [''] * n\n    \n    left = 0\n    right = n - 1\n    \n    while left < right:\n        # Choose the lexicographically smaller character between s[left] and s[right]\n        char = min(s[left], s[right])\n        result[left] = char\n        result[right] = char\n        \n        left += 1\n        right -= 1\n    \n    # Handle odd-length strings by setting the middle character appropriately\n    if left == right:\n        result[left] = s[left]\n    \n    return ''.join(result)\n\nif __name__ == \"__main__\":\n    input_line = sys.stdin.readline().strip()\n    output = min_operations_to_palindrome(input_line)\n    print(output)",
            "history_file": null
        },
        {
            "question_id": "abc343_d",
            "difficulty": "medium",
            "total_time": 19.84113359451294,
            "code_generation_time": 17.67927837371826,
            "passed_tests": 0,
            "total_tests": 19,
            "success_rate": 0.0,
            "total_input_tokens": 1297,
            "total_output_tokens": 397,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    N, T = map(int, input().split())\n    \n    # Initialize a list to keep track of changes in scores\n    events = [defaultdict(lambda: 0) for _ in range(T + 1)]\n    \n    # Read all updates and store them in appropriate time slots\n    for i in range(1, T + 1):\n        A_i, B_i = map(int, input().split())\n        events[i][A_i] += B_i\n    \n    # Current scores of each player\n    current_scores = [0] * (N + 1)\n    \n    # Set to keep track of unique score values at any given moment\n    unique_score_values = set()\n    \n    results = []\n    \n    # Process each second up to T seconds\n    for t in range(1, T + 1):\n        if len(unique_score_values) > 0:\n            previous_unique_count = len(unique_score_values)\n        \n        # Apply the update for this second\n        for player_id, increment in events[t].items():\n            current_scores[player_id] += increment\n        \n        # Update the set of unique score values\n        unique_score_values.clear()\n        for score in current_scores[1:]:\n            unique_score_values.add(score)\n        \n        # If it's not the first event, append the result\n        if t != 1:\n            results.append(len(previous_unique_count))\n    \n    # Print the number of different score values after each half-second interval\n    for count in results:\n        print(count)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc305_e",
            "difficulty": "hard",
            "total_time": 27.389288902282715,
            "code_generation_time": 19.471657752990723,
            "passed_tests": 0,
            "total_tests": 31,
            "success_rate": 0.0,
            "total_input_tokens": 1260,
            "total_output_tokens": 465,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict, deque\n\ndef bfs(graph, start):\n    queue = deque([start])\n    visited = set()\n    distances = {node: float('inf') for node in range(1, len(graph) + 1)}\n    distances[start] = 0\n    \n    while queue:\n        current = queue.popleft()\n        if current in visited:\n            continue\n        visited.add(current)\n        \n        for neighbor in graph[current]:\n            if distances[neighbor] > distances[current] + 1:\n                distances[neighbor] = distances[current] + 1\n                queue.append(neighbor)\n    \n    return distances\n\ndef solve():\n    import sys\n    input = sys.stdin.read().splitlines()\n    \n    N, M, K = map(int, input[0].split())\n    \n    # Build the adjacency list representation of the graph\n    graph = defaultdict(list)\n    index = 1\n    for _ in range(M):\n        a_i, b_i = map(int, input[index].split())\n        graph[a_i].append(b_i)\n        graph[b_i].append(a_i)\n        index += 1\n    \n    guards = []\n    for _ in range(K):\n        p_i, h_i = map(int, input[index].split())\n        guards.append((p_i, h_i))\n        index += 1\n    \n    guarded_vertices = [False] * (N + 1)\n    \n    for guard_position, stamina in guards:\n        distances_from_guard = bfs(graph, guard_position)\n        for vertex, distance in enumerate(distances_from_guard, start=1):\n            if distance <= stamina and not guarded_vertices[vertex]:\n                guarded_vertices[vertex] = True\n    \n    result = [vertex for vertex in range(1, N + 1) if guarded_vertices[vertex]]\n    result.sort()\n    \n    print(len(result))\n    print(\" \".join(map(str, result)))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc311_c",
            "difficulty": "medium",
            "total_time": 20.072007179260254,
            "code_generation_time": 19.282723665237427,
            "passed_tests": 12,
            "total_tests": 51,
            "success_rate": 0.24,
            "total_input_tokens": 1036,
            "total_output_tokens": 484,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef find_cycle(N, adj):\n    visited = [False] * N\n    rec_stack = set()\n    \n    def dfs(node, path):\n        if node in rec_stack:\n            # Cycle detected\n            start_index = path.index(node)\n            return path[start_index:]\n        \n        if visited[node]:\n            return None\n        \n        visited[node] = True\n        rec_stack.add(node)\n        result = dfs(adj[node], path + [node])\n        rec_stack.remove(node)\n        \n        return result\n    \n    for i in range(N):\n        if not visited[i]:\n            cycle = dfs(i, [])\n            if cycle:\n                return len(cycle), ' '.join(map(str, map(lambda x: x+1, cycle)))\n    \n    return -1, \"\"\n\nif __name__ == \"__main__\":\n    import sys\n    data = sys.stdin.read().splitlines()\n    N = int(data[0].strip())\n    A = list(map(int, data[1].strip().split()))\n    adj = [a-1 for a in A]\n    M, B = find_cycle(N, adj)\n    print(M)\n    print(B)",
            "history_file": null
        },
        {
            "question_id": "abc326_e",
            "difficulty": "hard",
            "total_time": 27.832106590270996,
            "code_generation_time": 17.6207058429718,
            "passed_tests": 2,
            "total_tests": 27,
            "success_rate": 0.07,
            "total_input_tokens": 1135,
            "total_output_tokens": 402,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom fractions import Fraction\n\ndef extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    gcd, x1, y1 = extended_gcd(b % a, a)\n    x = y1 - (b // a) * x1\n    y = x1\n    return gcd, x, y\n\nMOD = 998244353\n\ndef mod_inverse(a, m):\n    _, x, _ = extended_gcd(a, m)\n    return x % m\n\nif __name__ == \"__main__\":\n    input = sys.stdin.read().split()\n    \n    N = int(input[0])\n    A = list(map(int, input[1:N+1]))\n    \n    total_prob = Fraction(0)\n    numerator_sum = Fraction(0)\n    \n    current_max = 0\n    \n    for i in range(N-1, -1, -1):\n        prob_to_roll_i_plus_1_or_greater = Fraction(current_max + 1, MOD)\n        \n        expected_value_if_continue = Fraction(A[i], MOD) / prob_to_roll_i_plus_1_or_greater\n        \n        new_total_prob = Fraction(i + 1, MOD) * (prob_to_roll_i_plus_1_or_greater ** (i))\n        \n        numerator_sum += new_total_prob * expected_value_if_continue\n        \n        current_max = max(current_max, i)\n    \n    result_fraction = numerator_sum.limit_denominator(MOD)\n    \n    z = (result_fraction.numerator * mod_inverse(result_fraction.denominator, MOD)) % MOD\n    \n    print(z)",
            "history_file": null
        },
        {
            "question_id": "3298",
            "difficulty": "hard",
            "total_time": 16.50303626060486,
            "code_generation_time": 15.536694288253784,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 676,
            "total_output_tokens": 337,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef max_consecutive_elements(nums):\n    n = len(nums)\n    \n    if n == 1:\n        return 1\n    \n    count_map = defaultdict(int)\n    modified_count_map = defaultdict(int)\n    \n    for num in nums:\n        count_map[num] += 1\n        modified_count_map[num + 1] += 1\n    \n    def find_max_length(counts):\n        current_num = None\n        length = 0\n        maxLength = 0\n        \n        for num in counts.keys():\n            if current_num is None or num - current_num > 1:\n                current_num = num\n                length = counts[num]\n            else:\n                length += min(length, counts[num])\n            \n            maxLength = max(maxLength, length)\n        \n        return maxLength\n    \n    original_max_length = find_max_length(count_map)\n    modified_max_length = find_max_length(modified_count_map)\n    \n    return max(original_max_length, modified_max_length)\n\nif __name__ == \"__main__\":\n    input_line = sys.stdin.readline().strip()\n    nums = list(map(int, input_line.split()))\n    result = max_consecutive_elements(nums)\n    print(result)",
            "history_file": null
        },
        {
            "question_id": "2824",
            "difficulty": "easy",
            "total_time": 13.363286018371582,
            "code_generation_time": 12.573155641555786,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 655,
            "total_output_tokens": 220,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef is_fascinating(n):\n    concatenated_number = str(n) + str(2 * n) + str(3 * n)\n    \n    if len(concatenated_number) != 9:\n        return False\n    \n    digit_count = [0] * 10\n    \n    for char in concatenated_number:\n        if char == '0':\n            return False\n        digit = int(char)\n        digit_count[digit] += 1\n        \n        if digit_count[digit] > 1:\n            return False\n    \n    return True\n\ndef main():\n    import sys\n    input_line = sys.stdin.readline().strip()\n    n = int(input_line)\n    \n    result = \"true\" if is_fascinating(n) else \"false\"\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": null
        },
        {
            "question_id": "abc313_c",
            "difficulty": "medium",
            "total_time": 19.243193864822388,
            "code_generation_time": 18.152302265167236,
            "passed_tests": 6,
            "total_tests": 27,
            "success_rate": 0.22,
            "total_input_tokens": 869,
            "total_output_tokens": 429,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import Counter\n\ndef solve():\n    n = int(sys.stdin.readline())\n    a = list(map(int, sys.stdin.readline().split()))\n    \n    if len(set(a)) == 1 or n <= 2:\n        print(0)\n        return\n    \n    # Count frequency of each number in the array\n    freq = sorted(list(Counter(a).items()), key=lambda x: x[0])\n    \n    total_operations = float('inf')\n    \n    # Try making all numbers equal to mid value where mid is average of two consecutive frequencies\n    left_sum = sum(x * y for x, y in freq[:-1]) + freq[-1][0] * (n - sum(y for _, y in freq))\n    right_count = n - sum(freq[i][1] for i in range(len(freq) - 1))\n    \n    for i in range(len(freq)):\n        current_value = freq[i][0]\n        \n        while True:\n            next_freq_index = bisect.bisect_left(freq, [current_value + 1], lo=i+1, hi=len(freq)-1)\n            \n            if next_freq_index >= len(freq):\n                break\n            \n            next_value = freq[next_freq_index][0]\n            operations_needed = ((next_value - current_value) // 2) * (freq[i][1] + right_count)\n            \n            total_operations = min(total_operations, operations_needed)\n            \n            current_value += 1\n        \n        left_sum -= freq[i][0] * freq[i][1]\n        right_count -= freq[i][1]\n\n    print(total_operations)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        },
        {
            "question_id": "abc307_e",
            "difficulty": "hard",
            "total_time": 33.106353759765625,
            "code_generation_time": 28.704888582229614,
            "passed_tests": 0,
            "total_tests": 21,
            "success_rate": 0.0,
            "total_input_tokens": 0,
            "total_output_tokens": 0,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = 998244353\n\ndef power(x, y):\n    if y == 0:\n        return 1\n    p = power(x, y // 2)\n    res = (p * p) % MOD\n    if y & 1:\n        res = (res * x) % MOD\n    return res\n\ndef solve():\n    import sys\n    data = sys.stdin.read().split()\n    n = int(data[0])\n    m = int(data[1])\n\n    # If there's only one person, we can assign any of the m values\n    if n == 1:\n        print(m)\n        return\n    \n    # Calculate (m - 1)^n using modular exponentiation\n    result = power((m - 1), n)\n    \n    # Subtract cases where all people have different numbers except possibly first/last being equal\n    if m > 2:\n        subtract_term = ((m - 2) ** (n - 1)) % MOD\n        result -= subtract_term\n        result += MOD  # Ensure non-negative result after subtraction\n        result %= MOD\n    \n    print(result)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": null
        }
    ]
}
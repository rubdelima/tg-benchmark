{
    "model": "gpt-oss:20b",
    "architecture": "multi-agent",
    "total_test_time": 18474.791481733322,
    "total_input_tokens": 532342,
    "total_output_tokens": 1186400,
    "score": 80.78148148148149,
    "tokens_per_second": 64.21723358409947,
    "difficulty_stats": {
        "easy": {
            "total": 30,
            "passed": 27,
            "percentage": 90.0
        },
        "medium": {
            "total": 30,
            "passed": 27,
            "percentage": 90.0
        },
        "hard": {
            "total": 30,
            "passed": 15,
            "percentage": 50.0
        }
    },
    "completed_at": "2025-12-03T12:52:10.814497",
    "results": [
        {
            "question_id": "abc341_b",
            "difficulty": "easy",
            "total_time": 48.19692373275757,
            "code_generation_time": 47.170360803604126,
            "passed_tests": 22,
            "total_tests": 22,
            "success_rate": 1.0,
            "total_input_tokens": 2951,
            "total_output_tokens": 3019,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n\n    N = int(next(it))\n    A = [int(next(it)) for _ in range(N)]\n    S = [0] * (N - 1)\n    T = [0] * (N - 1)\n    for i in range(N - 1):\n        S[i] = int(next(it))\n        T[i] = int(next(it))\n\n    for i in range(N - 1):\n        k = A[i] // S[i]\n        A[i + 1] += k * T[i]\n        # A[i] is no longer needed\n\n    print(A[N - 1])\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc341_b.json"
        },
        {
            "question_id": "1899_B",
            "difficulty": "hard",
            "total_time": 95.87058663368225,
            "code_generation_time": 95.34493446350098,
            "passed_tests": 39,
            "total_tests": 39,
            "success_rate": 1.0,
            "total_input_tokens": 10726,
            "total_output_tokens": 5867,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    t = int(next(it))\n    out_lines = []\n    for _ in range(t):\n        n = int(next(it))\n        a = [int(next(it)) for _ in range(n)]\n        # prefix sums\n        pref = [0] * (n + 1)\n        for i in range(1, n + 1):\n            pref[i] = pref[i - 1] + a[i - 1]\n        # find divisors\n        divs = []\n        i = 1\n        while i * i <= n:\n            if n % i == 0:\n                divs.append(i)\n                if i != n // i:\n                    divs.append(n // i)\n            i += 1\n        best = 0\n        for k in divs:\n            if k == n:\n                continue  # only one truck\n            cnt = n // k\n            min_sum = 10**18\n            max_sum = -10**18\n            for t_idx in range(cnt):\n                start = t_idx * k\n                s = pref[start + k] - pref[start]\n                if s < min_sum:\n                    min_sum = s\n                if s > max_sum:\n                    max_sum = s\n            diff = max_sum - min_sum\n            if diff > best:\n                best = diff\n        out_lines.append(str(best))\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/1899_B.json"
        },
        {
            "question_id": "abc332_b",
            "difficulty": "easy",
            "total_time": 17.15968918800354,
            "code_generation_time": 16.93961524963379,
            "passed_tests": 30,
            "total_tests": 30,
            "success_rate": 1.0,
            "total_input_tokens": 2494,
            "total_output_tokens": 1005,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    K = int(next(it))\n    G = int(next(it))\n    M = int(next(it))\n\n    glass = 0\n    mug = 0\n\n    for _ in range(K):\n        if glass == G:\n            glass = 0\n        elif mug == 0:\n            mug = M\n        else:\n            transfer = min(mug, G - glass)\n            mug -= transfer\n            glass += transfer\n\n    print(glass, mug)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc332_b.json"
        },
        {
            "question_id": "abc337_e",
            "difficulty": "hard",
            "total_time": 766.238600730896,
            "code_generation_time": 765.9625194072723,
            "passed_tests": 0,
            "total_tests": 25,
            "success_rate": 0.0,
            "total_input_tokens": 17889,
            "total_output_tokens": 51565,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport math\nfrom typing import List\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    N = int(data[0])\n    X = int(data[1]) if len(data) > 1 else None\n\n    # Minimal number of friends\n    M: int = math.ceil(math.log2(N)) if N > 1 else 0\n\n    # Build distribution\n    friends: List[List[int]] = [[] for _ in range(M)]\n    for bottle in range(1, N + 1):\n        for i in range(M):\n            if bottle & (1 << i):\n                friends[i].append(bottle)\n\n    # Output\n    out_lines: List[str] = []\n    out_lines.append(str(M))\n    for i in range(M):\n        if friends[i]:\n            line = [str(len(friends[i]))] + [str(b) for b in friends[i]]\n            out_lines.append(' '.join(line))\n        else:\n            out_lines.append('0')\n    # The answer (poisoned bottle)\n    out_lines.append(str(X))\n\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/abc337_e.json"
        },
        {
            "question_id": "3207",
            "difficulty": "easy",
            "total_time": 23.208709955215454,
            "code_generation_time": 22.61866068840027,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 2026,
            "total_output_tokens": 1435,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    # Expect at least three tokens\n    s1 = data[0]\n    s2 = data[1] if len(data) > 1 else ''\n    s3 = data[2] if len(data) > 2 else ''\n\n    # Strip surrounding double quotes if present\n    def strip_quotes(s: str) -> str:\n        if len(s) >= 2 and s[0] == '\"' and s[-1] == '\"':\n            return s[1:-1]\n        return s\n\n    s1 = strip_quotes(s1)\n    s2 = strip_quotes(s2)\n    s3 = strip_quotes(s3)\n\n    # Find longest common prefix length\n    p = 0\n    min_len = min(len(s1), len(s2), len(s3))\n    while p < min_len and s1[p] == s2[p] == s3[p]:\n        p += 1\n\n    if p == 0:\n        print(-1)\n    else:\n        deletions = (len(s1) - p) + (len(s2) - p) + (len(s3) - p)\n        print(deletions)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/3207.json"
        },
        {
            "question_id": "2837",
            "difficulty": "medium",
            "total_time": 881.1238570213318,
            "code_generation_time": 880.4942138195038,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 5596,
            "total_output_tokens": 60705,
            "error": null,
            "traceback": null,
            "code": "",
            "history_file": "gpt-oss_20b/2837.json"
        },
        {
            "question_id": "3331",
            "difficulty": "easy",
            "total_time": 34.348747968673706,
            "code_generation_time": 33.99813389778137,
            "passed_tests": 57,
            "total_tests": 57,
            "success_rate": 1.0,
            "total_input_tokens": 2179,
            "total_output_tokens": 2181,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n\n    # The last token is k\n    k = int(data[-1])\n\n    # All preceding tokens form the list literal\n    list_tokens = data[:-1]\n    list_str = \" \".join(list_tokens).strip()\n\n    # Remove surrounding brackets\n    if list_str.startswith('[') and list_str.endswith(']'):\n        list_str = list_str[1:-1]\n\n    # Split by comma and convert to integers\n    if list_str == '':\n        nums = []\n    else:\n        nums = [int(x.strip()) for x in list_str.split(',')]\n\n    # Count elements strictly less than k\n    ops = sum(1 for x in nums if x < k)\n\n    print(ops)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/3331.json"
        },
        {
            "question_id": "abc322_e",
            "difficulty": "hard",
            "total_time": 65.0736334323883,
            "code_generation_time": 62.49977707862854,
            "passed_tests": 44,
            "total_tests": 44,
            "success_rate": 1.0,
            "total_input_tokens": 3306,
            "total_output_tokens": 3939,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    K = int(next(it))\n    P = int(next(it))\n\n    costs = []\n    adds = []\n    for _ in range(N):\n        costs.append(int(next(it)))\n        adds.append([int(next(it)) for _ in range(K)])\n\n    B = P + 1                     # base for encoding\n    mult = [1] * K\n    for j in range(1, K):\n        mult[j] = mult[j - 1] * B\n\n    S = B ** K                    # number of states\n\n    # pre\u2011compute decoded vectors for every index\n    states = [[0] * K for _ in range(S)]\n    for idx in range(S):\n        tmp = idx\n        for j in range(K):\n            states[idx][j] = tmp % B\n            tmp //= B\n\n    INF = 10 ** 18\n    dp = [INF] * S\n    dp[0] = 0                     # zero state\n\n    # helper to encode a vector\n    def encode(vals):\n        return sum(vals[j] * mult[j] for j in range(K))\n\n    goal_idx = encode([P] * K)\n\n    for plan_idx in range(N):\n        next_dp = dp[:]          # copy current table\n        inc = adds[plan_idx]\n        cost = costs[plan_idx]\n        for s in range(S):\n            cur_cost = dp[s]\n            if cur_cost == INF:\n                continue\n            cur_vals = states[s]\n            new_vals = [min(P, cur_vals[j] + inc[j]) for j in range(K)]\n            t = encode(new_vals)\n            new_cost = cur_cost + cost\n            if next_dp[t] > new_cost:\n                next_dp[t] = new_cost\n        dp = next_dp\n\n    if dp[goal_idx] == INF:\n        print(-1)\n    else:\n        print(dp[goal_idx])\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc322_e.json"
        },
        {
            "question_id": "abc315_f",
            "difficulty": "hard",
            "total_time": 915.695360660553,
            "code_generation_time": 914.5892658233643,
            "passed_tests": 5,
            "total_tests": 66,
            "success_rate": 0.08,
            "total_input_tokens": 11738,
            "total_output_tokens": 62428,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport math\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    xs = [0] * N\n    ys = [0] * N\n    for i in range(N):\n        xs[i] = int(next(it))\n        ys[i] = int(next(it))\n\n    # maximum jump length we need to consider\n    L = 35\n    # pre\u2011compute powers of two up to L-2 (because exponent = i-j-2)\n    pow2 = [1.0] * (L - 1)          # pow2[k] = 2^k\n    for k in range(1, L - 1):\n        pow2[k] = pow2[k - 1] * 2.0\n\n    dp = [float('inf')] * N\n    dp[0] = 0.0\n\n    for i in range(1, N):\n        best = float('inf')\n        start = max(0, i - L)\n        for j in range(start, i):\n            dx = xs[i] - xs[j]\n            dy = ys[i] - ys[j]\n            dist = math.hypot(dx, dy)\n            if i == j + 1:\n                cost = dp[j] + dist\n            else:\n                # number of skipped checkpoints = i-j-1 > 0\n                # penalty = 2^(i-j-2)\n                penalty = pow2[i - j - 2]\n                cost = dp[j] + dist + penalty\n            if cost < best:\n                best = cost\n        dp[i] = best\n\n    # print with high precision\n    print(\"{:.20f}\".format(dp[N - 1]))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/abc315_f.json"
        },
        {
            "question_id": "abc335_a",
            "difficulty": "easy",
            "total_time": 10.598835706710815,
            "code_generation_time": 10.436280727386475,
            "passed_tests": 17,
            "total_tests": 17,
            "success_rate": 1.0,
            "total_input_tokens": 1697,
            "total_output_tokens": 612,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    s = data[0]\n    # Replace the last character with '4'\n    result = s[:-1] + '4'\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc335_a.json"
        },
        {
            "question_id": "abc304_b",
            "difficulty": "easy",
            "total_time": 44.04129195213318,
            "code_generation_time": 43.86410093307495,
            "passed_tests": 18,
            "total_tests": 18,
            "success_rate": 1.0,
            "total_input_tokens": 2362,
            "total_output_tokens": 2934,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n\n    # number of decimal digits\n    d = len(str(N))\n\n    if d <= 3:\n        answer = N\n    else:\n        k = d - 3\n        pow10 = 10 ** k\n        answer = (N // pow10) * pow10\n\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc304_b.json"
        },
        {
            "question_id": "abc341_a",
            "difficulty": "easy",
            "total_time": 13.628607988357544,
            "code_generation_time": 13.552170753479004,
            "passed_tests": 9,
            "total_tests": 9,
            "success_rate": 1.0,
            "total_input_tokens": 1614,
            "total_output_tokens": 841,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    N = int(data[0])\n    result = (\"10\" * N) + \"1\"\n    sys.stdout.write(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc341_a.json"
        },
        {
            "question_id": "2877",
            "difficulty": "medium",
            "total_time": 408.71061635017395,
            "code_generation_time": 408.07944798469543,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 11040,
            "total_output_tokens": 27749,
            "error": null,
            "traceback": null,
            "code": "import sys\n\n# -------------------------------------------------------------\n\ndef strip_quotes(s: str) -> str:\n    \"\"\"Remove leading/trailing double or single quotes if present.\"\"\"\n    if (s.startswith('\"') and s.endswith('\"')) or (s.startswith(\"'\") and s.endswith(\"'\")):\n        return s[1:-1]\n    return s\n\ndef merge(s: str, t: str) -> str:\n    \"\"\"Return the shortest string containing both s and t.\"\"\"\n    # Substring cases\n    if t in s:\n        return s\n    if s in t:\n        return t\n\n    # Find maximum overlap where suffix of s matches prefix of t\n    max_k = min(len(s), len(t))\n    overlap = 0\n    for k in range(max_k, 0, -1):\n        if s[-k:] == t[:k]:\n            overlap = k\n            break\n\n    return s + t[overlap:]\n\ndef solve() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n\n    # Input may contain quotes \u2013 strip them\n    a = strip_quotes(data[0])\n    b = strip_quotes(data[1]) if len(data) > 1 else ''\n    c = strip_quotes(data[2]) if len(data) > 2 else ''\n\n    strings = [a, b, c]\n    from itertools import permutations\n\n    best = None\n    for perm in permutations(strings):\n        tmp = merge(perm[0], perm[1])\n        candidate = merge(tmp, perm[2])\n\n        if best is None:\n            best = candidate\n        else:\n            if len(candidate) < len(best):\n                best = candidate\n            elif len(candidate) == len(best) and candidate < best:\n                best = candidate\n\n    print(best)\n\n# -------------------------------------------------------------\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/2877.json"
        },
        {
            "question_id": "2878",
            "difficulty": "medium",
            "total_time": 49.02001905441284,
            "code_generation_time": 48.24991989135742,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 2347,
            "total_output_tokens": 3181,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n\n    # All tokens except the last one belong to the array\n    array_tokens = data[:-1]\n    k = int(data[-1])\n\n    nums = []\n    for token in array_tokens:\n        # Remove brackets and commas\n        token = token.lstrip('[').rstrip('],')\n        if token:\n            nums.append(int(token))\n\n    n = len(nums)\n    diff = [0] * (n + 1)\n    current = 0\n\n    for i in range(n):\n        current += diff[i]\n        remaining = nums[i] - current\n        if remaining < 0:\n            print(\"false\")\n            return\n        if remaining > 0:\n            if i > n - k:\n                print(\"false\")\n                return\n            diff[i] += remaining\n            diff[i + k] -= remaining\n            current += remaining\n\n    print(\"true\")\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/2878.json"
        },
        {
            "question_id": "3263",
            "difficulty": "easy",
            "total_time": 162.7404124736786,
            "code_generation_time": 161.85615944862366,
            "passed_tests": 98,
            "total_tests": 100,
            "success_rate": 0.98,
            "total_input_tokens": 12008,
            "total_output_tokens": 10578,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport re\n\ndef min_cost(arr):\n    \"\"\"Return the minimum possible sum of the costs of three subarrays.\"\"\"\n    n = len(arr)\n    if n < 3:\n        return 0  # not enough elements to form three subarrays\n\n    best = float('inf')\n    # i is the last index of the first subarray\n    for i in range(0, n - 2):\n        # j is the last index of the second subarray\n        for j in range(i + 1, n - 1):\n            cost = arr[i + 1] + arr[j + 1]\n            if cost < best:\n                best = cost\n    return arr[0] + best\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data:\n        return\n\n    # Extract all integers from the input string\n    nums = [int(x) for x in re.findall(r'\\d+', data)]\n    if not nums:\n        return\n\n    # If the first number equals the length of the remaining numbers,\n    # treat it as the array length; otherwise the whole list is the array.\n    if len(nums) >= 2 and nums[0] == len(nums) - 1:\n        arr = nums[1:]\n    else:\n        arr = nums\n\n    # Edge case: array length less than 3 \u2192 no valid split\n    if len(arr) < 3:\n        print(0)\n        return\n\n    result = min_cost(arr)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/3263.json"
        },
        {
            "question_id": "abc339_d",
            "difficulty": "medium",
            "total_time": 374.9010136127472,
            "code_generation_time": 368.74182629585266,
            "passed_tests": 52,
            "total_tests": 52,
            "success_rate": 1.0,
            "total_input_tokens": 11841,
            "total_output_tokens": 23804,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque\nfrom typing import Deque, Tuple\n\ndef solve() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    board = []\n    start_positions = []\n\n    for i in range(N):\n        row = next(it)\n        board.append(row)\n        for j, ch in enumerate(row):\n            if ch == 'P':\n                start_positions.append((i, j))\n\n    # encode positions as single integers\n    start1 = start_positions[0][0] * N + start_positions[0][1]\n    start2 = start_positions[1][0] * N + start_positions[1][1]\n    total = N * N\n\n    # pre\u2011compute destination for every cell and direction\n    dirs = [(-1, 0), (1, 0), (0, -1), (0, 1)]          # up, down, left, right\n    next_cell = [[0] * 4 for _ in range(total)]\n    for idx in range(total):\n        r, c = divmod(idx, N)\n        for d, (dr, dc) in enumerate(dirs):\n            nr, nc = r + dr, c + dc\n            if 0 <= nr < N and 0 <= nc < N and board[nr][nc] != '#':\n                next_cell[idx][d] = nr * N + nc\n            else:\n                next_cell[idx][d] = idx\n\n    # BFS\n    visited = bytearray(total * total)\n    q: Deque[Tuple[int, int]] = deque()\n    q.append((start1, start2))\n    visited[start1 * total + start2] = 1\n    steps = 0\n\n    while q:\n        for _ in range(len(q)):\n            a, b = q.popleft()\n            for d in range(4):\n                na = next_cell[a][d]\n                nb = next_cell[b][d]\n                if na == nb:          # goal reached\n                    print(steps + 1)\n                    return\n                idx = na * total + nb\n                if not visited[idx]:\n                    visited[idx] = 1\n                    q.append((na, nb))\n        steps += 1\n\n    print(-1)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/abc339_d.json"
        },
        {
            "question_id": "3309",
            "difficulty": "easy",
            "total_time": 40.714232206344604,
            "code_generation_time": 40.12947487831116,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 2559,
            "total_output_tokens": 2613,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    # Read all tokens, join them to reconstruct the original string\n    tokens = sys.stdin.read().split()\n    if not tokens:\n        return\n    raw = ''.join(tokens)          # e.g. '[\"a\",\"aba\",\"ababa\",\"aa\"]'\n\n    # Remove surrounding brackets\n    if raw[0] == '[' and raw[-1] == ']':\n        raw = raw[1:-1]\n    else:\n        # malformed input \u2013 treat as empty list\n        raw = ''\n\n    # Split on commas and strip quotes/whitespace\n    words = []\n    for part in raw.split(','):\n        part = part.strip()\n        if part.startswith('\"') and part.endswith('\"'):\n            part = part[1:-1]\n        words.append(part)\n\n    n = len(words)\n    ans = 0\n    for i in range(n - 1):\n        a = words[i]\n        la = len(a)\n        for j in range(i + 1, n):\n            b = words[j]\n            if len(b) < la:\n                continue\n            if b.startswith(a) and b.endswith(a):\n                ans += 1\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/3309.json"
        },
        {
            "question_id": "2873",
            "difficulty": "medium",
            "total_time": 41.1792049407959,
            "code_generation_time": 40.02603340148926,
            "passed_tests": 94,
            "total_tests": 94,
            "success_rate": 1.0,
            "total_input_tokens": 2136,
            "total_output_tokens": 2585,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport math\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    n = int(data[0])\n\n    if n < 4:          # smallest sum of two primes is 2+2 = 4\n        print([])\n        return\n\n    # Sieve of Eratosthenes up to n\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    limit = int(math.isqrt(n))\n    for p in range(2, limit + 1):\n        if is_prime[p]:\n            step = p\n            start = p * p\n            for multiple in range(start, n + 1, step):\n                is_prime[multiple] = False\n\n    # Find all pairs\n    pairs = []\n    for x in range(2, n // 2 + 1):\n        y = n - x\n        if is_prime[x] and is_prime[y]:\n            pairs.append([x, y])\n\n    # Output\n    print(pairs)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/2873.json"
        },
        {
            "question_id": "abc322_a",
            "difficulty": "easy",
            "total_time": 11.121791124343872,
            "code_generation_time": 11.037243604660034,
            "passed_tests": 8,
            "total_tests": 8,
            "success_rate": 1.0,
            "total_input_tokens": 1841,
            "total_output_tokens": 642,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    s = next(it)\n    for i in range(n - 2):\n        if s[i:i+3] == \"ABC\":\n            print(i + 1)\n            return\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc322_a.json"
        },
        {
            "question_id": "3203",
            "difficulty": "hard",
            "total_time": 257.6189315319061,
            "code_generation_time": 257.08290362358093,
            "passed_tests": 0,
            "total_tests": 79,
            "success_rate": 0.0,
            "total_input_tokens": 1417,
            "total_output_tokens": 12985,
            "error": null,
            "traceback": null,
            "code": "",
            "history_file": "gpt-oss_20b/3203.json"
        },
        {
            "question_id": "3297",
            "difficulty": "medium",
            "total_time": 280.2070858478546,
            "code_generation_time": 279.5871956348419,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 1928,
            "total_output_tokens": 19275,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    word_token = next(it)\n    # Remove surrounding quotes if present\n    if word_token.startswith('\"') and word_token.endswith('\"'):\n        word = word_token[1:-1]\n    else:\n        word = word_token\n    # In case the word token contains quotes but not both ends (unlikely), strip them anyway\n    word = word.strip('\"')\n    try:\n        k = int(next(it))\n    except StopIteration:\n        # If k is on the same line without quotes, it might be part of the word token\n        # e.g., input: abacaba 3\n        # In that case, the word token is 'abacaba', and we already read k\n        # But if we didn't get k, we can't proceed\n        return\n    n = len(word)\n    # Find minimal t > 0 such that word[:n - k*t] == word[k*t:]\n    # t ranges from 1 to ceil(n/k)\n    max_t = (n + k - 1) // k\n    for t in range(1, max_t + 1):\n        m = n - k * t\n        if m < 0:\n            break\n        if word[:m] == word[k * t:]:\n            print(t)\n            return\n    # Fallback: should never reach here because t = ceil(n/k) always works\n    print(max_t)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/3297.json"
        },
        {
            "question_id": "3212",
            "difficulty": "hard",
            "total_time": 57.64052891731262,
            "code_generation_time": 56.86948347091675,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 2380,
            "total_output_tokens": 3770,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = 1_000_000_007\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n\n    nums = []\n    for token in data:\n        # remove brackets and commas from both ends\n        s = token.strip('[],')\n        if s:\n            nums.append(int(s))\n\n    # last occurrence of each value\n    last = {}\n    for i, v in enumerate(nums):\n        last[v] = i\n\n    max_right = -1\n    cut_count = 0\n    for i, v in enumerate(nums):\n        max_right = max(max_right, last[v])\n        if i == max_right:\n            cut_count += 1\n\n    # number of good partitions = 2^(cut_count-1)\n    answer = pow(2, cut_count - 1, MOD)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/3212.json"
        },
        {
            "question_id": "abc315_e",
            "difficulty": "hard",
            "total_time": 336.42678689956665,
            "code_generation_time": 334.0668308734894,
            "passed_tests": 6,
            "total_tests": 34,
            "success_rate": 0.18,
            "total_input_tokens": 19005,
            "total_output_tokens": 22018,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import deque\nfrom typing import List, Deque\n\ndef solve() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n\n    prereq: List[List[int]] = [[] for _ in range(n + 1)]\n    depend: List[List[int]] = [[] for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n        c = int(next(it))\n        for _ in range(c):\n            p = int(next(it))\n            prereq[i].append(p)\n            depend[p].append(i)\n\n    # Step 2: find all prerequisites of book 1\n    visited: List[bool] = [False] * (n + 1)\n    stack: List[int] = [1]\n    visited[1] = True\n    while stack:\n        v = stack.pop()\n        for p in prereq[v]:\n            if not visited[p]:\n                visited[p] = True\n                stack.append(p)\n\n    # Step 3: compute indegrees inside the visited set\n    indeg: List[int] = [0] * (n + 1)\n    for v in range(1, n + 1):\n        if visited[v]:\n            cnt = 0\n            for p in prereq[v]:\n                if visited[p]:\n                    cnt += 1\n            indeg[v] = cnt\n\n    # Step 4: Kahn's algorithm on the induced subgraph\n    q: Deque[int] = deque()\n    for v in range(1, n + 1):\n        if visited[v] and indeg[v] == 0:\n            q.append(v)\n\n    order: List[int] = []\n    while q:\n        v = q.popleft()\n        order.append(v)\n        for w in depend[v]:\n            if visited[w]:\n                indeg[w] -= 1\n                if indeg[w] == 0:\n                    q.append(w)\n\n    # Output all visited books except book 1\n    result = [str(v) for v in order if v != 1]\n    sys.stdout.write(\" \".join(result))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/abc315_e.json"
        },
        {
            "question_id": "abc323_c",
            "difficulty": "medium",
            "total_time": 44.890910387039185,
            "code_generation_time": 44.786813497543335,
            "passed_tests": 11,
            "total_tests": 11,
            "success_rate": 1.0,
            "total_input_tokens": 3401,
            "total_output_tokens": 2958,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n\n    N = int(next(it))\n    M = int(next(it))\n\n    A = [int(next(it)) for _ in range(M)]\n\n    S = [next(it) for _ in range(N)]\n\n    # 1. current totals\n    current = [0] * N\n    for i in range(N):\n        total = 0\n        s = S[i]\n        for j in range(M):\n            if s[j] == 'o':\n                total += A[j]\n        total += (i + 1)          # bonus\n        current[i] = total\n\n    # 2. maximum score of the other players\n    max_other = [0] * N\n    for i in range(N):\n        mx = 0\n        for j in range(N):\n            if j == i:\n                continue\n            if current[j] > mx:\n                mx = current[j]\n        max_other[i] = mx\n\n    # 3. answer for each player\n    out_lines = []\n    for i in range(N):\n        if current[i] > max_other[i]:\n            out_lines.append('0')\n            continue\n\n        unsolved = []\n        s = S[i]\n        for j in range(M):\n            if s[j] == 'x':\n                unsolved.append(A[j])\n\n        unsolved.sort(reverse=True)\n\n        needed = 0\n        new_total = current[i]\n        for score in unsolved:\n            new_total += score\n            needed += 1\n            if new_total > max_other[i]:\n                break\n\n        out_lines.append(str(needed))\n\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == '__main__':\n    main()",
            "history_file": "gpt-oss_20b/abc323_c.json"
        },
        {
            "question_id": "3172",
            "difficulty": "easy",
            "total_time": 17.47022008895874,
            "code_generation_time": 16.85977578163147,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 2362,
            "total_output_tokens": 991,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    m = int(next(it))\n    total = n * (n + 1) // 2\n    k = n // m\n    sum_multiples = m * k * (k + 1) // 2\n    answer = total - 2 * sum_multiples\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/3172.json"
        },
        {
            "question_id": "abc305_b",
            "difficulty": "easy",
            "total_time": 15.788021326065063,
            "code_generation_time": 15.682985782623291,
            "passed_tests": 11,
            "total_tests": 11,
            "success_rate": 1.0,
            "total_input_tokens": 1992,
            "total_output_tokens": 945,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    p, q = data[0], data[1]\n\n    # Map letters to indices\n    idx = {'A': 0, 'B': 1, 'C': 2, 'D': 3, 'E': 4, 'F': 5, 'G': 6}\n    dist = [3, 1, 4, 1, 5, 9]  # distances between consecutive points\n\n    i, j = idx[p], idx[q]\n    if i > j:\n        i, j = j, i\n\n    total = sum(dist[k] for k in range(i, j))\n    print(total)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc305_b.json"
        },
        {
            "question_id": "abc340_a",
            "difficulty": "easy",
            "total_time": 11.752070665359497,
            "code_generation_time": 11.651048421859741,
            "passed_tests": 10,
            "total_tests": 10,
            "success_rate": 1.0,
            "total_input_tokens": 1728,
            "total_output_tokens": 678,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    A = int(next(it))\n    B = int(next(it))\n    D = int(next(it))\n\n    terms = []\n    x = A\n    while x <= B:\n        terms.append(str(x))\n        x += D\n\n    sys.stdout.write(' '.join(terms))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc340_a.json"
        },
        {
            "question_id": "abc314_c",
            "difficulty": "medium",
            "total_time": 29.821237325668335,
            "code_generation_time": 29.269119024276733,
            "passed_tests": 27,
            "total_tests": 27,
            "success_rate": 1.0,
            "total_input_tokens": 2861,
            "total_output_tokens": 1398,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    M = int(next(it))\n    S = list(next(it))\n    colors = [int(next(it)) for _ in range(N)]\n\n    # positions per color (1-indexed colors)\n    pos = [[] for _ in range(M + 1)]\n    for idx, col in enumerate(colors):\n        pos[col].append(idx)\n\n    # perform shifts in order of colors\n    for col in range(1, M + 1):\n        indices = pos[col]\n        k = len(indices)\n        if k <= 1:\n            continue\n        last_char = S[indices[-1]]\n        # shift right by one\n        for j in range(k - 1, 0, -1):\n            S[indices[j]] = S[indices[j - 1]]\n        S[indices[0]] = last_char\n\n    sys.stdout.write(''.join(S))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc314_c.json"
        },
        {
            "question_id": "abc336_b",
            "difficulty": "easy",
            "total_time": 15.107834577560425,
            "code_generation_time": 14.949795484542847,
            "passed_tests": 17,
            "total_tests": 17,
            "success_rate": 1.0,
            "total_input_tokens": 1799,
            "total_output_tokens": 731,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    cnt = 0\n    while n % 2 == 0:\n        n //= 2\n        cnt += 1\n    print(cnt)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc336_b.json"
        },
        {
            "question_id": "2856",
            "difficulty": "medium",
            "total_time": 79.81534361839294,
            "code_generation_time": 78.83309888839722,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 5669,
            "total_output_tokens": 5129,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport re\nfrom collections import defaultdict\nfrom typing import List, DefaultDict\n\ndef solve() -> None:\n    data: str = sys.stdin.read()\n    # Extract all integers from the input (handles brackets, commas, spaces, etc.)\n    tokens: List[str] = data.split()\n    nums: List[int] = []\n    for tok in tokens:\n        nums.extend(map(int, re.findall(r'-?\\d+', tok)))\n\n    if not nums:\n        print(0)\n        return\n\n    n: int = len(nums)\n    totalDistinct: int = len(set(nums))\n\n    answer: int = 0\n    j: int = 0\n    freq: DefaultDict[int, int] = defaultdict(int)\n    distinctInWindow: int = 0\n\n    for i in range(n):\n        # Expand the window until it contains all distinct values\n        while j < n and distinctInWindow < totalDistinct:\n            x: int = nums[j]\n            if freq[x] == 0:\n                distinctInWindow += 1\n            freq[x] += 1\n            j += 1\n\n        if distinctInWindow == totalDistinct:\n            # All longer windows starting at i are also complete\n            answer += n - j + 1\n\n        # Move the left border one step to the right\n        y: int = nums[i]\n        freq[y] -= 1\n        if freq[y] == 0:\n            distinctInWindow -= 1\n\n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/2856.json"
        },
        {
            "question_id": "abc310_f",
            "difficulty": "hard",
            "total_time": 151.7063193321228,
            "code_generation_time": 151.42329502105713,
            "passed_tests": 24,
            "total_tests": 38,
            "success_rate": 0.63,
            "total_input_tokens": 3227,
            "total_output_tokens": 5913,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = 998244353\n\ndef solve() -> None:\n    data = list(map(int, sys.stdin.read().split()))\n    if not data:\n        return\n    n = data[0]\n    A = data[1:]\n\n    # DP arrays: prev[s] = probability that sum s is NOT achievable\n    prev = [0] * 11\n    curr = [0] * 11\n    prev[0] = 0\n    for s in range(1, 11):\n        prev[s] = 1\n\n    for a in A:\n        inv_a = pow(a, MOD - 2, MOD)\n        for s in range(11):\n            limit = a if a < s else s\n            sum_val = 0\n            # sum over v = 1 .. limit of prev[s-v]\n            for v in range(1, limit + 1):\n                sum_val += prev[s - v]\n                if sum_val >= MOD:\n                    sum_val -= MOD\n            term = (sum_val + (a - limit)) % MOD\n            curr[s] = prev[s] * term % MOD * inv_a % MOD\n        prev, curr = curr, prev  # swap\n\n    not_achievable = prev[10]\n    answer = (1 - not_achievable) % MOD\n    print(answer)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/abc310_f.json"
        },
        {
            "question_id": "abc333_e",
            "difficulty": "hard",
            "total_time": 1087.9765894412994,
            "code_generation_time": 1087.592634677887,
            "passed_tests": 0,
            "total_tests": 44,
            "success_rate": 0.0,
            "total_input_tokens": 18930,
            "total_output_tokens": 74630,
            "error": null,
            "traceback": null,
            "code": "",
            "history_file": "gpt-oss_20b/abc333_e.json"
        },
        {
            "question_id": "2867",
            "difficulty": "medium",
            "total_time": 365.4911205768585,
            "code_generation_time": 364.72742772102356,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 8024,
            "total_output_tokens": 24641,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = 10 ** 9 + 7\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n\n    # Extract integers from tokens that may contain brackets or commas\n    nums = []\n    for token in data:\n        cleaned = token.strip('[],')\n        if cleaned:\n            nums.append(int(cleaned))\n\n    ones = [i for i, v in enumerate(nums) if v == 1]\n\n    if not ones:\n        print(0)\n        return\n    if len(ones) == 1:\n        print(1)\n        return\n\n    ans = 1\n    for prev, cur in zip(ones, ones[1:]):\n        ans = (ans * (cur - prev)) % MOD\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/2867.json"
        },
        {
            "question_id": "abc324_e",
            "difficulty": "hard",
            "total_time": 373.2266435623169,
            "code_generation_time": 372.16784024238586,
            "passed_tests": 40,
            "total_tests": 40,
            "success_rate": 1.0,
            "total_input_tokens": 19780,
            "total_output_tokens": 24588,
            "error": null,
            "traceback": null,
            "code": "#!/usr/bin/env python3\nimport sys\nimport bisect\n\ndef solve() -> None:\n    data = sys.stdin.read().split()\n    it = iter(data)\n    try:\n        n = int(next(it))\n    except StopIteration:\n        return\n    T = next(it)\n    t_len = len(T)\n\n    pref = []\n    suff = []\n\n    # Precompute reversed T for suffix matching\n    rev_T = T[::-1]\n\n    for _ in range(n):\n        s = next(it)\n        # pref_i\n        p = 0\n        for ch in s:\n            if p < t_len and ch == T[p]:\n                p += 1\n        pref.append(p)\n\n        # suff_i\n        p = t_len - 1\n        for ch in reversed(s):\n            if p >= 0 and ch == T[p]:\n                p -= 1\n        suff_len = t_len - 1 - p\n        suff.append(suff_len)\n\n    suff.sort()\n    total_pairs = 0\n    for pi in pref:\n        need = t_len - pi\n        if need <= 0:\n            total_pairs += n\n        else:\n            idx = bisect.bisect_left(suff, need)\n            total_pairs += n - idx\n\n    print(total_pairs)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/abc324_e.json"
        },
        {
            "question_id": "abc318_d",
            "difficulty": "medium",
            "total_time": 121.97789025306702,
            "code_generation_time": 121.58137249946594,
            "passed_tests": 17,
            "total_tests": 17,
            "success_rate": 1.0,
            "total_input_tokens": 8403,
            "total_output_tokens": 7966,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n\n    # Build symmetric weight matrix\n    w = [[0] * n for _ in range(n)]\n    for i in range(n):\n        for j in range(i + 1, n):\n            val = int(next(it))\n            w[i][j] = w[j][i] = val\n\n    size = 1 << n\n    dp = [0] * size\n\n    for mask in range(1, size):\n        # If fewer than two vertices are left, nothing can be added\n        if mask & (mask - 1) == 0:\n            continue\n\n        low_bit = mask & -mask          # lowest set bit\n        i = low_bit.bit_length() - 1    # index of that vertex\n\n        # Option 1: leave the lowest vertex unmatched\n        best = dp[mask ^ low_bit]\n\n        # Option 2: pair it with any other vertex in the mask\n        rest = mask ^ low_bit\n        sub = rest\n        while sub:\n            j_bit = sub & -sub\n            j = j_bit.bit_length() - 1\n            new_mask = mask ^ low_bit ^ j_bit\n            cand = w[i][j] + dp[new_mask]\n            if cand > best:\n                best = cand\n            sub ^= j_bit\n\n        dp[mask] = best\n\n    print(dp[size - 1])\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/abc318_d.json"
        },
        {
            "question_id": "abc343_c",
            "difficulty": "medium",
            "total_time": 35.493796586990356,
            "code_generation_time": 34.917515993118286,
            "passed_tests": 29,
            "total_tests": 29,
            "success_rate": 1.0,
            "total_input_tokens": 2319,
            "total_output_tokens": 2245,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef is_palindrome(num: int) -> bool:\n    s = str(num)\n    return s == s[::-1]\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    N = int(data[0])\n\n    best = 0\n    x = 1\n    while True:\n        cube = x * x * x\n        if cube > N:\n            break\n        if is_palindrome(cube):\n            best = cube\n        x += 1\n\n    print(best)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc343_c.json"
        },
        {
            "question_id": "abc309_e",
            "difficulty": "hard",
            "total_time": 595.5593905448914,
            "code_generation_time": 584.5147659778595,
            "passed_tests": 42,
            "total_tests": 51,
            "success_rate": 0.82,
            "total_input_tokens": 25144,
            "total_output_tokens": 35184,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom typing import List, Tuple\n\nsys.setrecursionlimit(1 << 25)\n\ndef solve() -> None:\n    data = list(map(int, sys.stdin.read().split()))\n    it = iter(data)\n\n    N = next(it)\n    M = next(it)\n\n    # build tree\n    g: List[List[int]] = [[] for _ in range(N + 1)]\n    for v in range(2, N + 1):\n        p = next(it)\n        g[p].append(v)\n\n    # DFS: depth, tin, tout, vertices by depth\n    depth: List[int] = [0] * (N + 1)\n    tin: List[int] = [0] * (N + 1)\n    tout: List[int] = [0] * (N + 1)\n    depth_list: List[List[int]] = []          # will grow to max_depth+1\n    timer = 0\n\n    def dfs(v: int, d: int) -> None:\n        nonlocal timer\n        if d == len(depth_list):\n            depth_list.append([])\n        depth_list[d].append(v)\n        depth[v] = d\n        tin[v] = timer\n        timer += 1\n        for to in g[v]:\n            dfs(to, d + 1)\n        tout[v] = timer - 1\n\n    dfs(1, 0)\n    max_depth = len(depth_list) - 1\n\n    # events per depth\n    events: List[List[Tuple[int, int, int]]] = [[] for _ in range(max_depth + 2)]  # +1 for possible +y+1\n    for _ in range(M):\n        x = next(it)\n        y = next(it)\n        d = depth[x]\n        l = tin[x]\n        r = tout[x]\n        events[d].append((l, r, 1))\n        end_depth = d + y + 1\n        if end_depth <= max_depth + 1:\n            events[end_depth].append((l, r, -1))\n\n    # Fenwick tree for range add / point query\n    class Fenwick:\n        __slots__ = ('n', 'bit')\n        def __init__(self, n: int) -> None:\n            self.n = n\n            self.bit: List[int] = [0] * (n + 2)\n\n        def _add(self, idx: int, delta: int) -> None:\n            while idx <= self.n:\n                self.bit[idx] += delta\n                idx += idx & -idx\n\n        def range_add(self, l: int, r: int, delta: int) -> None:\n            self._add(l, delta)\n            self._add(r + 1, -delta)\n\n        def point_query(self, idx: int) -> int:\n            s = 0\n            while idx > 0:\n                s += self.bit[idx]\n                idx -= idx & -idx\n            return s\n\n    fenwick = Fenwick(N + 2)\n    ans = 0\n\n    for d in range(max_depth + 1):\n        for l, r, delta in events[d]:\n            fenwick.range_add(l + 1, r + 1, delta)   # 1\u2011based Fenwick\n        for v in depth_list[d]:\n            if fenwick.point_query(tin[v] + 1) > 0:\n                ans += 1\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/abc309_e.json"
        },
        {
            "question_id": "abc338_d",
            "difficulty": "hard",
            "total_time": 123.52058124542236,
            "code_generation_time": 122.75433778762817,
            "passed_tests": 27,
            "total_tests": 27,
            "success_rate": 1.0,
            "total_input_tokens": 4278,
            "total_output_tokens": 8247,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve() -> None:\n    data = list(map(int, sys.stdin.read().strip().split()))\n    if not data:\n        return\n    N, M = data[0], data[1]\n    X = data[2:]\n\n    diff = [0] * (N + 2)          # indices 1 \u2026 N+1\n    base = 0\n\n    def add_range(l: int, r: int, val: int) -> None:\n        \"\"\"add val to all bridges l \u2026 r (inclusive, modulo N)\"\"\"\n        if l <= r:                 # no wrap\n            diff[l]     += val\n            diff[r + 1] -= val\n        else:                      # wrap around\n            diff[l]     += val\n            diff[N + 1] -= val\n            diff[1]     += val\n            diff[r + 1] -= val\n\n    for k in range(M - 1):\n        a = X[k]\n        b = X[k + 1]\n        if a == b:                 # no travel needed\n            continue\n\n        d_cw = (b - a + N) % N\n        d_ccw = N - d_cw\n\n        shorter = d_cw if d_cw < d_ccw else d_ccw\n        base += shorter\n\n        if d_cw == d_ccw:          # equal directions \u2013 no penalty\n            continue\n\n        penalty = abs(d_cw - d_ccw)\n\n        if d_cw < d_ccw:           # shorter path is clockwise\n            l = a\n            r = (b - 1 + N) % N\n            if r == 0:\n                r = N\n            add_range(l, r, penalty)\n        else:                      # shorter path is counter\u2011clockwise\n            l = b\n            r = (a - 1 + N) % N\n            if r == 0:\n                r = N\n            add_range(l, r, penalty)\n\n    cur = 0\n    INF = 10 ** 18\n    min_penalty = INF\n    for i in range(1, N + 1):\n        cur += diff[i]\n        if cur < min_penalty:\n            min_penalty = cur\n\n    print(base + min_penalty)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/abc338_d.json"
        },
        {
            "question_id": "abc329_f",
            "difficulty": "hard",
            "total_time": 363.0536608695984,
            "code_generation_time": 359.38916015625,
            "passed_tests": 42,
            "total_tests": 42,
            "success_rate": 1.0,
            "total_input_tokens": 14726,
            "total_output_tokens": 23592,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom typing import Dict, List\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    Q = int(next(it))\n\n    # boxes[1..N], each is a dict: color -> count\n    boxes: List[Dict[int, int]] = [dict() for _ in range(N + 1)]\n    for i in range(1, N + 1):\n        color = int(next(it))\n        boxes[i][color] = 1\n\n    out_lines: List[str] = []\n\n    for _ in range(Q):\n        a = int(next(it))\n        b = int(next(it))\n\n        # Ensure boxes[a] is the smaller dict\n        if len(boxes[a]) > len(boxes[b]):\n            boxes[a], boxes[b] = boxes[b], boxes[a]\n\n        small = boxes[a]\n        large = boxes[b]\n\n        # Merge small into large\n        for col, cnt in small.items():\n            large[col] = large.get(col, 0) + cnt\n\n        # Empty the source box\n        boxes[a] = {}\n\n        out_lines.append(str(len(large)))\n\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc329_f.json"
        },
        {
            "question_id": "abc306_c",
            "difficulty": "medium",
            "total_time": 20.791924476623535,
            "code_generation_time": 20.316521883010864,
            "passed_tests": 16,
            "total_tests": 16,
            "success_rate": 1.0,
            "total_input_tokens": 2619,
            "total_output_tokens": 1192,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    total = 3 * N\n    first = [0] * (N + 1)\n    second = [0] * (N + 1)\n\n    for pos in range(1, total + 1):\n        v = int(next(it))\n        if first[v] == 0:\n            first[v] = pos\n        elif second[v] == 0:\n            second[v] = pos\n        # third occurrence ignored\n\n    pairs = [(i, second[i]) for i in range(1, N + 1)]\n    pairs.sort(key=lambda x: x[1])\n\n    output = ' '.join(str(pair[0]) for pair in pairs)\n    sys.stdout.write(output + '\\n')\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc306_c.json"
        },
        {
            "question_id": "abc331_b",
            "difficulty": "easy",
            "total_time": 23.73636507987976,
            "code_generation_time": 23.54081082344055,
            "passed_tests": 22,
            "total_tests": 22,
            "success_rate": 1.0,
            "total_input_tokens": 1973,
            "total_output_tokens": 1460,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    S = int(next(it))\n    M = int(next(it))\n    L = int(next(it))\n\n    # Helper for ceil division\n    def ceil_div(a, b):\n        return (a + b - 1) // b\n\n    max6 = ceil_div(N, 6) + 1\n    max8 = ceil_div(N, 8) + 1\n\n    best_cost = float('inf')\n\n    for i in range(max6 + 1):          # number of 6\u2011egg packs\n        for j in range(max8 + 1):      # number of 8\u2011egg packs\n            eggs = 6 * i + 8 * j\n            if eggs >= N:\n                k = 0\n            else:\n                k = ceil_div(N - eggs, 12)\n            cost = i * S + j * M + k * L\n            if cost < best_cost:\n                best_cost = cost\n\n    print(best_cost)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc331_b.json"
        },
        {
            "question_id": "2869",
            "difficulty": "medium",
            "total_time": 58.85311007499695,
            "code_generation_time": 57.58506512641907,
            "passed_tests": 83,
            "total_tests": 83,
            "success_rate": 1.0,
            "total_input_tokens": 2944,
            "total_output_tokens": 3731,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport re\n\ndef main() -> None:\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    # Extract all integers from the input\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n\n    # The input contains exactly two arrays of equal length\n    n = len(nums) // 2\n    nums1 = nums[:n]\n    nums2 = nums[n:]\n\n    # DP variables: previous values for dp1 and dp2\n    prev1 = 1\n    prev2 = 1\n    answer = 1\n\n    for i in range(1, n):\n        curr1 = 1\n        if nums1[i - 1] <= nums1[i]:\n            curr1 = max(curr1, prev1 + 1)\n        if nums2[i - 1] <= nums1[i]:\n            curr1 = max(curr1, prev2 + 1)\n\n        curr2 = 1\n        if nums1[i - 1] <= nums2[i]:\n            curr2 = max(curr2, prev1 + 1)\n        if nums2[i - 1] <= nums2[i]:\n            curr2 = max(curr2, prev2 + 1)\n\n        answer = max(answer, curr1, curr2)\n\n        prev1, prev2 = curr1, curr2\n\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/2869.json"
        },
        {
            "question_id": "abc332_d",
            "difficulty": "hard",
            "total_time": 55.4240939617157,
            "code_generation_time": 55.11701965332031,
            "passed_tests": 38,
            "total_tests": 38,
            "success_rate": 1.0,
            "total_input_tokens": 5082,
            "total_output_tokens": 3564,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport itertools\n\ndef inversion_count(perm):\n    \"\"\"Return number of inversions of a permutation (list of ints).\"\"\"\n    n = len(perm)\n    inv = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if perm[i] > perm[j]:\n                inv += 1\n    return inv\n\ndef main() -> None:\n    data = list(map(int, sys.stdin.read().split()))\n    if not data:\n        return\n    it = iter(data)\n    H = next(it)\n    W = next(it)\n\n    # read matrix A\n    A = [[next(it) for _ in range(W)] for _ in range(H)]\n    # read matrix B\n    B = [[next(it) for _ in range(W)] for _ in range(H)]\n\n    row_indices = list(range(H))\n    col_indices = list(range(W))\n\n    best = None  # None means not found yet\n\n    for p in itertools.permutations(row_indices):\n        for q in itertools.permutations(col_indices):\n            ok = True\n            for i in range(H):\n                ai = A[p[i]]\n                for j in range(W):\n                    if ai[q[j]] != B[i][j]:\n                        ok = False\n                        break\n                if not ok:\n                    break\n            if ok:\n                cost = inversion_count(p) + inversion_count(q)\n                if best is None or cost < best:\n                    best = cost\n\n    if best is None:\n        print(-1)\n    else:\n        print(best)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc332_d.json"
        },
        {
            "question_id": "abc322_c",
            "difficulty": "medium",
            "total_time": 20.0575692653656,
            "code_generation_time": 19.613996028900146,
            "passed_tests": 27,
            "total_tests": 27,
            "success_rate": 1.0,
            "total_input_tokens": 2362,
            "total_output_tokens": 1161,
            "error": null,
            "traceback": null,
            "code": "import sys\n\n# Increase recursion depth just in case\nsys.setrecursionlimit(200000)\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    M = int(next(it))\n    A = [int(next(it)) for _ in range(M)]\n    \n    ans = [0] * N\n    idx = 0  # index in A\n    for i in range(1, N + 1):\n        # Move idx until A[idx] >= i\n        while idx < M and A[idx] < i:\n            idx += 1\n        # idx is guaranteed < M because A[M-1] == N\n        ans[i - 1] = A[idx] - i\n    \n    sys.stdout.write(\"\\n\".join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc322_c.json"
        },
        {
            "question_id": "3094",
            "difficulty": "medium",
            "total_time": 64.44427847862244,
            "code_generation_time": 63.292009115219116,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 5861,
            "total_output_tokens": 4001,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport re\nfrom typing import Dict\n\ndef solve() -> None:\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    # Extract all integers from the input string\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n\n    if not nums:\n        print(-1)\n        return\n\n    # Frequency map with explicit type annotation\n    freq: Dict[int, int] = {}\n    for x in nums:\n        freq[x] = freq.get(x, 0) + 1\n\n    total_ops = 0\n    for cnt in freq.values():\n        if cnt == 1:\n            print(-1)\n            return\n        if cnt % 3 == 0:\n            ops = cnt // 3\n        elif cnt % 3 == 1:\n            if cnt < 4:\n                print(-1)\n                return\n            ops = (cnt - 4) // 3 + 2\n        else:  # cnt % 3 == 2\n            ops = (cnt - 2) // 3 + 1\n        total_ops += ops\n\n    print(total_ops)\n\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/3094.json"
        },
        {
            "question_id": "abc312_b",
            "difficulty": "easy",
            "total_time": 264.9695644378662,
            "code_generation_time": 264.8395035266876,
            "passed_tests": 1,
            "total_tests": 14,
            "success_rate": 0.07,
            "total_input_tokens": 1453,
            "total_output_tokens": 16384,
            "error": null,
            "traceback": null,
            "code": "",
            "history_file": "gpt-oss_20b/abc312_b.json"
        },
        {
            "question_id": "1899_C",
            "difficulty": "hard",
            "total_time": 26.71378993988037,
            "code_generation_time": 25.81448268890381,
            "passed_tests": 106,
            "total_tests": 106,
            "success_rate": 1.0,
            "total_input_tokens": 2694,
            "total_output_tokens": 1555,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    t = int(next(it))\n    out_lines = []\n    for _ in range(t):\n        n = int(next(it))\n        a = [int(next(it)) for _ in range(n)]\n        best = -10**18\n        prev_dp = 0  # placeholder, will be set at i=0\n        for i in range(n):\n            if i == 0:\n                curr_dp = a[0]\n            else:\n                if (a[i] & 1) == (a[i-1] & 1):  # same parity\n                    curr_dp = a[i]\n                else:\n                    curr_dp = max(a[i], prev_dp + a[i])\n            best = max(best, curr_dp)\n            prev_dp = curr_dp\n        out_lines.append(str(best))\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/1899_C.json"
        },
        {
            "question_id": "3228",
            "difficulty": "medium",
            "total_time": 95.12018394470215,
            "code_generation_time": 94.15310215950012,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 3321,
            "total_output_tokens": 6276,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport re\n\ndef solve() -> None:\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    # Extract all integers from the input string\n    numbers = list(map(int, re.findall(r'\\d+', data)))\n\n    total = len(numbers)\n    n = total // 2          # arrays have equal length\n    nums1 = numbers[:n]\n    nums2 = numbers[n:]\n\n    set1 = set(nums1)\n    set2 = set(nums2)\n\n    a = len(set1 - set2)    # only in nums1\n    b = len(set2 - set1)    # only in nums2\n    c = len(set1 & set2)    # in both\n\n    half = n // 2\n    keepA = min(a, half)\n    keepB = min(b, half)\n    cap1 = half - keepA\n    cap2 = half - keepB\n    keepC = min(c, cap1 + cap2)\n\n    print(keepA + keepB + keepC)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/3228.json"
        },
        {
            "question_id": "abc318_b",
            "difficulty": "easy",
            "total_time": 21.93551278114319,
            "code_generation_time": 21.727208375930786,
            "passed_tests": 21,
            "total_tests": 21,
            "success_rate": 1.0,
            "total_input_tokens": 2454,
            "total_output_tokens": 1328,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    # grid of 100x100 unit squares\n    covered = [[False] * 100 for _ in range(100)]\n    for _ in range(n):\n        a = int(next(it))\n        b = int(next(it))\n        c = int(next(it))\n        d = int(next(it))\n        # mark squares with lower-left corner (x,y)\n        for x in range(a, b):\n            row = covered[x]\n            for y in range(c, d):\n                row[y] = True\n    area = 0\n    for x in range(100):\n        area += sum(covered[x])\n    print(area)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc318_b.json"
        },
        {
            "question_id": "abc333_c",
            "difficulty": "medium",
            "total_time": 175.0757555961609,
            "code_generation_time": 174.93747353553772,
            "passed_tests": 17,
            "total_tests": 17,
            "success_rate": 1.0,
            "total_input_tokens": 719,
            "total_output_tokens": 1037,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n\n    # Generate repunits up to length 12 (enough for N \u2264 333)\n    repunits = [int('1' * i) for i in range(1, 13)]\n\n    sums_set = set()\n    L = len(repunits)\n    for i in range(L):\n        for j in range(L):\n            for k in range(L):\n                sums_set.add(repunits[i] + repunits[j] + repunits[k])\n\n    sums_list = sorted(sums_set)\n    # N is 1-indexed\n    print(sums_list[N - 1])\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc333_c.json"
        },
        {
            "question_id": "abc314_b",
            "difficulty": "easy",
            "total_time": 36.208282709121704,
            "code_generation_time": 36.0107307434082,
            "passed_tests": 20,
            "total_tests": 20,
            "success_rate": 1.0,
            "total_input_tokens": 3145,
            "total_output_tokens": 2288,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n\n    N = int(next(it))\n    C = []\n    bets = []\n\n    for _ in range(N):\n        c = int(next(it))\n        C.append(c)\n        person_bets = [int(next(it)) for _ in range(c)]\n        bets.append(person_bets)\n\n    X = int(next(it))\n\n    minC = 38          # larger than any possible C[i] (max 37)\n    answer = []\n\n    for idx in range(N):\n        if X in bets[idx]:\n            if C[idx] < minC:\n                minC = C[idx]\n                answer = [idx + 1]          # 1\u2011based index\n            elif C[idx] == minC:\n                answer.append(idx + 1)\n\n    K = len(answer)\n    print(K)\n    if K:\n        print(' '.join(map(str, answer)))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc314_b.json"
        },
        {
            "question_id": "abc324_d",
            "difficulty": "hard",
            "total_time": 317.9864456653595,
            "code_generation_time": 308.16173219680786,
            "passed_tests": 17,
            "total_tests": 43,
            "success_rate": 0.4,
            "total_input_tokens": 12046,
            "total_output_tokens": 18285,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport math\n\ndef solve() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n\n    N = int(data[0])\n    S = data[1]\n\n    # frequency of digits in S\n    freqS = [0] * 10\n    for ch in S:\n        freqS[ord(ch) - 48] += 1\n    freqS_tuple = tuple(freqS)\n\n    limit = 10 ** N - 1\n    max_i = math.isqrt(limit)\n\n    count = 0\n    for i in range(max_i + 1):          # i^2 is a square \u2264 limit\n        s = str(i)\n        zeros_needed = N - len(s)\n\n        freqX = [0] * 10\n        for ch in s:\n            freqX[ord(ch) - 48] += 1\n        freqX[0] += zeros_needed\n\n        if tuple(freqX) == freqS_tuple:\n            count += 1\n\n    print(count)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/abc324_d.json"
        },
        {
            "question_id": "3019",
            "difficulty": "easy",
            "total_time": 119.97033095359802,
            "code_generation_time": 119.35434365272522,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 5827,
            "total_output_tokens": 7557,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n\n    # The input is expected to be a single string (possibly surrounded by quotes)\n    moves = data[0].strip('\"')\n\n    cntL = cntR = cntU = 0\n    for ch in moves:\n        if ch == 'L':\n            cntL += 1\n        elif ch == 'R':\n            cntR += 1\n        elif ch == '_':\n            cntU += 1\n        # other characters are ignored (should not appear)\n\n    answer = abs(cntR - cntL) + cntU\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/3019.json"
        },
        {
            "question_id": "abc334_d",
            "difficulty": "medium",
            "total_time": 37.74404835700989,
            "code_generation_time": 36.39376759529114,
            "passed_tests": 24,
            "total_tests": 24,
            "success_rate": 1.0,
            "total_input_tokens": 2565,
            "total_output_tokens": 2216,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport bisect\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    Q = int(next(it))\n\n    R = [int(next(it)) for _ in range(N)]\n    queries = [int(next(it)) for _ in range(Q)]\n\n    R.sort()\n    pref = [0] * (N + 1)\n    for i in range(1, N + 1):\n        pref[i] = pref[i - 1] + R[i - 1]\n\n    out_lines = []\n    for X in queries:\n        # bisect_right returns first index where pref[idx] > X\n        k = bisect.bisect_right(pref, X) - 1\n        out_lines.append(str(k))\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc334_d.json"
        },
        {
            "question_id": "abc309_c",
            "difficulty": "medium",
            "total_time": 57.66981053352356,
            "code_generation_time": 56.26356768608093,
            "passed_tests": 27,
            "total_tests": 27,
            "success_rate": 1.0,
            "total_input_tokens": 3266,
            "total_output_tokens": 3564,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    K = int(next(it))\n\n    meds = []\n    total = 0\n    maxA = 0\n\n    for _ in range(N):\n        a = int(next(it))\n        b = int(next(it))\n        meds.append((a, b))\n        total += b\n        if a > maxA:\n            maxA = a\n\n    # If already small enough on day 1\n    if total <= K:\n        print(1)\n        return\n\n    meds.sort(key=lambda x: x[0])\n\n    i = 0\n    while i < N:\n        curA = meds[i][0]\n        group_sum = 0\n        while i < N and meds[i][0] == curA:\n            group_sum += meds[i][1]\n            i += 1\n        total -= group_sum\n        if total <= K:\n            print(curA + 1)\n            return\n\n    # All medicines finished\n    print(maxA + 1)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc309_c.json"
        },
        {
            "question_id": "abc343_b",
            "difficulty": "easy",
            "total_time": 20.751256704330444,
            "code_generation_time": 20.60577654838562,
            "passed_tests": 14,
            "total_tests": 14,
            "success_rate": 1.0,
            "total_input_tokens": 2741,
            "total_output_tokens": 929,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    matrix = [[int(next(it)) for _ in range(N)] for _ in range(N)]\n    out_lines = []\n    for i in range(N):\n        neighbors = [str(j + 1) for j in range(N) if matrix[i][j] == 1]\n        out_lines.append(' '.join(neighbors))\n    sys.stdout.write('\\n'.join(out_lines))\n\nif __name__ == '__main__':\n    main()",
            "history_file": "gpt-oss_20b/abc343_b.json"
        },
        {
            "question_id": "abc333_a",
            "difficulty": "easy",
            "total_time": 12.911842823028564,
            "code_generation_time": 12.810902833938599,
            "passed_tests": 7,
            "total_tests": 7,
            "success_rate": 1.0,
            "total_input_tokens": 1510,
            "total_output_tokens": 709,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    try:\n        n = int(next(it))\n    except StopIteration:\n        return\n    # Convert n to its digit character\n    digit = str(n)\n    # Repeat the digit n times\n    result = digit * n\n    sys.stdout.write(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc333_a.json"
        },
        {
            "question_id": "abc312_c",
            "difficulty": "medium",
            "total_time": 53.981953144073486,
            "code_generation_time": 53.20686984062195,
            "passed_tests": 41,
            "total_tests": 41,
            "success_rate": 1.0,
            "total_input_tokens": 2493,
            "total_output_tokens": 3405,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport bisect\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    M = int(next(it))\n    A = [int(next(it)) for _ in range(N)]\n    B = [int(next(it)) for _ in range(M)]\n\n    A.sort()\n    B.sort()\n\n    max_val = max(A[-1] if A else 0, B[-1] if B else 0)\n    low = 1\n    high = max_val + 1  # at this value no buyer can buy\n\n    while low < high:\n        mid = (low + high) // 2\n        sellers = bisect.bisect_right(A, mid)          # A[i] <= mid\n        buyers = M - bisect.bisect_left(B, mid)        # B[i] >= mid\n        if sellers >= buyers:\n            high = mid\n        else:\n            low = mid + 1\n\n    print(low)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc312_c.json"
        },
        {
            "question_id": "abc312_f",
            "difficulty": "hard",
            "total_time": 783.1497480869293,
            "code_generation_time": 781.4560534954071,
            "passed_tests": 29,
            "total_tests": 43,
            "success_rate": 0.67,
            "total_input_tokens": 16678,
            "total_output_tokens": 51564,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    M = int(next(it))\n\n    pull = []      # type 0\n    reg = []       # type 1\n    opener = []    # type 2\n\n    for _ in range(N):\n        t = int(next(it))\n        v = int(next(it))\n        if t == 0:\n            pull.append(v)\n        elif t == 1:\n            reg.append(v)\n        else:          # t == 2\n            opener.append(v)\n\n    # sort in non\u2011increasing order\n    pull.sort(reverse=True)\n    reg.sort(reverse=True)\n    opener.sort(reverse=True)\n\n    # prefix sums helper\n    def pref(arr):\n        p = [0]\n        for x in arr:\n            p.append(p[-1] + x)\n        return p\n\n    P = pref(pull)      # pull\n    R = pref(reg)       # regular\n    C = pref(opener)    # capacities\n\n    # minimal number of openers for each k\n    t_k = [0] * (len(reg) + 1)\n    t = 0\n    for k in range(len(reg) + 1):\n        while t < len(opener) and C[t] < k:\n            t += 1\n        t_k[k] = t          # if t > len(opener) it will be impossible\n\n    best = 0\n    max_k = min(len(reg), M)\n    for k in range(max_k + 1):\n        t = t_k[k]\n        if t > len(opener) or k + t > M:\n            continue\n        rest = M - k - t\n        pull_take = min(rest, len(pull))\n        value = R[k] + P[pull_take]\n        if value > best:\n            best = value\n\n    print(best)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/abc312_f.json"
        },
        {
            "question_id": "3225",
            "difficulty": "medium",
            "total_time": 40.33938002586365,
            "code_generation_time": 39.01264405250549,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 2591,
            "total_output_tokens": 2326,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom collections import defaultdict\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n\n    # Find the token that ends with ']'\n    idx = None\n    for i, token in enumerate(data):\n        if token.endswith(']'):\n            idx = i\n            break\n    if idx is None:\n        raise ValueError(\"Array token not found\")\n\n    # Tokens belonging to the array\n    arr_tokens = data[:idx + 1]\n    # Token for k\n    if idx + 1 >= len(data):\n        raise ValueError(\"k value missing\")\n    k_token = data[idx + 1]\n\n    # Reconstruct the array string\n    arr_str = ' '.join(arr_tokens).strip()\n    if arr_str[0] == '[':\n        arr_str = arr_str[1:]\n    if arr_str and arr_str[-1] == ']':\n        arr_str = arr_str[:-1]\n\n    # Parse numbers\n    if arr_str.strip() == '':\n        nums = []\n    else:\n        nums = [int(x.strip()) for x in arr_str.split(',')]\n\n    k = int(k_token)\n\n    # Sliding window\n    freq = defaultdict(int)\n    left = 0\n    max_len = 0\n\n    for right, val in enumerate(nums):\n        freq[val] += 1\n        while freq[val] > k:\n            freq[nums[left]] -= 1\n            if freq[nums[left]] == 0:\n                del freq[nums[left]]\n            left += 1\n        cur_len = right - left + 1\n        if cur_len > max_len:\n            max_len = cur_len\n\n    print(max_len)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/3225.json"
        },
        {
            "question_id": "abc303_e",
            "difficulty": "hard",
            "total_time": 1458.6204814910889,
            "code_generation_time": 1458.1367678642273,
            "passed_tests": 0,
            "total_tests": 18,
            "success_rate": 0.0,
            "total_input_tokens": 7936,
            "total_output_tokens": 98304,
            "error": null,
            "traceback": null,
            "code": "",
            "history_file": "gpt-oss_20b/abc303_e.json"
        },
        {
            "question_id": "abc305_a",
            "difficulty": "easy",
            "total_time": 19.159221410751343,
            "code_generation_time": 19.070018768310547,
            "passed_tests": 7,
            "total_tests": 7,
            "success_rate": 1.0,
            "total_input_tokens": 1983,
            "total_output_tokens": 1082,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    r = N % 5\n    if r <= 2:\n        ans = N - r\n    else:\n        ans = N + (5 - r)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc305_a.json"
        },
        {
            "question_id": "2884",
            "difficulty": "hard",
            "total_time": 525.8424534797668,
            "code_generation_time": 519.2987089157104,
            "passed_tests": 99,
            "total_tests": 100,
            "success_rate": 0.99,
            "total_input_tokens": 11650,
            "total_output_tokens": 32846,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport collections\nimport ast\n\n# ---------- Aho\u2013Corasick automaton ----------\nclass Node:\n    __slots__ = ('next', 'fail', 'out')\n    def __init__(self):\n        self.next = [-1] * 26          # transitions for 'a'..'z'\n        self.fail = 0                 # failure link\n        self.out = []                 # pattern lengths ending here\n\nclass AhoCorasick:\n    def __init__(self):\n        self.nodes = [Node()]         # root node\n\n    def insert(self, pattern: str):\n        node = 0\n        for ch in pattern:\n            c = ord(ch) - 97          # 'a' -> 0\n            nxt = self.nodes[node].next[c]\n            if nxt == -1:\n                nxt = len(self.nodes)\n                self.nodes[node].next[c] = nxt\n                self.nodes.append(Node())\n            node = nxt\n        self.nodes[node].out.append(len(pattern))\n\n    def build(self):\n        q = collections.deque()\n        # initialise fail links of depth\u20111 nodes\n        for c in range(26):\n            nxt = self.nodes[0].next[c]\n            if nxt != -1:\n                self.nodes[nxt].fail = 0\n                q.append(nxt)\n            else:\n                self.nodes[0].next[c] = 0   # missing transition to root\n\n        # BFS\n        while q:\n            r = q.popleft()\n            for c in range(26):\n                s = self.nodes[r].next[c]\n                if s != -1:\n                    q.append(s)\n                    f = self.nodes[r].fail\n                    while self.nodes[f].next[c] == -1:\n                        f = self.nodes[f].fail\n                    self.nodes[s].fail = self.nodes[f].next[c]\n                    self.nodes[s].out += self.nodes[self.nodes[s].fail].out\n                else:\n                    self.nodes[r].next[c] = self.nodes[self.nodes[r].fail].next[c]\n\n    def step(self, node: int, ch: str) -> int:\n        return self.nodes[node].next[ord(ch) - 97]\n\n# ---------- robust input parsing ----------\ndef parse_input(data: str):\n    \"\"\"\n    Accepts the two formats used in the official tests:\n      1. word on the first line, list literal on the second line\n      2. word on the first line, space\u2011separated forbidden strings on the\n         second line\n    Leading/trailing quotes around the word are removed if present.\n    \"\"\"\n    lines = [line.strip() for line in data.strip().splitlines() if line.strip()]\n    if not lines:\n        return \"\", []\n\n    # word\n    word_line = lines[0]\n    if (word_line.startswith('\"') and word_line.endswith('\"')) or \\\n       (word_line.startswith(\"'\") and word_line.endswith(\"'\")):\n        word = word_line[1:-1]\n    else:\n        word = word_line\n\n    forbidden = []\n    if len(lines) >= 2:\n        second = lines[1]\n        if second.startswith('[') and second.endswith(']'):\n            try:\n                forbidden = ast.literal_eval(second)\n                if not isinstance(forbidden, list):\n                    forbidden = []\n            except Exception:\n                forbidden = []\n        else:\n            forbidden = second.split()\n    return word, forbidden\n\n# ---------- main ----------\ndef main():\n    data = sys.stdin.read()\n    word, forbidden = parse_input(data)\n\n    if not word or not forbidden:\n        print(0)\n        return\n\n    ac = AhoCorasick()\n    for pat in forbidden:\n        ac.insert(pat)\n    ac.build()\n\n    last_forbidden_start = -1\n    best = 0\n    node = 0\n\n    for i, ch in enumerate(word):\n        node = ac.step(node, ch)\n        for L in ac.nodes[node].out:\n            start = i - L + 1\n            if start > last_forbidden_start:\n                last_forbidden_start = start\n        cur_len = i - last_forbidden_start\n        if cur_len > best:\n            best = cur_len\n\n    print(best)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/2884.json"
        },
        {
            "question_id": "2866",
            "difficulty": "easy",
            "total_time": 37.01171851158142,
            "code_generation_time": 36.365731954574585,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 2839,
            "total_output_tokens": 2201,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    # The last token is the threshold\n    threshold_token = data[-1]\n    try:\n        threshold = int(threshold_token)\n    except ValueError:\n        # In case the threshold token still contains brackets (unlikely)\n        threshold = int(threshold_token.strip('[],'))\n\n    # All preceding tokens belong to the array\n    array_tokens = data[:-1]\n    nums = []\n    for token in array_tokens:\n        # Remove leading '[' and trailing ']' and commas\n        cleaned = token.strip('[],')\n        if cleaned == '':\n            continue\n        nums.append(int(cleaned))\n\n    max_len = 0\n    cur_len = 0\n    prev_parity = None  # 0 for even, 1 for odd\n\n    for val in nums:\n        if val > threshold:\n            cur_len = 0\n            prev_parity = None\n            continue\n\n        parity = val % 2\n        if cur_len == 0:\n            if parity == 0:  # even start\n                cur_len = 1\n                prev_parity = 0\n            else:\n                cur_len = 0\n                prev_parity = None\n        else:\n            if parity != prev_parity:\n                cur_len += 1\n                prev_parity = parity\n            else:\n                # alternation broken\n                if parity == 0:  # can start new subarray here\n                    cur_len = 1\n                    prev_parity = 0\n                else:\n                    cur_len = 0\n                    prev_parity = None\n        if cur_len > max_len:\n            max_len = cur_len\n\n    print(max_len)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/2866.json"
        },
        {
            "question_id": "3320",
            "difficulty": "easy",
            "total_time": 27.65858292579651,
            "code_generation_time": 27.04263734817505,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 2159,
            "total_output_tokens": 1578,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    # Reconstruct the input string from tokens\n    s = ' '.join(data)\n    # Remove brackets and commas\n    s = s.replace('[', '').replace(']', '').replace(',', '')\n    # Split into individual number strings\n    tokens = s.split()\n    nums = [int(tok) for tok in tokens if tok]\n    n = len(nums)\n    if n < 2:\n        print(0)\n        return\n    target = nums[0] + nums[1]\n    count = 1\n    i = 2\n    while i + 1 < n:\n        if nums[i] + nums[i + 1] == target:\n            count += 1\n            i += 2\n        else:\n            break\n    print(count)\n\nif __name__ == '__main__':\n    main()",
            "history_file": "gpt-oss_20b/3320.json"
        },
        {
            "question_id": "abc315_b",
            "difficulty": "easy",
            "total_time": 15.576788902282715,
            "code_generation_time": 15.391921520233154,
            "passed_tests": 24,
            "total_tests": 24,
            "success_rate": 1.0,
            "total_input_tokens": 2332,
            "total_output_tokens": 802,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    M = int(next(it))\n    D = [int(next(it)) for _ in range(M)]\n\n    total = sum(D)\n    target = (total + 1) // 2  # middle day index (1-indexed)\n\n    cumulative = 0\n    for idx, days in enumerate(D, start=1):\n        cumulative += days\n        if cumulative >= target:\n            day_in_month = target - (cumulative - days)\n            print(idx, day_in_month)\n            return\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc315_b.json"
        },
        {
            "question_id": "abc313_a",
            "difficulty": "easy",
            "total_time": 16.11487603187561,
            "code_generation_time": 15.995327234268188,
            "passed_tests": 12,
            "total_tests": 12,
            "success_rate": 1.0,
            "total_input_tokens": 1899,
            "total_output_tokens": 866,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    # Read N abilities\n    abilities = [int(next(it)) for _ in range(n)]\n    # Person 1 is at index 0\n    p1 = abilities[0]\n    if n == 1:\n        print(0)\n        return\n    max_other = max(abilities[1:])\n    if p1 > max_other:\n        print(0)\n    else:\n        print(max_other - p1 + 1)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc313_a.json"
        },
        {
            "question_id": "abc329_e",
            "difficulty": "hard",
            "total_time": 753.7991478443146,
            "code_generation_time": 753.1079821586609,
            "passed_tests": 36,
            "total_tests": 48,
            "success_rate": 0.75,
            "total_input_tokens": 14007,
            "total_output_tokens": 49266,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    M = int(next(it))\n    S = next(it)\n    T = next(it)\n\n    max_start = N - M\n    for i in range(N):\n        ok = False\n        for k in range(M):\n            j = i - k\n            if 0 <= j <= max_start and T[k] == S[i]:\n                ok = True\n                break\n        if not ok:\n            print(\"No\")\n            return\n    print(\"Yes\")\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc329_e.json"
        },
        {
            "question_id": "3223",
            "difficulty": "hard",
            "total_time": 592.6057147979736,
            "code_generation_time": 590.3081035614014,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 16556,
            "total_output_tokens": 38526,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    word_token = next(it)\n    # remove possible surrounding quotes\n    word = word_token.strip('\"').strip(\"'\")\n    k = int(next(it))\n\n    n = len(word)\n    if k > n:\n        print(0)\n        return\n\n    # good[i] == True  <=>  |word[i] - word[i+1]| <= 2\n    good = [False] * (n - 1)\n    for i in range(n - 1):\n        if abs(ord(word[i]) - ord(word[i + 1])) <= 2:\n            good[i] = True\n\n    ans = 0\n    i = 0\n    while i < n:\n        seg_start = i\n        while i < n - 1 and good[i]:\n            i += 1\n        seg_end = i          # inclusive\n        seg_len = seg_end - seg_start + 1\n\n        # process this segment\n        for m in range(1, 27):\n            L = k * m\n            if L > seg_len:\n                break\n\n            cnt = [0] * 26\n            bad = 0\n\n            def add(idx: int) -> None:\n                nonlocal bad\n                old = cnt[idx]\n                new = old + 1\n                if old == 0 or old == k:\n                    if new != 0 and new != k:\n                        bad += 1\n                else:\n                    if new == 0 or new == k:\n                        bad -= 1\n                cnt[idx] = new\n\n            def remove(idx: int) -> None:\n                nonlocal bad\n                old = cnt[idx]\n                new = old - 1\n                if old == 0 or old == k:\n                    if new != 0 and new != k:\n                        bad += 1\n                else:\n                    if new == 0 or new == k:\n                        bad -= 1\n                cnt[idx] = new\n\n            # first window\n            for pos in range(seg_start, seg_start + L):\n                add(ord(word[pos]) - 97)\n            if bad == 0:\n                ans += 1\n\n            # slide\n            for r in range(seg_start + L, seg_end + 1):\n                add(ord(word[r]) - 97)\n                remove(ord(word[r - L]) - 97)\n                if bad == 0:\n                    ans += 1\n\n        i += 1\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/3223.json"
        },
        {
            "question_id": "3017",
            "difficulty": "hard",
            "total_time": 82.23185682296753,
            "code_generation_time": 81.30616402626038,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 6870,
            "total_output_tokens": 5019,
            "error": null,
            "traceback": null,
            "code": "import sys\nfrom functools import lru_cache\n\n# -------------------------------------------------------------\n\ndef solve() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    low = int(next(it))\n    high = int(next(it))\n    k = int(next(it))\n\n    # ---------------------------------------------------------\n    # digit DP: count numbers <= N that are beautiful\n    def count_up_to(N: int) -> int:\n        if N <= 0:\n            return 0\n        s = str(N)\n        n = len(s)\n\n        @lru_cache(maxsize=None)\n        def dfs(pos: int, tight: int, started: int, diff: int, mod: int) -> int:\n            if pos == n:\n                # number finished\n                return int(started == 1 and diff == 0 and mod == 0)\n\n            limit = int(s[pos]) if tight else 9\n            total = 0\n            for d in range(0, limit + 1):\n                new_tight = tight and (d == limit)\n                new_started = started or (d != 0)\n\n                if new_started:\n                    # update diff and mod\n                    new_diff = diff + (1 if d % 2 == 0 else -1)\n                    new_mod = (mod * 10 + d) % k\n                else:\n                    new_diff = diff          # still 0\n                    new_mod = 0\n\n                total += dfs(pos + 1, new_tight, new_started, new_diff, new_mod)\n            return total\n\n        return dfs(0, 1, 0, 0, 0)\n\n    # ---------------------------------------------------------\n    ans = count_up_to(high) - count_up_to(low - 1)\n    print(ans)\n\n\n# -------------------------------------------------------------\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/3017.json"
        },
        {
            "question_id": "abc301_a",
            "difficulty": "easy",
            "total_time": 23.75263810157776,
            "code_generation_time": 23.656942129135132,
            "passed_tests": 12,
            "total_tests": 12,
            "success_rate": 1.0,
            "total_input_tokens": 2165,
            "total_output_tokens": 1381,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    try:\n        n = int(next(it))\n    except StopIteration:\n        return\n    try:\n        s = next(it)\n    except StopIteration:\n        s = ''\n    # Ensure s length matches n, but we trust input\n    totalT = s.count('T')\n    totalA = n - totalT  # since only T and A\n    if totalT > totalA:\n        sys.stdout.write('T')\n        return\n    if totalA > totalT:\n        sys.stdout.write('A')\n        return\n    # tie case\n    target = totalT  # same as totalA\n    curT = curA = 0\n    for ch in s:\n        if ch == 'T':\n            curT += 1\n        else:\n            curA += 1\n        if curT == target:\n            sys.stdout.write('T')\n            return\n        if curA == target:\n            sys.stdout.write('A')\n            return\n\nif __name__ == '__main__':\n    main()",
            "history_file": "gpt-oss_20b/abc301_a.json"
        },
        {
            "question_id": "3210",
            "difficulty": "medium",
            "total_time": 108.64059638977051,
            "code_generation_time": 107.77755999565125,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 7201,
            "total_output_tokens": 6739,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef solve() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n\n    vowels = set('aeiou')\n    out_lines = []\n    idx = 0\n\n    # The input may contain several pairs (string, integer).\n    while idx + 1 < len(data):\n        s_token = data[idx]\n        k = int(data[idx + 1])\n        idx += 2\n\n        # Remove possible surrounding quotes from the string token\n        s = s_token.strip('\"').strip(\"'\")\n        n = len(s)\n\n        # Prefix sums for vowels and consonants\n        prefV = [0] * (n + 1)\n        prefC = [0] * (n + 1)\n        for i, ch in enumerate(s):\n            prefV[i + 1] = prefV[i] + (1 if ch in vowels else 0)\n            prefC[i + 1] = prefC[i] + (0 if ch in vowels else 1)\n\n        ans = 0\n        for i in range(n):\n            for j in range(i, n):\n                v = prefV[j + 1] - prefV[i]\n                c = prefC[j + 1] - prefC[i]\n                if v == c and (v * c) % k == 0:\n                    ans += 1\n\n        out_lines.append(str(ans))\n\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/3210.json"
        },
        {
            "question_id": "3200",
            "difficulty": "medium",
            "total_time": 87.08418941497803,
            "code_generation_time": 86.24387049674988,
            "passed_tests": 87,
            "total_tests": 87,
            "success_rate": 1.0,
            "total_input_tokens": 2359,
            "total_output_tokens": 5590,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = 1_000_000_007\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    n = int(data[0])\n\n    # pre\u2011compute powers\n    pow26 = [1] * (n + 1)\n    pow25 = [1] * (n + 1)\n    pow24 = [1] * (n + 1)\n    pow23 = [1] * (n + 1)\n\n    for i in range(1, n + 1):\n        pow26[i] = (pow26[i - 1] * 26) % MOD\n        pow25[i] = (pow25[i - 1] * 25) % MOD\n        pow24[i] = (pow24[i - 1] * 24) % MOD\n        pow23[i] = (pow23[i - 1] * 23) % MOD\n\n    term1 = pow26[n]                                 # 26^n\n\n    # 3*25^n + n*25^(n-1)\n    term2 = (3 * pow25[n] + n * pow25[n - 1]) % MOD\n\n    # 3*24^n + 2*n*24^(n-1)\n    term3 = (3 * pow24[n] + 2 * n * pow24[n - 1]) % MOD\n\n    # 23^n + n*23^(n-1)\n    term4 = (pow23[n] + n * pow23[n - 1]) % MOD\n\n    bad = (term2 - term3 + term4) % MOD\n    good = (term1 - bad) % MOD\n\n    print(good)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/3200.json"
        },
        {
            "question_id": "abc329_c",
            "difficulty": "medium",
            "total_time": 23.6159770488739,
            "code_generation_time": 23.391661882400513,
            "passed_tests": 17,
            "total_tests": 17,
            "success_rate": 1.0,
            "total_input_tokens": 2061,
            "total_output_tokens": 1359,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    s = next(it)\n\n    # Array to store maximum run length for each character\n    max_len = [0] * 26\n\n    # Initialize with first character\n    cur_char = s[0]\n    cur_run = 1\n\n    for i in range(1, n):\n        if s[i] == cur_char:\n            cur_run += 1\n        else:\n            idx = ord(cur_char) - ord('a')\n            if cur_run > max_len[idx]:\n                max_len[idx] = cur_run\n            cur_char = s[i]\n            cur_run = 1\n\n    # Update for the last run\n    idx = ord(cur_char) - ord('a')\n    if cur_run > max_len[idx]:\n        max_len[idx] = cur_run\n\n    # Sum of maximum run lengths gives the answer\n    answer = sum(max_len)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc329_c.json"
        },
        {
            "question_id": "3025",
            "difficulty": "hard",
            "total_time": 358.7991259098053,
            "code_generation_time": 353.2394587993622,
            "passed_tests": 86,
            "total_tests": 100,
            "success_rate": 0.86,
            "total_input_tokens": 12946,
            "total_output_tokens": 21912,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport bisect\nimport re\n\ndef solve() -> None:\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    # Extract all integers (array elements + target)\n    nums = list(map(int, re.findall(r'-?\\d+', data)))\n    if len(nums) < 2:\n        # Not enough data\n        print(-1)\n        return\n\n    target = nums[-1]\n    arr = nums[:-1]\n\n    if sum(arr) < target:\n        print(-1)\n        return\n\n    # multiset of current pieces, sorted ascending\n    pieces = sorted(arr)\n    operations = 0\n    remaining = target\n\n    while remaining > 0:\n        # find rightmost element <= remaining\n        idx = bisect.bisect_right(pieces, remaining) - 1\n        if idx >= 0:\n            # use this piece\n            val = pieces.pop(idx)\n            remaining -= val\n            continue\n\n        # no usable piece \u2013 split the largest one\n        largest = pieces.pop()          # largest element\n        half = largest // 2\n        # insert half twice, keeping the list sorted\n        bisect.insort(pieces, half)\n        bisect.insort(pieces, half)\n        operations += 1\n\n    print(operations)\n\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/3025.json"
        },
        {
            "question_id": "abc323_d",
            "difficulty": "hard",
            "total_time": 420.64561223983765,
            "code_generation_time": 411.4693398475647,
            "passed_tests": 19,
            "total_tests": 30,
            "success_rate": 0.63,
            "total_input_tokens": 10263,
            "total_output_tokens": 25659,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport heapq\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    cnt = {}\n    for _ in range(n):\n        s = int(next(it))\n        c = int(next(it))\n        cnt[s] = c\n\n    heap = list(cnt.keys())\n    heapq.heapify(heap)\n\n    while heap:\n        x = heapq.heappop(heap)\n        c = cnt.get(x, 0)\n        if c == 0:\n            continue\n        pairs = c // 2\n        rem = c % 2\n        cnt[x] = rem\n        if pairs:\n            nx = x * 2\n            cnt[nx] = cnt.get(nx, 0) + pairs\n            heapq.heappush(heap, nx)\n\n    result = sum(cnt.values())\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc323_d.json"
        },
        {
            "question_id": "abc334_e",
            "difficulty": "hard",
            "total_time": 78.84919738769531,
            "code_generation_time": 74.87130165100098,
            "passed_tests": 31,
            "total_tests": 31,
            "success_rate": 1.0,
            "total_input_tokens": 3305,
            "total_output_tokens": 4650,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = 998244353\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    H = int(next(it))\n    W = int(next(it))\n    grid = [list(next(it).strip()) for _ in range(H)]\n\n    N = H * W\n    parent = [-1] * N\n    rank = [0] * N\n\n    def find(x: int) -> int:\n        while parent[x] != x:\n            parent[x] = parent[parent[x]]\n            x = parent[x]\n        return x\n\n    def union(a: int, b: int) -> None:\n        ra, rb = find(a), find(b)\n        if ra == rb:\n            return\n        if rank[ra] < rank[rb]:\n            parent[ra] = rb\n        else:\n            parent[rb] = ra\n            if rank[ra] == rank[rb]:\n                rank[ra] += 1\n\n    R = 0  # number of red cells\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '#':\n                idx = i * W + j\n                parent[idx] = idx\n                if i > 0 and grid[i - 1][j] == '#':\n                    union(idx, idx - W)\n                if j > 0 and grid[i][j - 1] == '#':\n                    union(idx, idx - 1)\n            else:\n                R += 1\n\n    # count green components\n    seen = [False] * N\n    C = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '#':\n                idx = i * W + j\n                root = find(idx)\n                if not seen[root]:\n                    seen[root] = True\n                    C += 1\n\n    # sum of t over all red cells\n    sum_t = 0\n    for i in range(H):\n        for j in range(W):\n            if grid[i][j] == '.':\n                neigh_roots = []\n                if i > 0 and grid[i - 1][j] == '#':\n                    r = find((i - 1) * W + j)\n                    neigh_roots.append(r)\n                if i + 1 < H and grid[i + 1][j] == '#':\n                    r = find((i + 1) * W + j)\n                    if r not in neigh_roots:\n                        neigh_roots.append(r)\n                if j > 0 and grid[i][j - 1] == '#':\n                    r = find(i * W + j - 1)\n                    if r not in neigh_roots:\n                        neigh_roots.append(r)\n                if j + 1 < W and grid[i][j + 1] == '#':\n                    r = find(i * W + j + 1)\n                    if r not in neigh_roots:\n                        neigh_roots.append(r)\n                sum_t += len(neigh_roots)\n\n    invR = pow(R, MOD - 2, MOD)\n    term = (sum_t % MOD) * invR % MOD\n    ans = (C + 1 - term) % MOD\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc334_e.json"
        },
        {
            "question_id": "abc325_d",
            "difficulty": "hard",
            "total_time": 327.4342403411865,
            "code_generation_time": 324.5493381023407,
            "passed_tests": 44,
            "total_tests": 44,
            "success_rate": 1.0,
            "total_input_tokens": 7834,
            "total_output_tokens": 21284,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport heapq\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    jobs = []\n    for _ in range(n):\n        t = int(next(it))\n        d = int(next(it))\n        jobs.append((t, t + d))  # (release, deadline)\n\n    # Sort by release time\n    jobs.sort(key=lambda x: x[0])\n\n    heap: list[int] = []  # min-heap of deadlines\n    i = 0\n    cur = 0\n    count = 0\n\n    while i < n or heap:\n        # If no job is available now, jump to next release time\n        if not heap:\n            cur = jobs[i][0]\n        # Add all jobs whose release <= cur\n        while i < n and jobs[i][0] <= cur:\n            heapq.heappush(heap, jobs[i][1])\n            i += 1\n        if not heap:\n            continue\n        # Take job with earliest deadline\n        deadline = heapq.heappop(heap)\n        if deadline < cur:\n            # This job cannot be scheduled anymore\n            continue\n        # Schedule it at time cur\n        count += 1\n        cur += 1\n\n    print(count)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc325_d.json"
        },
        {
            "question_id": "3151",
            "difficulty": "medium",
            "total_time": 398.306036233902,
            "code_generation_time": 396.95008277893066,
            "passed_tests": 53,
            "total_tests": 53,
            "success_rate": 1.0,
            "total_input_tokens": 6139,
            "total_output_tokens": 26663,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport re\nimport ast\n\ndef solve_one(processors, tasks):\n    \"\"\"\n    Compute the minimal total time for one test case.\n    processors : list of n integers\n    tasks      : list of 4*n integers\n    \"\"\"\n    n = len(processors)\n    if len(tasks) != 4 * n:\n        # Unexpected format \u2013 cannot solve\n        return \"0\"\n\n    processors.sort()                     # increasing\n    tasks.sort(reverse=True)              # decreasing\n\n    best = 0\n    for i in range(n):\n        finish = processors[i] + tasks[4 * i]   # largest task of the group\n        if finish > best:\n            best = finish\n    return str(best)\n\n\ndef main():\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    # Try to find bracketed lists first\n    bracketed = re.findall(r'\\[.*?\\]', data, flags=re.S)\n    lists = []\n\n    if bracketed:\n        for s in bracketed:\n            try:\n                lst = ast.literal_eval(s)\n                if isinstance(lst, list):\n                    lists.append(lst)\n            except Exception:\n                pass\n    else:\n        # No brackets \u2013 split by lines and parse numbers\n        for line in data.strip().splitlines():\n            nums = list(map(int, re.findall(r'-?\\d+', line)))\n            if nums:\n                lists.append(nums)\n\n    # If the number of lists is odd, ignore the last one\n    if len(lists) % 2 != 0:\n        # Possibly the first number is n and the rest are two arrays\n        # Try to interpret the first list as a single integer n\n        if len(lists) == 3 and isinstance(lists[0], int):\n            n = lists[0]\n            processors = lists[1]\n            tasks = lists[2]\n            print(solve_one(processors, tasks))\n            return\n        # Otherwise just ignore the last incomplete pair\n        lists = lists[:-1]\n\n    out = []\n    for i in range(0, len(lists), 2):\n        processors = lists[i]\n        tasks = lists[i + 1]\n        out.append(solve_one(processors, tasks))\n\n    sys.stdout.write(\"\\n\".join(out))\n\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/3151.json"
        },
        {
            "question_id": "2844",
            "difficulty": "easy",
            "total_time": 37.847986698150635,
            "code_generation_time": 37.24095153808594,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 2224,
            "total_output_tokens": 2303,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    # Read entire input\n    data = sys.stdin.read()\n    if not data.strip():\n        return\n\n    # Remove all whitespace to simplify parsing\n    compact = ''.join(data.split())\n\n    # Strip surrounding brackets if present\n    if compact.startswith('[') and compact.endswith(']'):\n        compact = compact[1:-1]\n\n    # Handle empty array\n    if compact == '':\n        nums = []\n    else:\n        nums = [int(x) for x in compact.split(',')]\n\n    n = len(nums)\n    sum_sq = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            val = nums[i - 1]\n            sum_sq += val * val\n\n    print(sum_sq)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/2844.json"
        },
        {
            "question_id": "abc341_d",
            "difficulty": "medium",
            "total_time": 49.73792219161987,
            "code_generation_time": 49.52502679824829,
            "passed_tests": 32,
            "total_tests": 32,
            "success_rate": 1.0,
            "total_input_tokens": 2269,
            "total_output_tokens": 3180,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport math\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    M = int(next(it))\n    K = int(next(it))\n\n    g = math.gcd(N, M)\n    L = (N // g) * M          # lcm, safe from overflow\n    maxNM = N if N > M else M\n\n    low = 1\n    high = K * maxNM          # upper bound that surely contains the answer\n\n    while low < high:\n        mid = (low + high) // 2\n        cnt = mid // N + mid // M - 2 * (mid // L)\n        if cnt >= K:\n            high = mid\n        else:\n            low = mid + 1\n\n    print(low)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc341_d.json"
        },
        {
            "question_id": "2816",
            "difficulty": "easy",
            "total_time": 372.03287172317505,
            "code_generation_time": 371.43067145347595,
            "passed_tests": 0,
            "total_tests": 100,
            "success_rate": 0.0,
            "total_input_tokens": 8556,
            "total_output_tokens": 24749,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    # Take the first token as the string, strip possible surrounding quotes\n    s = data[0].strip('\"').strip(\"'\")\n    n = len(s)\n    chars = list(s)\n    for i in range(n // 2):\n        j = n - 1 - i\n        if chars[i] != chars[j]:\n            # choose the smaller character\n            if chars[i] < chars[j]:\n                chars[j] = chars[i]\n            else:\n                chars[i] = chars[j]\n    result = ''.join(chars)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/2816.json"
        },
        {
            "question_id": "abc343_d",
            "difficulty": "medium",
            "total_time": 42.848124980926514,
            "code_generation_time": 41.93156361579895,
            "passed_tests": 19,
            "total_tests": 19,
            "success_rate": 1.0,
            "total_input_tokens": 3410,
            "total_output_tokens": 2590,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    T = int(next(it))\n\n    # current score of each player (1-indexed)\n    score = [0] * (N + 1)\n\n    # frequency of each score\n    freq = {0: N}\n    distinct = 1\n\n    out_lines = []\n\n    for _ in range(T):\n        a = int(next(it))\n        b = int(next(it))\n\n        old = score[a]\n        new = old + b\n        score[a] = new\n\n        # remove one from old score\n        cnt_old = freq[old] - 1\n        if cnt_old == 0:\n            del freq[old]\n            distinct -= 1\n        else:\n            freq[old] = cnt_old\n\n        # add one to new score\n        if new in freq:\n            freq[new] += 1\n        else:\n            freq[new] = 1\n            distinct += 1\n\n        out_lines.append(str(distinct))\n\n    sys.stdout.write(\"\\n\".join(out_lines))\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc343_d.json"
        },
        {
            "question_id": "abc305_e",
            "difficulty": "hard",
            "total_time": 369.9472918510437,
            "code_generation_time": 366.38481402397156,
            "passed_tests": 31,
            "total_tests": 31,
            "success_rate": 1.0,
            "total_input_tokens": 14484,
            "total_output_tokens": 23559,
            "error": null,
            "traceback": null,
            "code": "import sys\nimport heapq\nfrom typing import List, Tuple\n\n# -------------------------------------------------------------\n\ndef solve() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n\n    N = int(next(it))\n    M = int(next(it))\n    K = int(next(it))\n\n    # adjacency list: g[v] contains all neighbours of v\n    g: List[List[int]] = [[] for _ in range(N + 1)]\n    for _ in range(M):\n        a = int(next(it))\n        b = int(next(it))\n        g[a].append(b)\n        g[b].append(a)\n\n    INF = 10 ** 18\n    dist: List[int] = [INF] * (N + 1)\n\n    # priority queue for Dijkstra: (distance, vertex)\n    pq: List[Tuple[int, int]] = []\n\n    for _ in range(K):\n        p = int(next(it))\n        h = int(next(it))\n        if -h < dist[p]:\n            dist[p] = -h\n            heapq.heappush(pq, (dist[p], p))\n\n    # Dijkstra with initial negative distances\n    while pq:\n        d, v = heapq.heappop(pq)\n        if d != dist[v]:\n            continue\n        nd = d + 1\n        for nv in g[v]:\n            if nd < dist[nv]:\n                dist[nv] = nd\n                heapq.heappush(pq, (nd, nv))\n\n    guarded = [str(v) for v in range(1, N + 1) if dist[v] <= 0]\n    print(len(guarded))\n    if guarded:\n        print(' '.join(guarded))\n\n# -------------------------------------------------------------\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/abc305_e.json"
        },
        {
            "question_id": "abc311_c",
            "difficulty": "medium",
            "total_time": 406.963339805603,
            "code_generation_time": 406.1442267894745,
            "passed_tests": 14,
            "total_tests": 51,
            "success_rate": 0.27,
            "total_input_tokens": 17245,
            "total_output_tokens": 26452,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    A = [0] * (n + 1)          # 1\u2011based\n    for i in range(1, n + 1):\n        A[i] = int(next(it))\n\n    visited = [0] * (n + 1)    # 0 = unvisited, else walk id\n    pos = [0] * (n + 1)        # position in current path\n\n    walk_id = 1\n    for start in range(1, n + 1):\n        if visited[start] != 0:\n            continue\n        cur = start\n        path: list[int] = []   # type annotation for mypy\n        while visited[cur] == 0:\n            visited[cur] = walk_id\n            pos[cur] = len(path)\n            path.append(cur)\n            cur = A[cur]\n        if visited[cur] == walk_id:          # cycle found\n            cycle_start = pos[cur]\n            cycle = path[cycle_start:]\n            print(len(cycle))\n            print(' '.join(map(str, cycle)))\n            return\n        walk_id += 1\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc311_c.json"
        },
        {
            "question_id": "abc326_e",
            "difficulty": "hard",
            "total_time": 127.86635255813599,
            "code_generation_time": 127.09710502624512,
            "passed_tests": 27,
            "total_tests": 27,
            "success_rate": 1.0,
            "total_input_tokens": 3715,
            "total_output_tokens": 8426,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = 998244353\n\ndef solve() -> None:\n    data = sys.stdin.read().strip().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    # 1\u2011based array for A\n    A = [0] * (N + 1)\n    for i in range(1, N + 1):\n        A[i] = int(next(it))\n\n    invN = pow(N, MOD - 2, MOD)          # modular inverse of N\n\n    # suffix sums of A\n    suffA = [0] * (N + 2)                # suffA[N+1] = 0\n    for i in range(N, 0, -1):\n        suffA[i] = (suffA[i + 1] + A[i]) % MOD\n\n    E = [0] * (N + 1)                    # E[N] = 0\n    suffE = [0] * (N + 2)                # suffE[N+1] = 0\n\n    # compute from N-1 down to 0\n    for x in range(N - 1, -1, -1):\n        val = (suffA[x + 1] + suffE[x + 1]) % MOD\n        E[x] = val * invN % MOD\n        suffE[x] = (suffE[x + 1] + E[x]) % MOD\n\n    print(E[0] % MOD)\n\nif __name__ == \"__main__\":\n    solve()",
            "history_file": "gpt-oss_20b/abc326_e.json"
        },
        {
            "question_id": "3298",
            "difficulty": "hard",
            "total_time": 948.2749366760254,
            "code_generation_time": 947.4580328464508,
            "passed_tests": 64,
            "total_tests": 100,
            "success_rate": 0.64,
            "total_input_tokens": 9462,
            "total_output_tokens": 64162,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef max_consecutive_after_increment(nums):\n    nums.sort()\n    best = 0\n    last = -10**9  # sentinel smaller than any possible value\n    cur_len = 0\n    for v in nums:\n        if v > last + 1:\n            # cannot extend, start new sequence\n            last = v\n            cur_len = 1\n        elif v == last:\n            # increment this element to extend\n            last = v + 1\n            cur_len += 1\n        elif v == last + 1:\n            # use this element as is\n            last = v\n            cur_len += 1\n        # else: v < last or v == last - 1, cannot use\n        if cur_len > best:\n            best = cur_len\n    return best\n\ndef parse_input(data):\n    data = data.strip()\n    if not data:\n        return []\n    # Remove surrounding brackets if present\n    if data[0] == '[' and data[-1] == ']':\n        data = data[1:-1]\n    # Split by commas\n    parts = data.split(',')\n    nums = []\n    for p in parts:\n        p = p.strip()\n        if p:\n            nums.append(int(p))\n    return nums\n\ndef main():\n    input_data = sys.stdin.read()\n    if not input_data.strip():\n        return\n    nums = parse_input(input_data)\n    result = max_consecutive_after_increment(nums)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/3298.json"
        },
        {
            "question_id": "2824",
            "difficulty": "easy",
            "total_time": 20.471313953399658,
            "code_generation_time": 19.838598489761353,
            "passed_tests": 100,
            "total_tests": 100,
            "success_rate": 1.0,
            "total_input_tokens": 1975,
            "total_output_tokens": 1086,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main():\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    n = int(data[0])\n\n    a = n\n    b = 2 * n\n    c = 3 * n\n\n    s = f\"{a}{b}{c}\"\n\n    if len(s) != 9 or '0' in s:\n        print(\"false\")\n        return\n\n    if set(s) == set('123456789'):\n        print(\"true\")\n    else:\n        print(\"false\")\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/2824.json"
        },
        {
            "question_id": "abc313_c",
            "difficulty": "medium",
            "total_time": 33.253743171691895,
            "code_generation_time": 32.74486470222473,
            "passed_tests": 27,
            "total_tests": 27,
            "success_rate": 1.0,
            "total_input_tokens": 2339,
            "total_output_tokens": 1988,
            "error": null,
            "traceback": null,
            "code": "import sys\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    n = int(next(it))\n    a = [int(next(it)) for _ in range(n)]\n\n    total = sum(a)\n    q = total // n\n    r = total % n\n\n    a.sort()\n    ans = 0\n    # first n - r elements should be q, last r elements should be q+1\n    limit = n - r\n    for i in range(n):\n        target = q if i < limit else q + 1\n        if a[i] > target:\n            ans += a[i] - target\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc313_c.json"
        },
        {
            "question_id": "abc307_e",
            "difficulty": "hard",
            "total_time": 33.846797466278076,
            "code_generation_time": 33.65680456161499,
            "passed_tests": 21,
            "total_tests": 21,
            "success_rate": 1.0,
            "total_input_tokens": 2092,
            "total_output_tokens": 2079,
            "error": null,
            "traceback": null,
            "code": "import sys\n\nMOD = 998244353\n\ndef main() -> None:\n    data = sys.stdin.read().split()\n    if not data:\n        return\n    it = iter(data)\n    N = int(next(it))\n    M = int(next(it))\n\n    a = (M - 1) % MOD\n    pow_a_N = pow(a, N, MOD)\n\n    if N % 2 == 0:\n        ans = (pow_a_N + a) % MOD\n    else:\n        ans = (pow_a_N - a) % MOD  # Python handles negative modulo\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()",
            "history_file": "gpt-oss_20b/abc307_e.json"
        }
    ]
}